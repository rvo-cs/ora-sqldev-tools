<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<folder>
<name><![CDATA[ASH]]></name>
<display id="199004a4-bf3b-486b-a9fa-8a4cf086ffcd" type="" style="Table" enable="true">
	<name><![CDATA[Live ASH - Enh. session viewer]]></name>
	<description><![CDATA[A session viewer, enhanced with ASH data over the last 20 seconds]]></description>
	<tooltip><![CDATA[A session viewer, with data from ASH over the last 20 seconds]]></tooltip>
	<drillclass><![CDATA[]]></drillclass>
	<CustomValues>
		<TYPE><![CDATA[horizontal]]></TYPE>
	</CustomValues>
    <queries>
        <query minversion="12.1">
            <sql><![CDATA[select
    :INST_ID                             as "Inst#",
    :CON_NAME_RE                         as "Con_name_RE",
    :SERVICE_RE                          as "Service_RE",
    :USERNAME_LIKE                       as "Username_like",
    :USERNAME_RE                         as "Username_RE",
    :LIVE_SESSIONS_ONLY                  as "Live_sessions_only",
    :SESSION_INACTIVITY_THRES            as "Inactive_thres",
    :SHOW_BACKGROUND                     as "Show_background",
    :SHOW_IDLE_BACKGROUND                as "Show_idle_background",
    :DISPLAY_PLAN_OPTS                   as "Plan_display_opts",
    nvl(:SNAPPER_INTERVAL, 20)           as "Snapper_interval",
    nvl(:ASH_TIME_SPAN_MIN, 10)          as "Ash_time_span",
    nvl(:ASH_TIME_BUCKET_SEC, 60)        as "Ash_time_bucket",
    :ASH_SUMMARY_TIME_SPAN_MIN           as "Ash_summary_mins",
    nvl(:SPOOL_DIR, :DEFAULT_SPOOL_DIR)  as "Spool_directory",
    -- XMLType for passing binds to child reports as a single column
    xmlserialize(
        document
        xmlelement("bindData",
            xmlforest(
                :DISPLAY_PLAN_OPTS                  as "planDisplayOpts",
                nvl(:SNAPPER_INTERVAL, 20)          as "snapperInterval",
                nvl(:ASH_TIME_SPAN_MIN, 10)         as "ashTimespan",
                nvl(:ASH_TIME_BUCKET_SEC, 60)       as "ashTimeBucket",
                :ASH_SUMMARY_TIME_SPAN_MIN          as "ashSummaryTimespan",
                nvl(:SPOOL_DIR, :DEFAULT_SPOOL_DIR) as "spoolDirectory",
                :TPT_ORACLE_DIR                     as "TPTOracleDir"
            ))
        as varchar2(2000)
    ) as "Xml_bind_data"
from
    dual]]></sql>
            <binds>
                <bind id="INST_ID">
                    <prompt><![CDATA[Instance number?]]></prompt>
                    <tooltip><![CDATA[Instance number; null = show all instances]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="CON_NAME_RE">
                    <prompt><![CDATA[Container name regexp?]]></prompt>
                    <tooltip><![CDATA[Show only matching containers (regexp, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="USERNAME_LIKE">
                    <prompt><![CDATA[Username like?]]></prompt>
                    <tooltip><![CDATA[Show only sessions of matching users (LIKE pattern, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="USERNAME_RE">
                    <prompt><![CDATA[Username regexp?]]></prompt>
                    <tooltip><![CDATA[Show only sessions of matching users (regexp, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SERVICE_RE">
                    <prompt><![CDATA[Service name regexp?]]></prompt>
                    <tooltip><![CDATA[Show only matching services (regexp, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="LIVE_SESSIONS_ONLY">
                    <prompt><![CDATA[Live sessions only?]]></prompt>
                    <tooltip><![CDATA[Exclude ended sessions iff 'Y']]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SESSION_INACTIVITY_THRES">
                    <prompt><![CDATA[Inactivity threshold?]]></prompt>
                    <tooltip><![CDATA[Hide sessions if inactive for more than the specified amount of time; unit: s; 0 or null = unlimited]]></tooltip>
                    <value><![CDATA[60]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SHOW_BACKGROUND">
                    <prompt><![CDATA[Include background?]]></prompt>
                    <tooltip><![CDATA[Show background processes iff 'Y']]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SHOW_IDLE_BACKGROUND">
                    <prompt><![CDATA[Show idle background?]]></prompt>
                    <tooltip><![CDATA[Show idle background processes iff 'Y']]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="DISPLAY_PLAN_OPTS">
                    <prompt><![CDATA[Plan display options?]]></prompt>
                    <tooltip><![CDATA[Additional plan display options]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SNAPPER_INTERVAL">
                    <prompt><![CDATA[Snapper interval time?]]></prompt>
                    <tooltip><![CDATA[Snapper interval time (s); default: 20 s]]></tooltip>
                    <value><![CDATA[20]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="ASH_TIME_SPAN_MIN">
                    <prompt><![CDATA[ASH report mins?]]></prompt>
                    <tooltip><![CDATA[ASH Report time span; unit: min, default: 10]]></tooltip>
                    <value><![CDATA[10]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="ASH_TIME_BUCKET_SEC">
                    <prompt><![CDATA[ASH time bucket length?]]></prompt>
                    <tooltip><![CDATA[ASH Report time bucket length; unit: s, default: 60]]></tooltip>
                    <value><![CDATA[60]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="ASH_SUMMARY_TIME_SPAN_MIN">
                    <prompt><![CDATA[ASH summary minutes?]]></prompt>
                    <tooltip><![CDATA[ASH Summary time span; unit: min, default: 60]]></tooltip>
                    <value><![CDATA[60]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SPOOL_DIR">
                    <prompt><![CDATA[Spool directory?]]></prompt>
                    <tooltip><![CDATA[Directory where ASH reports will be spooled]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="DEFAULT_SPOOL_DIR">
                    <prompt><![CDATA[Default spool directory?]]></prompt>
                    <tooltip><![CDATA[Default spool directory]]></tooltip>
                    <!--##USER_CONFIG##--><value><![CDATA[E:\Home\romain\SQL_Developer\output\ash_html]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="TPT_ORACLE_DIR">
                    <prompt><![CDATA[tpt-oracle root directory?]]></prompt>
                    <tooltip><![CDATA[Local directory for tpt-oracle scripts (source: https://github.com/tanelpoder/tpt-oracle)]]></tooltip>
                    <!--##USER_CONFIG##--><value><![CDATA[F:\Products\Contrib\git-src\tpt-oracle]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
        <query>
            <sql><![CDATA[select
    :INST_ID                             as "Inst#",
    :SERVICE_RE                          as "Service_RE",
    :USERNAME_LIKE                       as "Username_like",
    :USERNAME_RE                         as "Username_RE",
    :LIVE_SESSIONS_ONLY                  as "Live_sessions_only",
    :SESSION_INACTIVITY_THRES            as "Inactive_thres",
    :SHOW_BACKGROUND                     as "Show_background",
    :SHOW_IDLE_BACKGROUND                as "Show_idle_background",
    :DISPLAY_PLAN_OPTS                   as "Plan_display_opts",
    nvl(:SNAPPER_INTERVAL, 20)           as "Snapper_interval",
    nvl(:ASH_TIME_SPAN_MIN, 10)          as "Ash_time_span",
    nvl(:ASH_TIME_BUCKET_SEC, 60)        as "Ash_time_bucket",
    :ASH_SUMMARY_TIME_SPAN_MIN           as "Ash_summary_mins",
    nvl(:SPOOL_DIR, :DEFAULT_SPOOL_DIR)  as "Spool_directory",
    -- XMLType for passing binds to child reports as a single column
    xmlserialize(
        document
        xmlelement("bindData",
            xmlforest(
                :DISPLAY_PLAN_OPTS                  as "planDisplayOpts",
                nvl(:SNAPPER_INTERVAL, 20)          as "snapperInterval",
                nvl(:ASH_TIME_SPAN_MIN, 10)         as "ashTimespan",
                nvl(:ASH_TIME_BUCKET_SEC, 60)       as "ashTimeBucket",
                :ASH_SUMMARY_TIME_SPAN_MIN          as "ashSummaryTimespan",
                nvl(:SPOOL_DIR, :DEFAULT_SPOOL_DIR) as "spoolDirectory",
                :TPT_ORACLE_DIR                     as "TPTOracleDir"
            ))
        as varchar2(2000)
    ) as "Xml_bind_data"
from
    dual]]></sql>
            <binds>
                <bind id="INST_ID">
                    <prompt><![CDATA[Instance number?]]></prompt>
                    <tooltip><![CDATA[Instance number; null = show all instances]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="USERNAME_LIKE">
                    <prompt><![CDATA[Username like?]]></prompt>
                    <tooltip><![CDATA[Show only sessions of matching users (LIKE pattern, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="USERNAME_RE">
                    <prompt><![CDATA[Username regexp?]]></prompt>
                    <tooltip><![CDATA[Show only sessions of matching users (regexp, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SERVICE_RE">
                    <prompt><![CDATA[Service name regexp?]]></prompt>
                    <tooltip><![CDATA[Show only matching services (regexp, CI)]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="LIVE_SESSIONS_ONLY">
                    <prompt><![CDATA[Live sessions only?]]></prompt>
                    <tooltip><![CDATA[Exclude ended sessions iff 'Y']]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SESSION_INACTIVITY_THRES">
                    <prompt><![CDATA[Inactivity threshold?]]></prompt>
                    <tooltip><![CDATA[Hide sessions if inactive for more than the specified amount of time; unit: s; 0 or null = unlimited]]></tooltip>
                    <value><![CDATA[60]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SHOW_BACKGROUND">
                    <prompt><![CDATA[Include background?]]></prompt>
                    <tooltip><![CDATA[Show background processes iff 'Y']]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SHOW_IDLE_BACKGROUND">
                    <prompt><![CDATA[Show idle background?]]></prompt>
                    <tooltip><![CDATA[Show idle background processes iff 'Y']]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="DISPLAY_PLAN_OPTS">
                    <prompt><![CDATA[Plan display options?]]></prompt>
                    <tooltip><![CDATA[Additional plan display options]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SNAPPER_INTERVAL">
                    <prompt><![CDATA[Snapper interval time?]]></prompt>
                    <tooltip><![CDATA[Snapper interval time (s); default: 20 s]]></tooltip>
                    <value><![CDATA[20]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="ASH_TIME_SPAN_MIN">
                    <prompt><![CDATA[ASH report mins?]]></prompt>
                    <tooltip><![CDATA[ASH Report time span; unit: min, default: 10]]></tooltip>
                    <value><![CDATA[10]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="ASH_TIME_BUCKET_SEC">
                    <prompt><![CDATA[ASH time bucket length?]]></prompt>
                    <tooltip><![CDATA[ASH Report time bucket length; unit: s, default: 60]]></tooltip>
                    <value><![CDATA[60]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="ASH_SUMMARY_TIME_SPAN_MIN">
                    <prompt><![CDATA[ASH summary minutes?]]></prompt>
                    <tooltip><![CDATA[ASH Summary time span; unit: min, default: 60]]></tooltip>
                    <value><![CDATA[60]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SPOOL_DIR">
                    <prompt><![CDATA[Spool directory?]]></prompt>
                    <tooltip><![CDATA[Directory where ASH reports will be spooled]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="DEFAULT_SPOOL_DIR">
                    <prompt><![CDATA[Default spool directory?]]></prompt>
                    <tooltip><![CDATA[Default spool directory]]></tooltip>
                    <!--##USER_CONFIG##--><value><![CDATA[E:\Home\romain\SQL_Developer\output\ash_html]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="TPT_ORACLE_DIR">
                    <prompt><![CDATA[tpt-oracle root directory?]]></prompt>
                    <tooltip><![CDATA[Local directory for tpt-oracle scripts (source: https://github.com/tanelpoder/tpt-oracle)]]></tooltip>
                    <!--##USER_CONFIG##--><value><![CDATA[F:\Products\Contrib\git-src\tpt-oracle]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
    </queries>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Sessions]]></name>
		<description><![CDATA[List of sessions]]></description>
		<tooltip><![CDATA[List of sessions. Don't forget to click on the parent row for filters to be applied.]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
            <query minversion="12.1">
                <sql><![CDATA[with
live_sessions as (
    select
        se.inst_id,
        se.sid, 
        se.serial#,             -- ASH: session_serial#
        se.service_name,        -- ASH: service_hash
        se.type,                -- ASH: session_type
        case
            when se.type = 'BACKGROUND'
                and se.time_remaining_micro is not null
                and se.state = 'WAITING'
                and se.wait_class = 'Idle'
            then
                null
            else
                se.status       -- ASH: implicitly always ACTIVE
        end  as status,
        cm.command_name  as command,
        se.username,            -- ASH: user_id
        se.schemaname,          -- ASH: n/a
        se.osuser,              -- ASH: n/a
        se.process,             -- Foreground: client OS process id;   ASH: n/a
        se.machine,             -- Foreground: client OS machine name; ASH: n/a
        se.program,             -- Foreground: client program name;    ASH: n/a
        se.logon_time,          -- ASH: n/a
        se.module,
        se.action,
        se.client_identifier,   -- ASH: client id
        se.client_info,         -- ASH: n/a
        se.sql_id,
        case
            when se.sql_id is null then
                null
            else
                se.sql_child_number
        end  as sql_child_number,
        se.sql_exec_id,
        se.sql_exec_start,
        se.prev_sql_id,         -- ASH: n/a
        case
            when se.prev_sql_id is null then
                null
            else
                se.prev_child_number
        end  as prev_child_number,
        se.prev_exec_id,        -- ASH: n/a
        se.prev_exec_start,     -- ASH: n/a
        tc.top_level_call_name,
        se.last_call_et,        -- ASH: n/a
        case 
            when se.time_remaining_micro is null then
                'ON CPU' 
            else
                se.state
        end  as state,          -- ASH: session_state
        se.wait_class,
        se.event,
        round(se.wait_time_micro / power(10, 3), 1)             as wait_time_ms,            -- ASH: n/a
        round(se.time_remaining_micro / power(10, 3), 1)        as time_remaining_ms,       -- ASH: n/a 
        round(se.time_since_last_wait_micro / power(10, 3), 1)  as time_since_last_wait_ms, -- ASH: n/a
        se.plsql_entry_object_id,
        se.plsql_entry_subprogram_id,
        se.plsql_object_id,
        se.plsql_subprogram_id,
        se.pdml_status,         -- ASH: n/a
        se.pddl_status,         -- ASH: n/a
        se.pq_status,           -- ASH: n/a
        case
            when px.qcsid is null then 
                'N' 
            else
                'Y' 
        end  as is_px_qry,
        case
            when px.qcsid = se.sid 
                and lnnvl(px.qcinst_id <> sys_context('USERENV', 'INSTANCE')) 
            then
                'Y' 
            when px.qcsid is not null then
                'N' 
        end  as is_px_qc,
        px.qcinst_id,
        px.qcsid,
        px.qcserial#, 
        se.blocking_session_status,
        se.blocking_instance,               -- ASH: blocking_inst_id
        se.blocking_session,                -- ASH: + blocking_session_serial#
        --se.row_wait_obj#,                   -- ASH: current_obj#
        --se.row_wait_file#,                  -- ASH: current_file#
        --se.row_wait_block#,                 -- ASH: current_block#
        --se.row_wait_row#,                   -- ASH: current_row#
        se.sql_trace,                       -- ASH: n/a
        se.sql_trace_waits,                 -- ASH: n/a
        se.sql_trace_binds,                 -- ASH: n/a
        se.sql_trace_plan_stats,            -- ASH: n/a
        se.ecid,
        se.resource_consumer_group,
        se.con_id                           -- 12.1 and higher
    from
        gv$session se,
        gv$px_session px,
        v$sqlcommand cm,
        v$toplevelcall tc
    where
        se.inst_id = px.inst_id (+)
        and se.saddr = px.saddr (+)
        and se.command = cm.command_type (+)
        and se.top_level_call# = tc.top_level_call# (+)
),
ash_sessions_last_20s as (
    select
        inst_id,
        sample_time,
        session_id,
        session_serial#,
        session_type,
        username,
        cnt_samp,
        cnt_sql_exec,
        sql_id,
        is_sqlid_current,
        sql_child_number,
        command,
        sql_exec_id,
        sql_exec_start,
        plsql_entry_object_id,
        plsql_entry_subprogram_id,
        plsql_object_id,
        plsql_subprogram_id,
        px_flags,
        qc_instance_id,
        qc_session_id,
        qc_session_serial#,
        session_state,
        wait_class,
        event,
        time_waited,
        blocking_session_status,
        blocking_session,
        blocking_session_serial#,
        blocking_inst_id,
        --current_obj#,
        --current_file#,
        --current_block#,
        --current_row#,
        top_level_call_name,
        consumer_group,
        cnt_xid,
        in_parse,
        in_hard_parse,
        in_sql_execution,
        in_plsql_execution,
        service_name,
        program,
        module,
        action,
        client_id,
        machine,
        ecid,
        cnt_ecid,
        tm_delta_time,
        tm_delta_cpu_time,
        tm_delta_db_time,
        tm_delta_cpu_time,
        case
            when tm_delta_cpu_time_ratio < power(10,-3) then
                0
            else
                tm_delta_cpu_time_ratio
        end  as tm_delta_cpu_time_ratio,
        case
            when tm_delta_db_time_ratio < power(10,-3) then
                0
            else
                tm_delta_db_time_ratio
        end  as tm_delta_db_time_ratio,
        delta_time,
        delta_read_io_requests,
        delta_write_io_requests,
        delta_read_io_bytes,
        delta_write_io_bytes,
        delta_interconnect_io_bytes,
        delta_read_iops,
        delta_write_iops,
        delta_iops,
        delta_read_mbps,
        delta_write_mbps,
        delta_interconnect_mbps,
        pga_allocated_mb,
        max_pga_allocated_mb,
        temp_space_allocated_mb,
        max_temp_space_allocated_mb,
        con_id                      -- 12.1 and higher
    from
        (select
            ash.inst_id,
            ash.sample_time,
            ash.session_id,
            ash.session_serial#,
            ash.session_type,
            usr.username,
            ash.cnt_samp,
            ash.cnt_sql_exec,
            ash.sql_id,
            ash.is_sqlid_current,
            ash.sql_child_number,
            cmd.command_name  as command,
            ash.sql_exec_id,
            ash.sql_exec_start,
            ash.plsql_entry_object_id,
            ash.plsql_entry_subprogram_id,
            ash.plsql_object_id,
            ash.plsql_subprogram_id,
            ash.px_flags,
            ash.qc_instance_id,
            ash.qc_session_id,
            ash.qc_session_serial#,
            ash.session_state,
            ash.wait_class,
            ash.event,
            ash.time_waited,
            ash.blocking_session_status,
            ash.blocking_session,
            ash.blocking_session_serial#,
            ash.blocking_inst_id,
            --ash.current_obj#,
            --ash.current_file#,
            --ash.current_block#,
            --ash.current_row#,
            ash.top_level_call_name,
            rcg.consumer_group,
            ash.cnt_xid,
            ash.in_parse,
            ash.in_hard_parse,
            ash.in_sql_execution,
            ash.in_plsql_execution,
            svc.name  as service_name,
            ash.program,
            ash.module,
            ash.action,
            ash.client_id,
            ash.machine,
            ash.ecid,
            ash.cnt_ecid,
            ash.tm_delta_time,
            ash.tm_delta_cpu_time,
            ash.tm_delta_db_time,
            ash.tm_delta_cpu_time
                    / greatest(nullif(ash.tm_delta_time, 0),
                               19 * power(10,6))                as tm_delta_cpu_time_ratio,
            ash.tm_delta_db_time
                    / greatest(nullif(ash.tm_delta_time, 0),
                               19 * power(10,6))                as tm_delta_db_time_ratio,
            ash.delta_time,
            ash.delta_read_io_requests,
            ash.delta_write_io_requests,
            ash.delta_read_io_bytes,
            ash.delta_write_io_bytes,
            ash.delta_interconnect_io_bytes,
            ash.delta_read_io_requests 
                    * power(10, 6) 
                    / greatest(nullif(ash.delta_time, 0), 
                               19 * power(10,6))                as delta_read_iops,
            ash.delta_write_io_requests
                    * power(10, 6) 
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))                as delta_write_iops,
            (ash.delta_read_io_requests + ash.delta_write_io_requests)
                    * power(10, 6) 
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))                as delta_iops,
            ash.delta_read_io_bytes
                    * power(10, 6)
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))
                    / power(2, 20)                              as delta_read_mbps,
            ash.delta_write_io_bytes
                    * power(10, 6)
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))
                    / power(2, 20)                              as delta_write_mbps,
            ash.delta_interconnect_io_bytes
                    * power(10, 6)
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))
                    / power(2, 20)                              as delta_interconnect_mbps,
            ash.pga_allocated / power(2, 20)                    as pga_allocated_mb,
            ash.max_pga_allocated / power(2, 20)                as max_pga_allocated_mb,
            ash.temp_space_allocated / power(2, 20)             as temp_space_allocated_mb,
            ash.max_temp_space_allocated / power(2, 20)         as max_temp_space_allocated_mb,
            ash.con_id              -- 12.1 and higher
        from
            (select
                inst_id,
                max(sample_time)
                        keep (dense_rank first order by sample_id desc) as sample_time,
                session_id,
                session_serial#,
                session_type,
                user_id,
                count(*)  as cnt_samp,
                count(distinct case
                                   when is_sqlid_current = 'Y' then
                                       to_char(inst_id) || ':' || sql_id 
                                       || ',' || to_char(sql_exec_id)
                                       || ',' || to_char(sql_exec_start, 
                                                         'YYYYMMDDHH24MISS')
                               end)                                     as cnt_sql_exec,
                max(sql_id)
                        keep (dense_rank first order by sample_id desc) as sql_id,
                max(is_sqlid_current)
                        keep (dense_rank first order by sample_id desc) as is_sqlid_current,
                max(sql_child_number)
                        keep (dense_rank first order by sample_id desc) as sql_child_number,
                max(sql_opcode)
                        keep (dense_rank first order by sample_id desc) as sql_opcode,
                max(sql_exec_id)
                        keep (dense_rank first order by sample_id desc) as sql_exec_id,
                max(sql_exec_start)
                        keep (dense_rank first order by sample_id desc) as sql_exec_start,
                max(plsql_entry_object_id)
                        keep (dense_rank first order by sample_id desc) as plsql_entry_object_id,
                max(plsql_entry_subprogram_id)
                        keep (dense_rank first order by sample_id desc) as plsql_entry_subprogram_id,
                max(plsql_object_id)
                        keep (dense_rank first order by sample_id desc) as plsql_object_id,
                max(plsql_subprogram_id)
                        keep (dense_rank first order by sample_id desc) as plsql_subprogram_id,
                max(px_flags)
                        keep (dense_rank first order by sample_id desc) as px_flags,
                qc_instance_id,
                qc_session_id,
                qc_session_serial#,
                max(session_state)
                        keep (dense_rank first order by sample_id desc) as session_state,
                max(wait_class)
                        keep (dense_rank first order by sample_id desc) as wait_class,
                max(event)
                        keep (dense_rank first order by sample_id desc) as event,
                max(time_waited)
                        keep (dense_rank first order by sample_id desc) as time_waited,
                max(blocking_session_status)
                        keep (dense_rank first order by sample_id desc) as blocking_session_status,
                max(blocking_session)
                        keep (dense_rank first order by sample_id desc) as blocking_session,
                max(blocking_session_serial#)
                        keep (dense_rank first order by sample_id desc) as blocking_session_serial#,
                max(blocking_inst_id)
                        keep (dense_rank first order by sample_id desc) as blocking_inst_id,
                --max(current_obj#)
                --        keep (dense_rank first order by sample_id desc) as current_obj#,
                --max(current_file#)
                --        keep (dense_rank first order by sample_id desc) as current_file#,
                --max(current_block#)
                --        keep (dense_rank first order by sample_id desc) as current_block#,
                --max(current_row#)
                --        keep (dense_rank first order by sample_id desc) as current_row#,
                max(top_level_call_name)
                        keep (dense_rank first order by sample_id desc) as top_level_call_name,
                max(consumer_group_id)
                        keep (dense_rank first order by sample_id desc) as consumer_group_id,
                count(distinct xid)                                     as cnt_xid,
                max(in_parse)
                        keep (dense_rank first order by sample_id desc) as in_parse,
                max(in_hard_parse)
                        keep (dense_rank first order by sample_id desc) as in_hard_parse,
                max(in_sql_execution)
                        keep (dense_rank first order by sample_id desc) as in_sql_execution,
                max(in_plsql_execution)
                        keep (dense_rank first order by sample_id desc) as in_plsql_execution,
                service_hash,
                max(program)
                        keep (dense_rank first order by sample_id desc) as program,
                max(module)
                        keep (dense_rank first order by sample_id desc) as module,
                max(action)
                        keep (dense_rank first order by sample_id desc) as action,
                max(client_id)
                        keep (dense_rank first order by sample_id desc) as client_id,
                max(machine)
                        keep (dense_rank first order by sample_id desc) as machine,
                max(ecid)
                        keep (dense_rank first order by sample_id desc) as ecid,
                count(distinct ecid)                                    as cnt_ecid,
                sum(tm_delta_time)                                      as tm_delta_time,
                sum(tm_delta_cpu_time)                                  as tm_delta_cpu_time,
                sum(tm_delta_db_time)                                   as tm_delta_db_time,
                sum(delta_time)                                         as delta_time,
                sum(delta_read_io_requests)                             as delta_read_io_requests,
                sum(delta_write_io_requests)                            as delta_write_io_requests,
                sum(delta_read_io_bytes)                                as delta_read_io_bytes,
                sum(delta_write_io_bytes)                               as delta_write_io_bytes,
                sum(delta_interconnect_io_bytes)                        as delta_interconnect_io_bytes,
                max(pga_allocated)
                        keep (dense_rank first order by sample_id desc) as pga_allocated,
                max(pga_allocated)                                      as max_pga_allocated,
                max(temp_space_allocated)
                        keep (dense_rank first order by sample_id desc) as temp_space_allocated,
                max(temp_space_allocated)                               as max_temp_space_allocated,
                max(con_id)
                        keep (dense_rank first order by sample_id desc) as con_id   -- 12.1 and higher
            from
                gv$active_session_history
            where
                sample_time >= localtimestamp - numtodsinterval(20, 'SECOND')
            group by
                inst_id,
                session_id,
                session_serial#,
                session_type,
                user_id,
                qc_instance_id,
                qc_session_id,
                qc_session_serial#,
                service_hash
            ) ash,
            all_users usr,
            gv$services svc,
            v$sqlcommand cmd,
            dba_rsrc_consumer_groups rcg
        where
            ash.user_id = usr.user_id (+)
            and ash.inst_id = svc.inst_id (+)
            and ash.service_hash = svc.name_hash (+)
            and ash.sql_opcode = cmd.command_type (+)
            and ash.consumer_group_id = rcg.consumer_group_id (+)
            and rcg.status (+) is null  -- ignore PENDING changes to consumer groups
        )
),
live_and_recent_sessions as (
    select
        'LIVE' as src,
        liv.inst_id,
        liv.con_id,         -- 12.1 and higher
        liv.service_name,
        liv.sid,
        liv.serial#,
        liv.type,
        liv.status,
        ash.cnt_samp            as ash_cnt_samp,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_cpu_time_ratio)  as avg_cpu_pct,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_db_time_ratio)   as avg_activ_pct,
        ash.cnt_sql_exec        as ash_cnt_sql_exec,
        nullif(ash.cnt_xid, 0)  as ash_cnt_xid,
        liv.command,
        liv.username,
        liv.schemaname,
        liv.osuser,
        liv.process,
        liv.machine,
        liv.program,
        liv.logon_time,
        liv.module,
        liv.action,
        liv.client_identifier,
        liv.client_info,
        liv.sql_id,
        liv.sql_child_number,
        liv.sql_exec_id,
        liv.sql_exec_start,
        liv.prev_sql_id,
        liv.prev_child_number,
        liv.prev_exec_id,
        liv.prev_exec_start,
        liv.top_level_call_name,
        liv.last_call_et,
        liv.state,
        liv.wait_class,
        liv.event,
        liv.wait_time_ms,
        liv.time_remaining_ms,
        liv.time_since_last_wait_ms,
        liv.plsql_entry_object_id,
        liv.plsql_entry_subprogram_id,
        liv.plsql_object_id,
        liv.plsql_subprogram_id,
        liv.ecid,
        nullif(ash.cnt_ecid, 0)             as ash_cnt_ecid,
        liv.pdml_status,
        liv.pddl_status,
        liv.pq_status,
        liv.is_px_qry,
        liv.is_px_qc,
        liv.qcinst_id                       as qc_inst_id,
        liv.qcsid                           as qc_sid,
        liv.qcserial#                       as qc_serial#, 
        liv.blocking_session_status,
        liv.blocking_instance               as blocking_inst_id,
        liv.blocking_session,
        cast(null as number)                as blocking_serial#,
        liv.sql_trace,
        liv.sql_trace_waits,
        liv.sql_trace_binds,
        liv.sql_trace_plan_stats,
        liv.resource_consumer_group,
        ash.in_parse,
        ash.in_hard_parse,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_iops, 0))           as avg_read_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_iops, 0))          as avg_write_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_mbps, 0))           as avg_read_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_mbps, 0))          as avg_write_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_interconnect_mbps, 0))   as avg_interconnect_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.pga_allocated_mb, 0))          as ash_pga_alloc_mb,
        c##pkg_pub_utility.prec_round(nullif(ash.temp_space_allocated_mb, 0))   as ash_temp_space_mb
        --, c##pkg_pub_utility.prec_round(ash.max_pga_allocated_mb)                 as ash_max_pga_alloc_mb
        --, c##pkg_pub_utility.prec_round(ash.max_temp_space_allocated_mb)          as ash_max_temp_space_mb
        , localtimestamp                    as sample_time
    from
        live_sessions liv,
        ash_sessions_last_20s ash
    where
        liv.inst_id = ash.inst_id (+)
        and liv.sid = ash.session_id (+)
        and liv.serial# = ash.session_serial# (+)
    union all
    select
        'ASH'                   as src,
        ash.inst_id,
        ash.con_id,             -- 12.1 and higher
        ash.service_name,
        ash.session_id          as sid,
        ash.session_serial#     as serial#,
        case
            when ash.session_type = 'FOREGROUND' then
                'USER'
            else
                ash.session_type
        end                     as type,
        'ENDED'                 as status,
        ash.cnt_samp            as ash_cnt_samp,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_cpu_time_ratio)    as avg_cpu_pct,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_db_time_ratio)     as avg_activ_pct,
        ash.cnt_sql_exec        as ash_cnt_sql_exec,
        nullif(ash.cnt_xid, 0)  as ash_cnt_xid,
        ash.command,
        ash.username,
        cast(null as varchar2(30))  as schemaname,
        cast(null as varchar2(30))  as osuser,
        cast(null as varchar2(30))  as process,
        cast(null as varchar2(30))  as host,
        cast(null as varchar2(30))  as program,
        cast(null as date)          as logon_time,
        ash.module,
        ash.action,
        ash.client_id               as client_identifier,
        cast(null as varchar2(30))  as client_info,
        ash.sql_id,
        ash.sql_child_number,
        ash.sql_exec_id,
        ash.sql_exec_start,
        cast(null as varchar2(13))  as prev_sql_id,
        cast(null as number)        as prev_child_number,
        cast(null as number)        as prev_exec_id,
        cast(null as date)          as prev_exec_start,
        ash.top_level_call_name,
        cast(null as number)        as last_call_et,
        ash.session_state           as state,
        ash.wait_class,
        ash.event,
        round(ash.time_waited / power(10, 3))   as wait_time_ms,
        cast(null as number)        as time_remaining_ms,
        cast(null as number)        as time_since_last_wait_ms,
        ash.plsql_entry_object_id,
        ash.plsql_entry_subprogram_id,
        ash.plsql_object_id,
        ash.plsql_subprogram_id,
        ash.ecid,
        nullif(ash.cnt_ecid, 0)     as ash_cnt_ecid,
        cast(null as varchar2(10))  as pdml_status,
        cast(null as varchar2(10))  as pddl_status,
        cast(null as varchar2(10))  as pq_status,
        case
            when ash.px_flags is not null then
                'Y'
            else
                'N'
        end  as is_px_query,
        case
            when ash.px_flags is null then
                null
            when ash.qc_instance_id = 0 then
                'Y'
            else
                'N'
        end  as is_px_qc,
        ash.qc_instance_id          as qc_inst_id,
        ash.qc_session_id           as qc_sid,
        ash.qc_session_serial#      as qc_serial#,
        ash.blocking_session_status,
        ash.blocking_inst_id,
        ash.blocking_session,
        ash.blocking_session_serial#    as blocking_serial#,
        cast(null as varchar2(10))  as sql_trace,
        cast(null as varchar2(10))  as sql_trace_waits,
        cast(null as varchar2(10))  as sql_trace_binds,
        cast(null as varchar2(10))  as sql_trace_plan_stats,
        ash.consumer_group          as resource_consumer_group,
        ash.in_parse,
        ash.in_hard_parse,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_iops, 0))           as avg_read_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_iops, 0))          as avg_write_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_mbps, 0))           as avg_read_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_mbps, 0))          as avg_write_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_interconnect_mbps, 0))   as avg_interconnect_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.pga_allocated_mb, 0))          as ash_pga_alloc_mb,
        c##pkg_pub_utility.prec_round(nullif(ash.temp_space_allocated_mb, 0))   as ash_temp_space_mb
        --, c##pkg_pub_utility.prec_round(ash.max_pga_allocated_mb)                 as ash_max_pga_alloc_mb
        --, c##pkg_pub_utility.prec_round(ash.max_temp_space_allocated_mb)          as ash_max_temp_space_mb
        , ash.sample_time
    from
        ash_sessions_last_20s ash,
        live_sessions liv
    where
        ash.inst_id = liv.inst_id (+)
        and ash.session_id = liv.sid (+)
        and ash.session_serial# = liv.serial# (+)
        and liv.inst_id is null
)
select
    src                     as "Src",
    inst_id                 as "Inst_id",
    con_id                  as "Con_id",
    con_name                as "Con_name",
    service_name            as "Service",
    sid                     as "Sid",
    serial#                 as "Serial#",
    type                    as "Type",
    status                  as "Status",
    ash_cnt_samp            as "# Samp",
    avg_cpu_pct             as "Avg CPU%",
    avg_activ_pct           as "Avg Activ%",  
    ash_cnt_sql_exec        as "# SQL Exec",
    ash_cnt_xid             as "# XID",
    ash_cnt_ecid            as "# ECID",
    command                 as "Command",
    username                as "Username",
    schemaname              as "Schema",
    osuser                  as "OS user",
    process                 as "Process",
    machine                 as "Machine",
    program                 as "Program",
    logon_time              as "Logon time",
    module                  as "Module",
    action                  as "Action",
    client_identifier       as "Client_identifier",
    client_info             as "Client_info",
    ecid,
    sql_id,
    sql_child_number        as sql_child#,
    sql_exec_id             as "Sql_exec_id",
    to_char(sql_exec_start, 'YYYY-MM-DD HH24:MI:SS')  as "Sql_exec_start",   /* Can't pass DATE binds to child reports */
    in_parse                as "In parse?",
    in_hard_parse           as "In hard parse?",
    prev_sql_id,
    prev_child_number       as prev_child#,
    prev_exec_id            as "Prev_exec_id",
    to_char(prev_exec_start, 'YYYY-MM-DD HH24:MI:SS') as "Prev_exec_start",  /* Can't pass DATE binds to child reports */
    top_level_call_name     as "Top-level call",
    last_call_et,
    state                   as "Session state",
    wait_class              as "Wait class",
    event                   as "Event",
    wait_time_ms                as "Wait time (ms)",
    time_remaining_ms           as "Time remaining (ms)",
    time_since_last_wait_ms     as "Time since last wait (ms)",
    plsql_entry_object_id       as "Plsql_entry_object_id",
    plsql_entry_subprogram_id   as "Plsql_entry_subprogram_id",
    plsql_object_id             as "Plsql_object_id",
    plsql_subprogram_id         as "Plsql_subprogram_id",
    pdml_status             as "PDML status",
    pddl_status             as "PDDL status",
    pq_status               as "PQ status",
    is_px_qry               as "PX query?",
    is_px_qc                as "Is PX QC?", 
    qc_inst_id              as "QC_inst_id",
    qc_sid                  as "QC_sid",
    qc_serial#              as "QC_serial#",
    blocking_session_status as "Blocking session status",
    blocking_inst_id        as "Blocking_inst_id",
    blocking_session        as "Blocking_session",
    blocking_serial#        as "Blocking_serial#",
    sql_trace               as "SQL trace",
    sql_trace_waits         as "SQL trace waits",
    sql_trace_binds         as "SQL trace binds",
    sql_trace_plan_stats    as "SQL trace stats",
    resource_consumer_group as "Resource_consumer_group",
    avg_read_iops           as "Avg read IOPS",
    avg_write_iops          as "Avg write IOPS",
    avg_read_mbps           as "Avg read Mbps",
    avg_write_mbps          as "Avg write Mbps",
    avg_interconnect_mbps   as "Avg interco Mbps",
    ash_pga_alloc_mb        as "PGA alloc (Mb)",
    ash_temp_space_mb       as "Temp space (Mb)",
    sample_time             as "Sample time",
    :Xml_bind_data          as "Bind_data"
from
    (select
        s.*,
        case
            when s.con_id = 1 then
                'CDB$ROOT'
            else
                pdb.name
        end  as con_name
    from
        live_and_recent_sessions s,
        v$pdbs pdb
    where
        s.con_id = pdb.con_id (+)
    )
where
    1 = 1
    and :Xml_bind_data is not null
    and 1 = (case
                when lnnvl(upper(:Live_sessions_only) = 'Y') then
                    1
                when src = 'LIVE' then
                    1
            end)
    and 1 = (case
                when :Inactive_thres is null or :Inactive_thres = 0 then
                    1
                when status = 'ENDED'
                    and localtimestamp > sample_time + numtodsinterval(:Inactive_thres, 'SECOND')
                then
                    0
                when src = 'LIVE'
                    and state = 'WAITING'
                    and wait_class = 'Idle'
                    and last_call_et > :Inactive_thres
                then
                    0
                else
                    1
            end)
    and 1 = (case
                when lnnvl(upper(:Show_background) = 'Y') then
                    case type
                        when 'USER' then
                            1
                    end
                else
                    case
                        when type = 'USER' then
                            1
                        when lnnvl(upper(:Show_idle_background) = 'Y') then
                            case
                                when lnnvl(state = 'WAITING')
                                    or lnnvl(wait_class = 'Idle')
                                    or ash_cnt_samp > 0
                                    or (sysdate - coalesce(sql_exec_start, prev_exec_start)) * 86400 <= 20
                                then
                                    1
                            end
                        else
                            1
                    end
            end)
    and 1 = (case
                when :Username_like is null then
                    1
                when upper(username) like upper(:Username_like) escape '\' then
                    1
            end)
    and 1 = (case
                when :Username_RE is null then
                    1
                when regexp_like(username, :Username_RE, 'i') then
                    1
            end)
    and 1 = (case
                when :Inst# is null then
                    1
                when inst_id = to_number(:Inst#) then
                    1
            end)
    and 1 = (case
                when :Service_RE is null then
                    1
                when regexp_like(service_name, :Service_RE, 'i') then
                    1
            end)
    and 1 = (case
                when :Con_name_RE is null then
                    1
                when regexp_like(con_name, :Con_name_RE, 'i') then
                    1
                when upper(:Show_background) = 'Y'
                    and type = 'BACKGROUND'
                then
                    1
            end)
order by
    decode(type, 'USER', 1, 'BACKGROUND', 2),
    inst_id,
    sid]]></sql>
                <binds>
                    <bind id="Live_sessions_only">
                        <prompt><![CDATA[Live_sessions_only]]></prompt>
                        <tooltip><![CDATA[Live_sessions_only]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Inactive_thres">
                        <prompt><![CDATA[Inactive_thres]]></prompt>
                        <tooltip><![CDATA[Inactive_thres]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Show_background">
                        <prompt><![CDATA[Show_background]]></prompt>
                        <tooltip><![CDATA[Show_background]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Show_idle_background">
                        <prompt><![CDATA[Show_idle_background]]></prompt>
                        <tooltip><![CDATA[Show_idle_background]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Username_like">
                        <prompt><![CDATA[Username_like]]></prompt>
                        <tooltip><![CDATA[Username_like]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Username_RE">
                        <prompt><![CDATA[Username_RE]]></prompt>
                        <tooltip><![CDATA[Username_RE]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Inst#">
                        <prompt><![CDATA[Inst#]]></prompt>
                        <tooltip><![CDATA[Inst#]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Con_name_RE">
                        <prompt><![CDATA[Con_name_RE]]></prompt>
                        <tooltip><![CDATA[Con_name_RE]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Service_RE">
                        <prompt><![CDATA[Service_RE]]></prompt>
                        <tooltip><![CDATA[Service_RE]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Xml_bind_data">
                        <prompt><![CDATA[Xml_bind_data]]></prompt>
                        <tooltip><![CDATA[Xml_bind_data]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
            <query>
                <sql><![CDATA[with
live_sessions as (
    select
        se.inst_id,
        se.sid, 
        se.serial#,             -- ASH: session_serial#
        se.service_name,        -- ASH: service_hash
        se.type,                -- ASH: session_type
        case
            when se.type = 'BACKGROUND'
                and se.time_remaining_micro is not null
                and se.state = 'WAITING'
                and se.wait_class = 'Idle'
            then
                null
            else
                se.status       -- ASH: implicitly always ACTIVE
        end  as status,
        cm.command_name  as command,
        se.username,            -- ASH: user_id
        se.schemaname,          -- ASH: n/a
        se.osuser,              -- ASH: n/a
        se.process,             -- Foreground: client OS process id;   ASH: n/a
        se.machine,             -- Foreground: client OS machine name; ASH: n/a
        se.program,             -- Foreground: client program name;    ASH: n/a
        se.logon_time,          -- ASH: n/a
        se.module,
        se.action,
        se.client_identifier,   -- ASH: client id
        se.client_info,         -- ASH: n/a
        se.sql_id,
        case
            when se.sql_id is null then
                null
            else
                se.sql_child_number
        end  as sql_child_number,
        se.sql_exec_id,
        se.sql_exec_start,
        se.prev_sql_id,         -- ASH: n/a
        case
            when se.prev_sql_id is null then
                null
            else
                se.prev_child_number
        end  as prev_child_number,
        se.prev_exec_id,        -- ASH: n/a
        se.prev_exec_start,     -- ASH: n/a
        tc.top_level_call_name,
        se.last_call_et,        -- ASH: n/a
        case 
            when se.time_remaining_micro is null then
                'ON CPU' 
            else
                se.state
        end  as state,          -- ASH: session_state
        se.wait_class,
        se.event,
        round(se.wait_time_micro / power(10, 3), 1)             as wait_time_ms,            -- ASH: n/a
        round(se.time_remaining_micro / power(10, 3), 1)        as time_remaining_ms,       -- ASH: n/a 
        round(se.time_since_last_wait_micro / power(10, 3), 1)  as time_since_last_wait_ms, -- ASH: n/a
        se.plsql_entry_object_id,
        se.plsql_entry_subprogram_id,
        se.plsql_object_id,
        se.plsql_subprogram_id,
        se.pdml_status,         -- ASH: n/a
        se.pddl_status,         -- ASH: n/a
        se.pq_status,           -- ASH: n/a
        case
            when px.qcsid is null then 
                'N' 
            else
                'Y' 
        end  as is_px_qry,
        case
            when px.qcsid = se.sid 
                and lnnvl(px.qcinst_id <> sys_context('USERENV', 'INSTANCE')) 
            then
                'Y' 
            when px.qcsid is not null then
                'N' 
        end  as is_px_qc,
        px.qcinst_id,
        px.qcsid,
        px.qcserial#, 
        se.blocking_session_status,
        se.blocking_instance,               -- ASH: blocking_inst_id
        se.blocking_session,                -- ASH: + blocking_session_serial#
        --se.row_wait_obj#,                   -- ASH: current_obj#
        --se.row_wait_file#,                  -- ASH: current_file#
        --se.row_wait_block#,                 -- ASH: current_block#
        --se.row_wait_row#,                   -- ASH: current_row#
        se.sql_trace,                       -- ASH: n/a
        se.sql_trace_waits,                 -- ASH: n/a
        se.sql_trace_binds,                 -- ASH: n/a
        se.sql_trace_plan_stats,            -- ASH: n/a
        se.ecid,
        se.resource_consumer_group
    from
        gv$session se,
        gv$px_session px,
        v$sqlcommand cm,
        v$toplevelcall tc
    where
        se.inst_id = px.inst_id (+)
        and se.saddr = px.saddr (+)
        and se.command = cm.command_type (+)
        and se.top_level_call# = tc.top_level_call# (+)
),
ash_sessions_last_20s as (
    select
        inst_id,
        sample_time,
        session_id,
        session_serial#,
        session_type,
        username,
        cnt_samp,
        cnt_sql_exec,
        sql_id,
        is_sqlid_current,
        sql_child_number,
        command,
        sql_exec_id,
        sql_exec_start,
        plsql_entry_object_id,
        plsql_entry_subprogram_id,
        plsql_object_id,
        plsql_subprogram_id,
        px_flags,
        qc_instance_id,
        qc_session_id,
        qc_session_serial#,
        session_state,
        wait_class,
        event,
        time_waited,
        blocking_session_status,
        blocking_session,
        blocking_session_serial#,
        blocking_inst_id,
        --current_obj#,
        --current_file#,
        --current_block#,
        --current_row#,
        top_level_call_name,
        consumer_group,
        cnt_xid,
        in_parse,
        in_hard_parse,
        in_sql_execution,
        in_plsql_execution,
        service_name,
        program,
        module,
        action,
        client_id,
        machine,
        ecid,
        cnt_ecid,
        tm_delta_time,
        tm_delta_cpu_time,
        tm_delta_db_time,
        tm_delta_cpu_time,
        case
            when tm_delta_cpu_time_ratio < power(10,-3) then
                0
            else
                tm_delta_cpu_time_ratio
        end  as tm_delta_cpu_time_ratio,
        case
            when tm_delta_db_time_ratio < power(10,-3) then
                0
            else
                tm_delta_db_time_ratio
        end  as tm_delta_db_time_ratio,
        delta_time,
        delta_read_io_requests,
        delta_write_io_requests,
        delta_read_io_bytes,
        delta_write_io_bytes,
        delta_interconnect_io_bytes,
        delta_read_iops,
        delta_write_iops,
        delta_iops,
        delta_read_mbps,
        delta_write_mbps,
        delta_interconnect_mbps,
        pga_allocated_mb,
        max_pga_allocated_mb,
        temp_space_allocated_mb,
        max_temp_space_allocated_mb
    from
        (select
            ash.inst_id,
            ash.sample_time,
            ash.session_id,
            ash.session_serial#,
            ash.session_type,
            usr.username,
            ash.cnt_samp,
            ash.cnt_sql_exec,
            ash.sql_id,
            ash.is_sqlid_current,
            ash.sql_child_number,
            cmd.command_name  as command,
            ash.sql_exec_id,
            ash.sql_exec_start,
            ash.plsql_entry_object_id,
            ash.plsql_entry_subprogram_id,
            ash.plsql_object_id,
            ash.plsql_subprogram_id,
            ash.px_flags,
            ash.qc_instance_id,
            ash.qc_session_id,
            ash.qc_session_serial#,
            ash.session_state,
            ash.wait_class,
            ash.event,
            ash.time_waited,
            ash.blocking_session_status,
            ash.blocking_session,
            ash.blocking_session_serial#,
            ash.blocking_inst_id,
            --ash.current_obj#,
            --ash.current_file#,
            --ash.current_block#,
            --ash.current_row#,
            ash.top_level_call_name,
            rcg.consumer_group,
            ash.cnt_xid,
            ash.in_parse,
            ash.in_hard_parse,
            ash.in_sql_execution,
            ash.in_plsql_execution,
            svc.name  as service_name,
            ash.program,
            ash.module,
            ash.action,
            ash.client_id,
            ash.machine,
            ash.ecid,
            ash.cnt_ecid,
            ash.tm_delta_time,
            ash.tm_delta_cpu_time,
            ash.tm_delta_db_time,
            ash.tm_delta_cpu_time
                    / greatest(nullif(ash.tm_delta_time, 0),
                               19 * power(10,6))                as tm_delta_cpu_time_ratio,
            ash.tm_delta_db_time
                    / greatest(nullif(ash.tm_delta_time, 0),
                               19 * power(10,6))                as tm_delta_db_time_ratio,
            ash.delta_time,
            ash.delta_read_io_requests,
            ash.delta_write_io_requests,
            ash.delta_read_io_bytes,
            ash.delta_write_io_bytes,
            ash.delta_interconnect_io_bytes,
            ash.delta_read_io_requests 
                    * power(10, 6) 
                    / greatest(nullif(ash.delta_time, 0), 
                               19 * power(10,6))                as delta_read_iops,
            ash.delta_write_io_requests
                    * power(10, 6) 
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))                as delta_write_iops,
            (ash.delta_read_io_requests + ash.delta_write_io_requests)
                    * power(10, 6) 
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))                as delta_iops,
            ash.delta_read_io_bytes
                    * power(10, 6)
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))
                    / power(2, 20)                              as delta_read_mbps,
            ash.delta_write_io_bytes
                    * power(10, 6)
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))
                    / power(2, 20)                              as delta_write_mbps,
            ash.delta_interconnect_io_bytes
                    * power(10, 6)
                    / greatest(nullif(ash.delta_time, 0),
                               19 * power(10,6))
                    / power(2, 20)                              as delta_interconnect_mbps,
            ash.pga_allocated / power(2, 20)                    as pga_allocated_mb,
            ash.max_pga_allocated / power(2, 20)                as max_pga_allocated_mb,
            ash.temp_space_allocated / power(2, 20)             as temp_space_allocated_mb,
            ash.max_temp_space_allocated / power(2, 20)         as max_temp_space_allocated_mb
        from
            (select
                inst_id,
                max(sample_time)
                        keep (dense_rank first order by sample_id desc) as sample_time,
                session_id,
                session_serial#,
                session_type,
                user_id,
                count(*)  as cnt_samp,
                count(distinct case
                                   when is_sqlid_current = 'Y' then
                                       to_char(inst_id) || ':' || sql_id 
                                       || ',' || to_char(sql_exec_id)
                                       || ',' || to_char(sql_exec_start, 
                                                         'YYYYMMDDHH24MISS')
                               end)                                     as cnt_sql_exec,
                max(sql_id)
                        keep (dense_rank first order by sample_id desc) as sql_id,
                max(is_sqlid_current)
                        keep (dense_rank first order by sample_id desc) as is_sqlid_current,
                max(sql_child_number)
                        keep (dense_rank first order by sample_id desc) as sql_child_number,
                max(sql_opcode)
                        keep (dense_rank first order by sample_id desc) as sql_opcode,
                max(sql_exec_id)
                        keep (dense_rank first order by sample_id desc) as sql_exec_id,
                max(sql_exec_start)
                        keep (dense_rank first order by sample_id desc) as sql_exec_start,
                max(plsql_entry_object_id)
                        keep (dense_rank first order by sample_id desc) as plsql_entry_object_id,
                max(plsql_entry_subprogram_id)
                        keep (dense_rank first order by sample_id desc) as plsql_entry_subprogram_id,
                max(plsql_object_id)
                        keep (dense_rank first order by sample_id desc) as plsql_object_id,
                max(plsql_subprogram_id)
                        keep (dense_rank first order by sample_id desc) as plsql_subprogram_id,
                max(px_flags)
                        keep (dense_rank first order by sample_id desc) as px_flags,
                qc_instance_id,
                qc_session_id,
                qc_session_serial#,
                max(session_state)
                        keep (dense_rank first order by sample_id desc) as session_state,
                max(wait_class)
                        keep (dense_rank first order by sample_id desc) as wait_class,
                max(event)
                        keep (dense_rank first order by sample_id desc) as event,
                max(time_waited)
                        keep (dense_rank first order by sample_id desc) as time_waited,
                max(blocking_session_status)
                        keep (dense_rank first order by sample_id desc) as blocking_session_status,
                max(blocking_session)
                        keep (dense_rank first order by sample_id desc) as blocking_session,
                max(blocking_session_serial#)
                        keep (dense_rank first order by sample_id desc) as blocking_session_serial#,
                max(blocking_inst_id)
                        keep (dense_rank first order by sample_id desc) as blocking_inst_id,
                --max(current_obj#)
                --        keep (dense_rank first order by sample_id desc) as current_obj#,
                --max(current_file#)
                --        keep (dense_rank first order by sample_id desc) as current_file#,
                --max(current_block#)
                --        keep (dense_rank first order by sample_id desc) as current_block#,
                --max(current_row#)
                --        keep (dense_rank first order by sample_id desc) as current_row#,
                max(top_level_call_name)
                        keep (dense_rank first order by sample_id desc) as top_level_call_name,
                max(consumer_group_id)
                        keep (dense_rank first order by sample_id desc) as consumer_group_id,
                count(distinct xid)                                     as cnt_xid,
                max(in_parse)
                        keep (dense_rank first order by sample_id desc) as in_parse,
                max(in_hard_parse)
                        keep (dense_rank first order by sample_id desc) as in_hard_parse,
                max(in_sql_execution)
                        keep (dense_rank first order by sample_id desc) as in_sql_execution,
                max(in_plsql_execution)
                        keep (dense_rank first order by sample_id desc) as in_plsql_execution,
                service_hash,
                max(program)
                        keep (dense_rank first order by sample_id desc) as program,
                max(module)
                        keep (dense_rank first order by sample_id desc) as module,
                max(action)
                        keep (dense_rank first order by sample_id desc) as action,
                max(client_id)
                        keep (dense_rank first order by sample_id desc) as client_id,
                max(machine)
                        keep (dense_rank first order by sample_id desc) as machine,
                max(ecid)
                        keep (dense_rank first order by sample_id desc) as ecid,
                count(distinct ecid)                                    as cnt_ecid,
                sum(tm_delta_time)                                      as tm_delta_time,
                sum(tm_delta_cpu_time)                                  as tm_delta_cpu_time,
                sum(tm_delta_db_time)                                   as tm_delta_db_time,
                sum(delta_time)                                         as delta_time,
                sum(delta_read_io_requests)                             as delta_read_io_requests,
                sum(delta_write_io_requests)                            as delta_write_io_requests,
                sum(delta_read_io_bytes)                                as delta_read_io_bytes,
                sum(delta_write_io_bytes)                               as delta_write_io_bytes,
                sum(delta_interconnect_io_bytes)                        as delta_interconnect_io_bytes,
                max(pga_allocated)
                        keep (dense_rank first order by sample_id desc) as pga_allocated,
                max(pga_allocated)                                      as max_pga_allocated,
                max(temp_space_allocated)
                        keep (dense_rank first order by sample_id desc) as temp_space_allocated,
                max(temp_space_allocated)                               as max_temp_space_allocated
            from
                gv$active_session_history
            where
                sample_time >= localtimestamp - numtodsinterval(20, 'SECOND')
            group by
                inst_id,
                session_id,
                session_serial#,
                session_type,
                user_id,
                qc_instance_id,
                qc_session_id,
                qc_session_serial#,
                service_hash
            ) ash,
            all_users usr,
            gv$services svc,
            v$sqlcommand cmd,
            dba_rsrc_consumer_groups rcg
        where
            ash.user_id = usr.user_id (+)
            and ash.inst_id = svc.inst_id (+)
            and ash.service_hash = svc.name_hash (+)
            and ash.sql_opcode = cmd.command_type (+)
            and ash.consumer_group_id = rcg.consumer_group_id (+)
            and rcg.status (+) is null  -- ignore PENDING changes to consumer groups
        )
),
live_and_recent_sessions as (
    select
        'LIVE' as src,
        liv.inst_id,
        liv.service_name,
        liv.sid,
        liv.serial#,
        liv.type,
        liv.status,
        ash.cnt_samp            as ash_cnt_samp,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_cpu_time_ratio)  as avg_cpu_pct,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_db_time_ratio)   as avg_activ_pct,
        ash.cnt_sql_exec        as ash_cnt_sql_exec,
        nullif(ash.cnt_xid, 0)  as ash_cnt_xid,
        liv.command,
        liv.username,
        liv.schemaname,
        liv.osuser,
        liv.process,
        liv.machine,
        liv.program,
        liv.logon_time,
        liv.module,
        liv.action,
        liv.client_identifier,
        liv.client_info,
        liv.sql_id,
        liv.sql_child_number,
        liv.sql_exec_id,
        liv.sql_exec_start,
        liv.prev_sql_id,
        liv.prev_child_number,
        liv.prev_exec_id,
        liv.prev_exec_start,
        liv.top_level_call_name,
        liv.last_call_et,
        liv.state,
        liv.wait_class,
        liv.event,
        liv.wait_time_ms,
        liv.time_remaining_ms,
        liv.time_since_last_wait_ms,
        liv.plsql_entry_object_id,
        liv.plsql_entry_subprogram_id,
        liv.plsql_object_id,
        liv.plsql_subprogram_id,
        liv.ecid,
        nullif(ash.cnt_ecid, 0)             as ash_cnt_ecid,
        liv.pdml_status,
        liv.pddl_status,
        liv.pq_status,
        liv.is_px_qry,
        liv.is_px_qc,
        liv.qcinst_id                       as qc_inst_id,
        liv.qcsid                           as qc_sid,
        liv.qcserial#                       as qc_serial#, 
        liv.blocking_session_status,
        liv.blocking_instance               as blocking_inst_id,
        liv.blocking_session,
        cast(null as number)                as blocking_serial#,
        liv.sql_trace,
        liv.sql_trace_waits,
        liv.sql_trace_binds,
        liv.sql_trace_plan_stats,
        liv.resource_consumer_group,
        ash.in_parse,
        ash.in_hard_parse,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_iops, 0))           as avg_read_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_iops, 0))          as avg_write_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_mbps, 0))           as avg_read_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_mbps, 0))          as avg_write_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_interconnect_mbps, 0))   as avg_interconnect_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.pga_allocated_mb, 0))          as ash_pga_alloc_mb,
        c##pkg_pub_utility.prec_round(nullif(ash.temp_space_allocated_mb, 0))   as ash_temp_space_mb
        --, c##pkg_pub_utility.prec_round(ash.max_pga_allocated_mb)                 as ash_max_pga_alloc_mb
        --, c##pkg_pub_utility.prec_round(ash.max_temp_space_allocated_mb)          as ash_max_temp_space_mb
        , localtimestamp                    as sample_time
    from
        live_sessions liv,
        ash_sessions_last_20s ash
    where
        liv.inst_id = ash.inst_id (+)
        and liv.sid = ash.session_id (+)
        and liv.serial# = ash.session_serial# (+)
    union all
    select
        'ASH'                   as src,
        ash.inst_id,
        ash.service_name,
        ash.session_id          as sid,
        ash.session_serial#     as serial#,
        case
            when ash.session_type = 'FOREGROUND' then
                'USER'
            else
                ash.session_type
        end                     as type,
        'ENDED'                 as status,
        ash.cnt_samp            as ash_cnt_samp,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_cpu_time_ratio)    as avg_cpu_pct,
        c##pkg_pub_utility.prec_round(100 * ash.tm_delta_db_time_ratio)     as avg_activ_pct,
        ash.cnt_sql_exec        as ash_cnt_sql_exec,
        nullif(ash.cnt_xid, 0)  as ash_cnt_xid,
        ash.command,
        ash.username,
        cast(null as varchar2(30))  as schemaname,
        cast(null as varchar2(30))  as osuser,
        cast(null as varchar2(30))  as process,
        cast(null as varchar2(30))  as host,
        cast(null as varchar2(30))  as program,
        cast(null as date)          as logon_time,
        ash.module,
        ash.action,
        ash.client_id               as client_identifier,
        cast(null as varchar2(30))  as client_info,
        ash.sql_id,
        ash.sql_child_number,
        ash.sql_exec_id,
        ash.sql_exec_start,
        cast(null as varchar2(13))  as prev_sql_id,
        cast(null as number)        as prev_child_number,
        cast(null as number)        as prev_exec_id,
        cast(null as date)          as prev_exec_start,
        ash.top_level_call_name,
        cast(null as number)        as last_call_et,
        ash.session_state           as state,
        ash.wait_class,
        ash.event,
        round(ash.time_waited / power(10, 3))   as wait_time_ms,
        cast(null as number)        as time_remaining_ms,
        cast(null as number)        as time_since_last_wait_ms,
        ash.plsql_entry_object_id,
        ash.plsql_entry_subprogram_id,
        ash.plsql_object_id,
        ash.plsql_subprogram_id,
        ash.ecid,
        nullif(ash.cnt_ecid, 0)     as ash_cnt_ecid,
        cast(null as varchar2(10))  as pdml_status,
        cast(null as varchar2(10))  as pddl_status,
        cast(null as varchar2(10))  as pq_status,
        case
            when ash.px_flags is not null then
                'Y'
            else
                'N'
        end  as is_px_query,
        case
            when ash.px_flags is null then
                null
            when ash.qc_instance_id = 0 then
                'Y'
            else
                'N'
        end  as is_px_qc,
        ash.qc_instance_id          as qc_inst_id,
        ash.qc_session_id           as qc_sid,
        ash.qc_session_serial#      as qc_serial#,
        ash.blocking_session_status,
        ash.blocking_inst_id,
        ash.blocking_session,
        ash.blocking_session_serial#    as blocking_serial#,
        cast(null as varchar2(10))  as sql_trace,
        cast(null as varchar2(10))  as sql_trace_waits,
        cast(null as varchar2(10))  as sql_trace_binds,
        cast(null as varchar2(10))  as sql_trace_plan_stats,
        ash.consumer_group          as resource_consumer_group,
        ash.in_parse,
        ash.in_hard_parse,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_iops, 0))           as avg_read_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_iops, 0))          as avg_write_iops,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_read_mbps, 0))           as avg_read_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_write_mbps, 0))          as avg_write_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.delta_interconnect_mbps, 0))   as avg_interconnect_mbps,
        c##pkg_pub_utility.prec_round(nullif(ash.pga_allocated_mb, 0))          as ash_pga_alloc_mb,
        c##pkg_pub_utility.prec_round(nullif(ash.temp_space_allocated_mb, 0))   as ash_temp_space_mb
        --, c##pkg_pub_utility.prec_round(ash.max_pga_allocated_mb)                 as ash_max_pga_alloc_mb
        --, c##pkg_pub_utility.prec_round(ash.max_temp_space_allocated_mb)          as ash_max_temp_space_mb
        , ash.sample_time
    from
        ash_sessions_last_20s ash,
        live_sessions liv
    where
        ash.inst_id = liv.inst_id (+)
        and ash.session_id = liv.sid (+)
        and ash.session_serial# = liv.serial# (+)
        and liv.inst_id is null
)
select
    src                     as "Src",
    inst_id                 as "Inst_id",
    service_name            as "Service",
    sid                     as "Sid",
    serial#                 as "Serial#",
    type                    as "Type",
    status                  as "Status",
    ash_cnt_samp            as "# Samp",
    avg_cpu_pct             as "Avg CPU%",
    avg_activ_pct           as "Avg Activ%",  
    ash_cnt_sql_exec        as "# SQL Exec",
    ash_cnt_xid             as "# XID",
    ash_cnt_ecid            as "# ECID",
    command                 as "Command",
    username                as "Username",
    schemaname              as "Schema",
    osuser                  as "OS user",
    process                 as "Process",
    machine                 as "Machine",
    program                 as "Program",
    logon_time              as "Logon time",
    module                  as "Module",
    action                  as "Action",
    client_identifier       as "Client_identifier",
    client_info             as "Client_info",
    ecid,
    sql_id,
    sql_child_number        as sql_child#,
    sql_exec_id             as "Sql_exec_id",
    to_char(sql_exec_start, 'YYYY-MM-DD HH24:MI:SS')  as "Sql_exec_start",   /* Can't pass DATE binds to child reports */
    in_parse                as "In parse?",
    in_hard_parse           as "In hard parse?",
    prev_sql_id,
    prev_child_number       as prev_child#,
    prev_exec_id            as "Prev_exec_id",
    to_char(prev_exec_start, 'YYYY-MM-DD HH24:MI:SS') as "Prev_exec_start",  /* Can't pass DATE binds to child reports */
    top_level_call_name     as "Top-level call",
    last_call_et,
    state                   as "Session state",
    wait_class              as "Wait class",
    event                   as "Event",
    wait_time_ms                as "Wait time (ms)",
    time_remaining_ms           as "Time remaining (ms)",
    time_since_last_wait_ms     as "Time since last wait (ms)",
    plsql_entry_object_id       as "Plsql_entry_object_id",
    plsql_entry_subprogram_id   as "Plsql_entry_subprogram_id",
    plsql_object_id             as "Plsql_object_id",
    plsql_subprogram_id         as "Plsql_subprogram_id",
    pdml_status             as "PDML status",
    pddl_status             as "PDDL status",
    pq_status               as "PQ status",
    is_px_qry               as "PX query?",
    is_px_qc                as "Is PX QC?", 
    qc_inst_id              as "QC_inst_id",
    qc_sid                  as "QC_sid",
    qc_serial#              as "QC_serial#",
    blocking_session_status as "Blocking session status",
    blocking_inst_id        as "Blocking_inst_id",
    blocking_session        as "Blocking_session",
    blocking_serial#        as "Blocking_serial#",
    sql_trace               as "SQL trace",
    sql_trace_waits         as "SQL trace waits",
    sql_trace_binds         as "SQL trace binds",
    sql_trace_plan_stats    as "SQL trace stats",
    resource_consumer_group as "Resource_consumer_group",
    avg_read_iops           as "Avg read IOPS",
    avg_write_iops          as "Avg write IOPS",
    avg_read_mbps           as "Avg read Mbps",
    avg_write_mbps          as "Avg write Mbps",
    avg_interconnect_mbps   as "Avg interco Mbps",
    ash_pga_alloc_mb        as "PGA alloc (Mb)",
    ash_temp_space_mb       as "Temp space (Mb)",
    sample_time             as "Sample time",
    :Xml_bind_data          as "Bind_data"
from
    live_and_recent_sessions
where
    1 = 1
    and :Xml_bind_data is not null
    and 1 = (case
                when lnnvl(upper(:Live_sessions_only) = 'Y') then
                    1
                when src = 'LIVE' then
                    1
            end)
    and 1 = (case
                when :Inactive_thres is null or :Inactive_thres = 0 then
                    1
                when status = 'ENDED'
                    and localtimestamp > sample_time + numtodsinterval(:Inactive_thres, 'SECOND')
                then
                    0
                when src = 'LIVE'
                    and state = 'WAITING'
                    and wait_class = 'Idle'
                    and last_call_et > :Inactive_thres
                then
                    0
                else
                    1
            end)
    and 1 = (case
                when lnnvl(upper(:Show_background) = 'Y') then
                    case type
                        when 'USER' then
                            1
                    end
                else
                    case
                        when type = 'USER' then
                            1
                        when lnnvl(upper(:Show_idle_background) = 'Y') then
                            case
                                when lnnvl(state = 'WAITING')
                                    or lnnvl(wait_class = 'Idle')
                                    or ash_cnt_samp > 0
                                    or (sysdate - coalesce(sql_exec_start, prev_exec_start)) * 86400 <= 20
                                then
                                    1
                            end
                        else
                            1
                    end
            end)
    and 1 = (case
                when :Username_like is null then
                    1
                when upper(username) like upper(:Username_like) escape '\' then
                    1
            end)
    and 1 = (case
                when :Username_RE is null then
                    1
                when regexp_like(username, :Username_RE, 'i') then
                    1
            end)
    and 1 = (case
                when :Inst# is null then
                    1
                when inst_id = to_number(:Inst#) then
                    1
            end)
    and 1 = (case
                when :Service_RE is null then
                    1
                when regexp_like(service_name, :Service_RE, 'i') then
                    1
            end)
order by
    decode(type, 'USER', 1, 'BACKGROUND', 2),
    inst_id,
    sid]]></sql>
                <binds>
                    <bind id="Live_sessions_only">
                        <prompt><![CDATA[Live_sessions_only]]></prompt>
                        <tooltip><![CDATA[Live_sessions_only]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Inactive_thres">
                        <prompt><![CDATA[Inactive_thres]]></prompt>
                        <tooltip><![CDATA[Inactive_thres]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Show_background">
                        <prompt><![CDATA[Show_background]]></prompt>
                        <tooltip><![CDATA[Show_background]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Show_idle_background">
                        <prompt><![CDATA[Show_idle_background]]></prompt>
                        <tooltip><![CDATA[Show_idle_background]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Username_like">
                        <prompt><![CDATA[Username_like]]></prompt>
                        <tooltip><![CDATA[Username_like]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Username_RE">
                        <prompt><![CDATA[Username_RE]]></prompt>
                        <tooltip><![CDATA[Username_RE]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Inst#">
                        <prompt><![CDATA[Inst#]]></prompt>
                        <tooltip><![CDATA[Inst#]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Service_RE">
                        <prompt><![CDATA[Service_RE]]></prompt>
                        <tooltip><![CDATA[Service_RE]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Xml_bind_data">
                        <prompt><![CDATA[Xml_bind_data]]></prompt>
                        <tooltip><![CDATA[Xml_bind_data]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
        </queries>
        <item reload="false" reloadparent="false" removeFromParent="false">
            <title>Start SQL tracing...</title>
            <help><![CDATA[This turns SQL tracing on in the specified session.

Remark: this only works for sessions in the local instance.
]]></help>
            <prompt type="confirm">
                <label>Session: #Sid#, #Serial## (#Inst_id#)    Username: #"Username"#</label>
            </prompt>
            <prompt type="radio" required="true">       <!-- index: 1 -->
                <label>Trace binds:</label>
                <default><![CDATA[STATIC:True]]></default>
                <value><![CDATA[STATIC:True:False]]></value>
            </prompt>
            <prompt type="radio" required="true">       <!-- index: 2 -->
                <label>Trace waits:</label>
                <default><![CDATA[STATIC:True]]></default>
                <value><![CDATA[STATIC:True:False]]></value>
            </prompt>
            <prompt type="radio" required="true">       <!-- index: 3 -->
                <label>Plan statistics:</label>
                <default><![CDATA[STATIC:All execs]]></default>
                <value><![CDATA[STATIC:All execs:First exec:Never]]></value>
            </prompt>
            <prompt type="confirm">
                <label>Confirm start tracing?</label>
            </prompt>
            <sql><![CDATA[declare
    l_session_id       number := #Sid#;
    l_session_serial   number := #Serial##;
    l_session_instance number := #Inst_id#;
begin
    if sys_context('USERENV', 'INSTANCE') != l_session_instance then
        raise_application_error(-20000, 'This session is not in the local instance');
    end if;

    dbms_monitor.session_trace_enable(
        session_id => l_session_id,
        serial_num => l_session_serial,
        binds      => #1#,
        waits      => #2#,
        plan_stat  => case '#3#'
                          when 'All execs'  then 'ALL_EXECUTIONS'
                          when 'First exec' then 'FIRST_EXECUTION'
                          when 'Never'      then 'NEVER'
                      end
    );
end;]]></sql>
            <confirmation>
                <title>SQL tracing enabled</title>
                <sql><![CDATA[
select
    nvl((select
            'Tracing in session ' || to_char(ses.sid) || ',' || to_char(ses.serial#)
                    || '(' || sys_context('USERENV', 'INSTANCE') || ') is now ' || ses.sql_trace
                    || ', with binds: ' || lower(ses.sql_trace_binds)
                    || ', waits: ' || lower(ses.sql_trace_waits)
                    || ', plan stats: ' || ses.sql_trace_plan_stats
        from
            v$session ses
        where
            ses.sid = #Sid#
            and ses.serial# = #Serial##
        ),
        'Tracing successfully enabled; note that the session has already ended'
    ) as diag_text
from dual]]></sql>
                <prompt><![CDATA[#0.DIAG_TEXT#]]></prompt>
            </confirmation>
        </item>
        <item reload="false" reloadparent="false" removeFromParent="false">
            <title>Stop SQL tracing...</title>
            <help><![CDATA[This turn SQL tracing off in the specified session.

Remark: this only works for sessions in the local instance.
]]></help>
            <prompt type="confirm">
                <label>Session: #Sid#, #Serial## (#Inst_id#)    Username: #"Username"#</label>
            </prompt>
            <prompt type="confirm">
                <label>Confirm stop tracing?</label>
            </prompt>
            <sql><![CDATA[declare
    l_session_id       number := #Sid#;
    l_session_serial   number := #Serial##;
    l_session_instance number := #Inst_id#;
begin
    if sys_context('USERENV', 'INSTANCE') != l_session_instance then
        raise_application_error(-20000, 'This session is not in the local instance');
    end if;

    dbms_monitor.session_trace_disable(
        session_id => l_session_id,
        serial_num => l_session_serial
    );
end;]]></sql>
            <confirmation>
                <title>SQL tracing disabled</title>
                <sql><![CDATA[
select
    nvl((select
            'Tracing in session ' || to_char(ses.sid) || ',' || to_char(ses.serial#)
                    || '(' || sys_context('USERENV', 'INSTANCE') || ') is now ' || ses.sql_trace
        from
            v$session ses
        where
            ses.sid = #Sid#
            and ses.serial# = #Serial##
        ),
        'Tracing successfully disabled; note that the session has already ended'
    ) as diag_text
from dual]]></sql>
                <prompt><![CDATA[#0.DIAG_TEXT#]]></prompt>
            </confirmation>
        </item>
        <item reload="false" reloadparent="false" removeFromParent="false">
            <title>Kill session...</title>
            <help><![CDATA[This terminates the specified session.

Remark: this only works for sessions in the local instance.
]]></help>
            <prompt type="confirm">
                <label>Session: #Sid#, #Serial## (#Inst_id#)    Username: #"Username"#</label>
            </prompt>
            <prompt type="radio" required="true">       <!-- index: 1 -->
                <label>When:</label>
                <default><![CDATA[STATIC:IMMEDIATE]]></default>
                <value><![CDATA[STATIC:IMMEDIATE:Post_transaction]]></value>
            </prompt>
<prompt type="confirm">
                <label>Confirm KILL session?</label>
            </prompt>
            <sql><![CDATA[declare
    l_session_id        number        := #Sid#;
    l_session_serial    number        := #Serial##;
    l_session_instance  number        := #Inst_id#;
    l_disconnect_mode   varchar2(20)  := '#1#';

    e_sess_marked_for_kill exception;
    pragma exception_init(e_sess_marked_for_kill, -31);
begin
    if sys_context('USERENV', 'INSTANCE') != l_session_instance then
        raise_application_error(-20000, 'This session is not in the local instance');
    end if;

    execute immediate 'alter system disconnect session ''' 
            || to_char(l_session_id) || ',' || to_char(l_session_serial)
            || ''' ' || lower(l_disconnect_mode);
exception
    when e_sess_marked_for_kill then
        null;
end;]]></sql>
            <confirmation>
                <title>Session killed</title>
                <sql><![CDATA[
select
    nvl((select
            'Session ' || to_char(ses.sid) || ',' || to_char(ses.serial#)
                    || '(' || sys_context('USERENV', 'INSTANCE') || ') status is now ' || ses.status
        from
            v$session ses
        where
            ses.sid = #Sid#
            and ses.serial# = #Serial##
        ),
        'Session #Sid#,#Serial##(#Inst_id#) was killed, and ended'
    ) as diag_text
from dual]]></sql>
                <prompt><![CDATA[#0.DIAG_TEXT#]]></prompt>
            </confirmation>
        </item>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Server]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[select
    ses.inst_id,
    ses.sid                                         as session_id,
    ses.serial#                                     as session_serial#,
    case
        when pro.background is null then
            'NO'
        else
            'YES'
    end                                             as "Background?", 
    pro.spid                                        as os_pid,
    pro.username                                    as os_user, 
    pro.terminal, 
    pro.program,
    round(pro.pga_used_mem     / power(2, 20), 2)   as pga_used_mb, 
    round(pro.pga_alloc_mem    / power(2, 20), 2)   as pga_alloc_mb, 
    round(pro.pga_freeable_mem / power(2, 20), 2)   as pga_freeable_mb,
    round(pro.pga_max_mem      / power(2, 20), 2)   as pga_max_mb,
    pro.traceid, 
    pro.tracefile
from 
    gv$session ses,
    gv$process pro
where
    ses.inst_id = :Inst_id
    and ses.sid = :Sid
    and pro.inst_id = ses.inst_id
    and pro.addr = ses.paddr]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Process mem]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[select
    ses.inst_id,
    ses.sid                                         as session_id,
    ses.serial#                                     as session_serial#,
    pmem.category, 
    round(pmem.allocated     / power(2, 20), 2)     as allocated_mb,
    round(pmem.used          / power(2, 20), 2)     as used_mb, 
    round(pmem.max_allocated / power(2, 20), 2)     as max_allocated_mb
from 
    gv$session ses,
    gv$process pro,
    gv$process_memory pmem
where
    ses.inst_id = :Inst_id
    and ses.sid = :Sid
    and pro.inst_id = ses.inst_id
    and pro.addr = ses.paddr
    and pmem.inst_id = pro.inst_id
    and pmem.pid = pro.pid]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Connect info]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[select
    ci.*
from 
    gv$session_connect_info ci
where 
    ci.inst_id = :Inst_id
    and ci.sid = :Sid]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Long ops]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query minversion="12.1">
                    <sql><![CDATA[select
    lop.inst_id,
    lop.sid,
    lop.serial#,
    lop.opname,
    lop.target,
    lop.target_desc,
    lop.sofar,
    lop.totalwork,
    lop.units,
    lop.start_time,
    lop.last_update_time,
    lop.timestamp,
    lop.time_remaining,
    lop.elapsed_seconds,
    lop.context,
    lop.message,
    lop.username,
    lop.sql_id,
    lop.sql_plan_hash_value,
    lop.sql_exec_start,
    lop.sql_exec_id,
    lop.sql_plan_line_id,
    lop.sql_plan_operation,
    lop.sql_plan_options,
    lop.qcsid,
    lop.con_id
from
    gv$session_longops lop
where
    lop.inst_id = :Inst_id
    and lop.sid = :Sid
order by
    lop.last_update_time desc nulls last]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query>
                    <sql><![CDATA[select
    lop.inst_id,
    lop.sid,
    lop.serial#,
    lop.opname,
    lop.target,
    lop.target_desc,
    lop.sofar,
    lop.totalwork,
    lop.units,
    lop.start_time,
    lop.last_update_time,
    lop.timestamp,
    lop.time_remaining,
    lop.elapsed_seconds,
    lop.context,
    lop.message,
    lop.username,
    lop.sql_id,
    lop.sql_plan_hash_value,
    lop.sql_exec_start,
    lop.sql_exec_id,
    lop.sql_plan_line_id,
    lop.sql_plan_operation,
    lop.sql_plan_options,
    lop.qcsid
from
    gv$session_longops lop
where
    lop.inst_id = :Inst_id
    and lop.sid = :Sid
order by
    lop.last_update_time desc nulls last]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Transactions]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query minversion="12.1">
                    <sql><![CDATA[select
    trn.inst_id,
    trn.con_id,
    ses.sid,
    ses.serial#,
    ses.type,
    ses.username,
    trn.xid,
    trn.status,
    trn.used_ublk,
    trn.used_urec,
    trn.start_time,
    trn.flag,
    trn.space,
    trn.recursive,
    trn.noundo,
    trn.ptx,
    trn.name,
    ses.program,
    ses.module,
    ses.action,
    trn.prv_xid,
    trn.ptx_xid
from
    gv$session     ses,
    gv$transaction trn
where
    ses.inst_id = :Inst_id
    and ses.sid = :Sid
    and trn.inst_id = ses.inst_id
    and trn.ses_addr = ses.saddr]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query>
                    <sql><![CDATA[select
    trn.inst_id,
    ses.sid,
    ses.serial#,
    ses.type,
    ses.username,
    trn.xid,
    trn.status,
    trn.used_ublk,
    trn.used_urec,
    trn.start_time,
    trn.flag,
    trn.space,
    trn.recursive,
    trn.noundo,
    trn.ptx,
    trn.name,
    ses.program,
    ses.module,
    ses.action,
    trn.prv_xid,
    trn.ptx_xid
from
    gv$session     ses,
    gv$transaction trn
where
    ses.inst_id = :Inst_id
    and ses.sid = :Sid
    and trn.inst_id = ses.inst_id
    and trn.ses_addr = ses.saddr]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Locks]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query minversion="12.1">
                    <sql><![CDATA[select
    s.inst_id,
    s.sid,
    s.serial#,
    s.username,
    l.type,
    t.name,
    l.lmode,
    l.request,
    decode(l.lmode,   0, 'None', 1, 'Null (NL)', 2, 'Row-S (SS)', 3, 'Row-X (SX)',
                      4, 'Share (S)', 5, 'S-Row-X (SSX)', 6, 'Excl. (X)')  as lock_mode,
    decode(l.request, 0, 'None', 1, 'Null (NL)', 2, 'Row-S (SS)', 3, 'Row-X (SX)',
                      4, 'Share (S)', 5, 'S-Row-X (SSX)', 6, 'Excl. (X)')  as req_mode,
    l.id1,
    l.id2,
    t.id1_tag,
    t.id2_tag,
    case
        when t.id1_tag = 'object #' or t.id2_tag = 'object #'
        then (select '"' || o.owner || '"."' || o.object_name || '"'
                     || case 
                            when o.subobject_name is not null 
                            then ':"' || o.subobject_name || '"'
                        end
                from cdb_objects o 
               where o.con_id = l.con_id 
                 and o.object_id = decode(t.id1_tag, 'object #', l.id1, l.id2))
    end  as locked_obj,
    l.ctime,
    decode(l.block, 0, 'NO', 1, 'YES')  as is_blocker,
    t.is_user,
    t.description,
    l.con_id
from
    gv$lock l,
    v$lock_type t,
    gv$session s
where
    l.type = t.type
    and l.inst_id = s.inst_id
    and l.sid = s.sid
    and s.inst_id = :Inst_id
    and s.sid = :Sid
order by
    l.ctime desc,
    l.type,
    l.lmode desc,
    l.request desc,
    l.id1,
    l.id2]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query>
                    <sql><![CDATA[select
    s.inst_id,
    s.sid,
    s.serial#,
    s.username,
    l.type,
    t.name,
    l.lmode,
    l.request,
    decode(l.lmode,   0, 'None', 1, 'Null (NL)', 2, 'Row-S (SS)', 3, 'Row-X (SX)',
                      4, 'Share (S)', 5, 'S-Row-X (SSX)', 6, 'Excl. (X)')  as lock_mode,
    decode(l.request, 0, 'None', 1, 'Null (NL)', 2, 'Row-S (SS)', 3, 'Row-X (SX)',
                      4, 'Share (S)', 5, 'S-Row-X (SSX)', 6, 'Excl. (X)')  as req_mode,
    l.id1,
    l.id2,
    t.id1_tag,
    t.id2_tag,
    case
        when t.id1_tag = 'object #' or t.id2_tag = 'object #'
        then (select '"' || o.owner || '"."' || o.object_name || '"'
                     || case 
                            when o.subobject_name is not null 
                            then ':"' || o.subobject_name || '"'
                        end
                from dba_objects o 
               where o.object_id = decode(t.id1_tag, 'object #', l.id1, l.id2))
    end  as locked_obj,
    l.ctime,
    decode(l.block, 0, 'NO', 1, 'YES')  as is_blocker,
    t.is_user,
    t.description
from
    gv$lock l,
    v$lock_type t,
    gv$session s
where
    l.type = t.type
    and l.inst_id = s.inst_id
    and l.sid = s.sid
    and s.inst_id = :Inst_id
    and s.sid = :Sid
order by
    l.ctime desc,
    l.type,
    l.lmode desc,
    l.request desc,
    l.id1,
    l.id2]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[SQL Details]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query minversion="19.1">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_reads,                     -- 12.2 and higher
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.result_cache,                     -- 18.1 and higher
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    a.ddl_no_invalidate,                -- 12.2 and higher
    a.is_rolling_invalid,               -- 12.2 and higher
    a.is_rolling_refresh_invalid,       -- 12.2 and higher
    a.sql_quarantine,                   -- 19.1 and higher
    a.avoided_executions,               -- 19.1 and higher
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = nvl(:SQL_ID, :PREV_SQL_ID)
order by
    case a.child_number
        when nvl2(:SQL_ID, to_number(:SQL_CHILD#), to_number(:PREV_CHILD#)) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="SQL_ID">
                            <prompt><![CDATA[SQL_ID]]></prompt>
                            <tooltip><![CDATA[SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="SQL_CHILD#">
                            <prompt><![CDATA[SQL_CHILD#]]></prompt>
                            <tooltip><![CDATA[SQL_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query minversion="18.1">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_reads,                     -- 12.2 and higher
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.result_cache,                     -- 18.1 and higher
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    a.ddl_no_invalidate,                -- 12.2 and higher
    a.is_rolling_invalid,               -- 12.2 and higher
    a.is_rolling_refresh_invalid,       -- 12.2 and higher
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = nvl(:SQL_ID, :PREV_SQL_ID)
order by
    case a.child_number
        when nvl2(:SQL_ID, to_number(:SQL_CHILD#), to_number(:PREV_CHILD#)) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="SQL_ID">
                            <prompt><![CDATA[SQL_ID]]></prompt>
                            <tooltip><![CDATA[SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="SQL_CHILD#">
                            <prompt><![CDATA[SQL_CHILD#]]></prompt>
                            <tooltip><![CDATA[SQL_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query minversion="12.2">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_reads,                     -- 12.2 and higher
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    a.ddl_no_invalidate,                -- 12.2 and higher
    a.is_rolling_invalid,               -- 12.2 and higher
    a.is_rolling_refresh_invalid,       -- 12.2 and higher
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = nvl(:SQL_ID, :PREV_SQL_ID)
order by
    case a.child_number
        when nvl2(:SQL_ID, to_number(:SQL_CHILD#), to_number(:PREV_CHILD#)) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="SQL_ID">
                            <prompt><![CDATA[SQL_ID]]></prompt>
                            <tooltip><![CDATA[SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="SQL_CHILD#">
                            <prompt><![CDATA[SQL_CHILD#]]></prompt>
                            <tooltip><![CDATA[SQL_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query minversion="12.1">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = nvl(:SQL_ID, :PREV_SQL_ID)
order by
    case a.child_number
        when nvl2(:SQL_ID, to_number(:SQL_CHILD#), to_number(:PREV_CHILD#)) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="SQL_ID">
                            <prompt><![CDATA[SQL_ID]]></prompt>
                            <tooltip><![CDATA[SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="SQL_CHILD#">
                            <prompt><![CDATA[SQL_CHILD#]]></prompt>
                            <tooltip><![CDATA[SQL_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query>
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    sqltype
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = nvl(:SQL_ID, :PREV_SQL_ID)
order by
    case a.child_number
        when nvl2(:SQL_ID, to_number(:SQL_CHILD#), to_number(:PREV_CHILD#)) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="SQL_ID">
                            <prompt><![CDATA[SQL_ID]]></prompt>
                            <tooltip><![CDATA[SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="SQL_CHILD#">
                            <prompt><![CDATA[SQL_CHILD#]]></prompt>
                            <tooltip><![CDATA[SQL_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Prev SQL Details]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query minversion="19.1">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_reads,                     -- 12.2 and higher
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.result_cache,                     -- 18.1 and higher
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    a.ddl_no_invalidate,                -- 12.2 and higher
    a.is_rolling_invalid,               -- 12.2 and higher
    a.is_rolling_refresh_invalid,       -- 12.2 and higher
    a.sql_quarantine,                   -- 19.1 and higher
    a.avoided_executions,               -- 19.1 and higher
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = :PREV_SQL_ID
order by
    case a.child_number
        when to_number(:PREV_CHILD#) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query minversion="18.1">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_reads,                     -- 12.2 and higher
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.result_cache,                     -- 18.1 and higher
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    a.ddl_no_invalidate,                -- 12.2 and higher
    a.is_rolling_invalid,               -- 12.2 and higher
    a.is_rolling_refresh_invalid,       -- 12.2 and higher
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = :PREV_SQL_ID
order by
    case a.child_number
        when to_number(:PREV_CHILD#) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query minversion="12.2">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_reads,                     -- 12.2 and higher
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    a.ddl_no_invalidate,                -- 12.2 and higher
    a.is_rolling_invalid,               -- 12.2 and higher
    a.is_rolling_refresh_invalid,       -- 12.2 and higher
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = :PREV_SQL_ID
order by
    case a.child_number
        when to_number(:PREV_CHILD#) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query minversion="12.1">
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.is_resolved_adaptive_plan,        -- 12.1 and higher
    a.full_plan_hash_value,             -- 12.1 and higher
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.im_scans,                         -- 12.1 and higher
    a.im_scan_bytes_uncompressed,       -- 12.1 and higher
    a.im_scan_bytes_inmemory,           -- 12.1 and higher
    a.is_reoptimizable,                 -- 12.1 and higher
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    sqltype,
    a.con_id                            -- 12.1 and higher
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = :PREV_SQL_ID
order by
    case a.child_number
        when to_number(:PREV_CHILD#) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query>
                    <sql><![CDATA[select
    a.sql_id,
    a.child_number,
    a.object_status,
    a.invalidations,
    a.loads, 
    a.parse_calls,
    a.first_load_time, 
    a.last_load_time, 
    a.last_active_time,
    a.users_opening, 
    a.users_executing,
    a.exact_matching_signature, 
    a.force_matching_signature,
    a.plan_hash_value,
    a.executions,
    a.px_servers_executions     as px_execs,
    a.fetches, 
    a.end_of_fetch_count        as eof_count,
    a.rows_processed,
    round(a.rows_processed       / nullif(a.executions, 0), 1)                  as rows_px,
    a.buffer_gets,
    round(a.buffer_gets          / nullif(a.executions, 0), 2)                  as buf_px,
    to_char(a.buffer_gets        / nullif(a.rows_processed, 0), '0.9EEEE')      as bufs_per_row,
    round(a.elapsed_time         / nullif(a.executions, 0) / power(10,3), 2)    as ela_px_ms,
    round(a.cpu_time             / nullif(a.executions, 0) / power(10,3), 2)    as cpu_px_ms,
    round(a.user_io_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as iowait_px_ms,
    round(a.application_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as appwait_px_ms,
    round(a.concurrency_wait_time/ nullif(a.executions, 0) / power(10,3), 2)    as ccywait_px_ms,
    round(a.cluster_wait_time    / nullif(a.executions, 0) / power(10,3), 2)    as cluwait_px_ms,
    round(a.plsql_exec_time      / nullif(a.executions, 0) / power(10,3), 2)    as plsql_time_px_ms,
    round(a.java_exec_time       / nullif(a.executions, 0) / power(10,3), 2)    as java_time_ps_ms,
    c.username                                                                  as parsing_user_name,
    a.parsing_schema_name,
    b.command_name,
    a.sql_fulltext,
    a.optimizer_mode,
    a.sorts,
    a.disk_reads,
    a.direct_writes,
    a.physical_read_requests,
    round(a.physical_read_bytes  / power(2,20), 2)  as phys_read_mb,
    a.physical_write_requests,
    round(a.physical_write_bytes / power(2,20), 2)  as phys_write_mb,
    a.optimized_phy_read_requests,
    a.io_interconnect_bytes,
    a.io_cell_uncompressed_bytes,
    a.io_cell_offload_eligible_bytes,
    a.io_cell_offload_returned_bytes,
    a.is_obsolete,
    a.is_bind_sensitive,
    a.is_bind_aware,
    a.is_shareable,
    a.outline_category,
    a.outline_sid,
    a.sql_profile,
    a.sql_patch,
    a.sql_plan_baseline,
    a.remote,
    round(a.elapsed_time           / power(10,6), 1)   as elapsed_time_s,
    round(a.cpu_time               / power(10,6), 1)   as cpu_time_s,
    round(a.user_io_wait_time      / power(10,6), 1)   as user_io_wait_s,
    round(a.application_wait_time  / power(10,6), 1)   as app_wait_time_s,
    round(a.concurrency_wait_time  / power(10,6), 1)   as ccy_wait_time_s,
    round(a.cluster_wait_time      / power(10,6), 1)   as clus_wait_time_s,
    round(a.plsql_exec_time        / power(10,6), 1)   as plsql_exec_time_s,
    round(a.java_exec_time         / power(10,6), 1)   as java_exec_time_s,
    a.loaded_versions, 
    a.open_versions,
    a.kept_versions,
    a.locked_total, 
    a.pinned_total,
    a.serializable_aborts,
    sqltype
from
    v$sql a,
    v$sqlcommand b,
    all_users c 
where
    a.command_type = b.command_type (+)
    and a.parsing_user_id = c.user_id (+)
    and a.sql_id = :PREV_SQL_ID
order by
    case a.child_number
        when to_number(:PREV_CHILD#) then
            0
        else
            1
    end asc,
    a.last_active_time desc,
    a.child_number asc]]></sql>
                    <binds>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[SQL Plan]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[with
db_release_level as (
    select
        c##pkg_pub_utility.db_version   as version,
        c##pkg_pub_utility.db_release   as release
    from
        dual
),
bind_values as (
    select
        plan_display_opts
    from
        xmltable(
            '/bindData' passing xmlparse(document :Bind_data)
            columns
                plan_display_opts varchar2(200) path 'planDisplayOpts'
        )
),
display_plan_options as (
    select
        'Advanced -projection '
            || case
                   when lev.version >= 12 then
                       '+adaptive '
               end
            || case
                   when lev.version >= 19 then
                       '-qbregistry '
               end
            || '+allstats last '
            || bnd.plan_display_opts
        as plan_options
    from
        db_release_level lev,
        bind_values bnd
),
target_cursor_plus as (
    select
        nvl(:SQL_ID, :PREV_SQL_ID)              as sql_id,
        nvl2(:SQL_ID,
             cast(:SQL_CHILD# as number),
             cast(:PREV_CHILD# as number))      as sql_child#,
        plan_options
    from
        display_plan_options
    where
        :SQL_ID is not null
        or :PREV_SQL_ID is not null
)
select b.*
from 
    target_cursor_plus a,
    table(dbms_xplan.display_cursor(
            sql_id => a.sql_id,
            cursor_child_no => a.sql_child#,
            format => a.plan_options
    )) b]]></sql>
                    <binds>
                        <bind id="SQL_ID">
                            <prompt><![CDATA[SQL_ID]]></prompt>
                            <tooltip><![CDATA[SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="SQL_CHILD#">
                            <prompt><![CDATA[SQL_CHILD#]]></prompt>
                            <tooltip><![CDATA[SQL_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Bind_data">
                            <prompt><![CDATA[Bind_data]]></prompt>
                            <tooltip><![CDATA[Bind_data]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[Prev SQL Plan]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[with
db_release_level as (
    select
        c##pkg_pub_utility.db_version   as version,
        c##pkg_pub_utility.db_release   as release
    from
        dual
),
bind_values as (
    select
        plan_display_opts
    from
        xmltable(
            '/bindData' passing xmlparse(document :Bind_data)
            columns
                plan_display_opts varchar2(200) path 'planDisplayOpts'
        )
),
display_plan_options as (
    select
        'Advanced -projection '
            || case
                   when lev.version >= 12 then
                       '+adaptive '
               end
            || case
                   when lev.version >= 19 then
                       '-qbregistry '
               end
            || '+allstats last '
            || bnd.plan_display_opts
        as plan_options
    from
        db_release_level lev,
        bind_values bnd
),
target_cursor_plus as (
    select
        :PREV_SQL_ID                    as sql_id,
        cast(:PREV_CHILD# as number)    as sql_child#,
        plan_options
    from
        display_plan_options
    where
        :PREV_SQL_ID is not null
)
select b.*
from 
    target_cursor_plus a,
    table(dbms_xplan.display_cursor(
            sql_id => a.sql_id,
            cursor_child_no => a.sql_child#,
            format => a.plan_options
    )) b]]></sql>
                    <binds>
                        <bind id="PREV_SQL_ID">
                            <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                            <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="PREV_CHILD#">
                            <prompt><![CDATA[PREV_CHILD#]]></prompt>
                            <tooltip><![CDATA[PREV_CHILD#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Plan_display_opts">
                            <prompt><![CDATA[Plan_display_opts]]></prompt>
                            <tooltip><![CDATA[Plan_display_opts]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Script" enable="true">
            <name><![CDATA[SQL Mon.]]></name>
            <description><![CDATA[SQL Monitoring Report (text) for the latest query in the session]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
            </CustomValues>
            <query>
                <sql><![CDATA[
whenever sqlerror exit failure rollback

set long 5000000
set linesize 600
set heading off
set feedback off
set pagesize 0

column sql_monitor_report format a600 word_wrapped

with
target_sql_exec as (
    select
        nvl(:SQL_ID, :PREV_SQL_ID)                                as sql_id,
        nvl2(:SQL_ID,
             cast(:Sql_exec_id as number),
             cast(:Prev_exec_id as number))                       as sql_exec_id,
        nvl2(:SQL_ID,
             to_date(:Sql_exec_start, 'YYYY-MM-DD HH24:MI:SS'),
             to_date(:Prev_exec_start, 'YYYY-MM-DD HH24:MI:SS'))  as sql_exec_start
    from
        dual
    where
        :SQL_ID is not null
        or :PREV_SQL_ID is not null
)
select
    dbms_sqltune.report_sql_monitor(
        type => 'TEXT',
        sql_id => x.sql_id,
        sql_exec_id => x.sql_exec_id,
        sql_exec_start => x.sql_exec_start,
        report_level => 'ALL'
    ) as sql_monitor_report
from
    target_sql_exec x
where
    x.sql_id is not null
    and x.sql_exec_id is not null
    and x.sql_exec_start is not null;
]]></sql>
                <binds>
                    <bind id="SQL_ID">
                        <prompt><![CDATA[SQL_ID]]></prompt>
                        <tooltip><![CDATA[SQL_ID]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="PREV_SQL_ID">
                        <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                        <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Sql_exec_id">
                        <prompt><![CDATA[Sql_exec_id]]></prompt>
                        <tooltip><![CDATA[Sql_exec_id]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Prev_exec_id">
                        <prompt><![CDATA[Prev_exec_id]]></prompt>
                        <tooltip><![CDATA[Prev_exec_id]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Sql_exec_start">
                        <prompt><![CDATA[Sql_exec_start]]></prompt>
                        <tooltip><![CDATA[Sql_exec_start]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Prev_exec_start">
                        <prompt><![CDATA[Prev_exec_start]]></prompt>
                        <tooltip><![CDATA[Prev_exec_start]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
        </display>
        <display id="null" type="" style="Script" enable="true">
            <name><![CDATA[Prev SQL Mon.]]></name>
            <description><![CDATA[SQL Monitoring Report (text) for the 2nd latest query in the session]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
            </CustomValues>
            <query>
                <sql><![CDATA[
whenever sqlerror exit failure rollback

set long 5000000
set linesize 600
set heading off
set feedback off
set pagesize 0

column sql_monitor_report format a600 word_wrapped

with
target_sql_exec as (
    select
        :PREV_SQL_ID                                         as sql_id,
        cast(:Prev_exec_id as number)                        as sql_exec_id,
        to_date(:Prev_exec_start, 'YYYY-MM-DD HH24:MI:SS')   as sql_exec_start
    from
        dual
    where
        :PREV_SQL_ID is not null
)
select
    dbms_sqltune.report_sql_monitor(
        type => 'TEXT',
        sql_id => x.sql_id,
        sql_exec_id => x.sql_exec_id,
        sql_exec_start => x.sql_exec_start,
        report_level => 'ALL'
    ) as sql_monitor_report
from
    target_sql_exec x
where
    x.sql_id is not null
    and x.sql_exec_id is not null
    and x.sql_exec_start is not null;
]]></sql>
                <binds>
                    <bind id="PREV_SQL_ID">
                        <prompt><![CDATA[PREV_SQL_ID]]></prompt>
                        <tooltip><![CDATA[PREV_SQL_ID]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Prev_exec_id">
                        <prompt><![CDATA[Prev_exec_id]]></prompt>
                        <tooltip><![CDATA[Prev_exec_id]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Prev_exec_start">
                        <prompt><![CDATA[Prev_exec_start]]></prompt>
                        <tooltip><![CDATA[Prev_exec_start]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
        </display>
        <display id="null" type="" style="Table" enable="true">
            <name><![CDATA[ASH Summary]]></name>
            <description><![CDATA[ASH-based summary of this session's activity]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
                <TYPE><![CDATA[horizontal]]></TYPE>
            </CustomValues>
            <queries>
                <query minversion="12.1">
                    <sql><![CDATA[with
bind_values as (
    select
        ash_summary_mins
    from
        xmltable(
            '/bindData' passing xmlparse(document :Bind_data)
            columns
                ash_summary_mins varchar2(200) path 'ashSummaryTimespan'
        )
),
ash_detail as (
    select
        ash1.*,
        extract(second from sample_time - sql_exec_start) * 1
            + extract(minute from sample_time - sql_exec_start) * 60
            + extract(hour from sample_time - sql_exec_start) * 3600
            + extract(day from sample_time - sql_exec_start) * 86400  as sql_exec_ela_s,
        extract(second from sample_time - grp_start_sample_time) * 1
            + extract(minute from sample_time - grp_start_sample_time) * 60
            + extract(hour from sample_time - grp_start_sample_time) * 3600
            + extract(day from sample_time - grp_start_sample_time) * 86400  as group_ela_s
    from
        (select
            ash0.*,
            last_value(ash0.grp_1st_sample_time) ignore nulls
                over (order by sample_id)  as grp_start_sample_time
        from
            (select
                inst_id,
                session_id,
                session_serial#,
                sample_id,
                sample_time,
                module,
                action,
                client_id,
                xid,
                ecid,
                in_parse,
                in_hard_parse,
                is_sqlid_current,
                sql_opcode,
                force_matching_signature,
                sql_id,
                sql_exec_id,
                sql_exec_start,
                sql_full_plan_hash_value,  -- 12.1 and higher
                sql_plan_hash_value,
                tm_delta_time,
                tm_delta_cpu_time,
                tm_delta_db_time,
                temp_space_allocated,
                pga_allocated,
                case
                    when lag(sample_id) over (order by sample_id) is null then
                        sample_time
                    when sys_op_map_nonnull(in_parse)
                            <> sys_op_map_nonnull(lag(in_parse) over (order by sample_id))
                        or sys_op_map_nonnull(in_hard_parse)
                            <> sys_op_map_nonnull(lag(in_hard_parse) over (order by sample_id))
                        or sys_op_map_nonnull(sql_id) 
                            <> sys_op_map_nonnull(lag(sql_id) over (order by sample_id))
                        or sys_op_map_nonnull(sql_exec_id)
                            <> sys_op_map_nonnull(lag(sql_exec_id) over (order by sample_id))
                        or sys_op_map_nonnull(sql_exec_start)
                            <> sys_op_map_nonnull(lag(sql_exec_start) over (order by sample_id))
                        or sys_op_map_nonnull(sql_full_plan_hash_value)                                     -- 12.1 and higher
                            <> sys_op_map_nonnull(lag(sql_full_plan_hash_value) over (order by sample_id))  -- 12.1 and higher
                        or sys_op_map_nonnull(sql_plan_hash_value)
                            <> sys_op_map_nonnull(lag(sql_plan_hash_value) over (order by sample_id))
                    then
                        sample_time
                end  as grp_1st_sample_time
            from
                gv$active_session_history 
            where
                inst_id = :Inst_id
                and session_id = :Sid
                and session_serial# = :Serial#
                and sample_time >= nvl((select localtimestamp
                                                - numtodsinterval(bnd.ash_summary_mins, 'MINUTE')
                                        from bind_values bnd), timestamp '1970-01-01 00:00:00')
            ) ash0
        ) ash1
),
ash_summary as (
    select
        ash.inst_id,
        ash.session_id,
        ash.session_serial#,
        min(sample_id)          as sample_id_start,
        max(sample_id)          as sample_id_end,
        min(sample_time)        as sample_time_start,
        max(sample_time)        as sample_time_end,
        max(sample_time) - min(sample_time)  as elapsed,
        count(*)                as cnt_samp,
        count(case
                  when is_sqlid_current = 'Y' then
                      1
              end)              as cnt_current_sql,
        ash.in_parse,
        ash.in_hard_parse,
        max(ash.sql_opcode) keep (dense_rank first order by sample_id desc)  as sql_opcode,
        max(ash.force_matching_signature)
                keep (dense_rank first order by sample_id desc)             as force_matching_signature,
        ash.sql_id,
        ash.sql_exec_id,
        ash.sql_exec_start,
        ash.sql_full_plan_hash_value,  -- 12.1 and higher
        ash.sql_plan_hash_value,
        sum(ash.tm_delta_cpu_time
                * least((nvl(sql_exec_ela_s, group_ela_s)
                            * power(10,6) / ash.tm_delta_time)
                        , 1))
            / power(10, 6)                                                  as cpu_time_s,
        sum(ash.tm_delta_db_time
                * least((nvl(sql_exec_ela_s, group_ela_s)
                            * power(10,6) / ash.tm_delta_time)
                        , 1))
            / power(10, 6)                                                  as db_time_s,
        max(ash.pga_allocated)                                              as pga_allocated,
        max(ash.temp_space_allocated)                                       as temp_space_allocated,
        max(ash.module) keep (dense_rank first order by sample_id desc)     as module,
        max(ash.action) keep (dense_rank first order by sample_id desc)     as action,
        max(ash.client_id) keep (dense_rank first order by sample_id desc)  as client_id,
        max(ash.xid) keep (dense_rank first order by sample_id desc)        as xid,
        max(ash.ecid) keep (dense_rank first order by sample_id desc)       as ecid,
        lag(max(sample_id)) over (order by min(sample_id))                  as prev_sample_id_end,
        lag(max(sample_time)) over (order by min(sample_id))                as prev_sample_time_end,
        min(sample_id) - lag(max(sample_id)) over (order by min(sample_id)) as delta_sample_id,
        min(sample_time) - lag(max(sample_time)) over (order by min(sample_id)) as delta_sample_time
    from
        ash_detail ash
    group by
        ash.inst_id,
        ash.session_id,
        ash.session_serial#,
        ash.grp_start_sample_time,
        ash.in_parse,
        ash.in_hard_parse,
        ash.sql_id,
        ash.sql_exec_id,
        ash.sql_exec_start,
        ash.sql_full_plan_hash_value,  -- 12.1 and higher
        ash.sql_plan_hash_value
),
ash_summary_plus_gaps as (
    select
        asu.inst_id,
        asu.session_id,
        asu.session_serial#,
        case
            when gap.column_value = 1 then
                asu.sample_id_start
            else
                asu.prev_sample_id_end + 1
        end  as sample_id_start,
        case
            when gap.column_value = 1 then
                asu.sample_id_end
            else
                asu.sample_id_start - 1
        end  as sample_id_end,
        case
            when gap.column_value = 1 then
                asu.sample_time_start
            else
                asu.prev_sample_time_end + numtodsinterval(1, 'SECOND')
        end  as sample_time_start,
        case
            when gap.column_value = 1 then
                asu.sample_time_end
            else
                asu.sample_time_start - numtodsinterval(1, 'SECOND')
        end  as sample_time_end,
        case
            when gap.column_value = 1 then
                'ACTIVE'
            else
                'INACTIVE'
        end  as status,
        case
            when gap.column_value = 1 then
                asu.elapsed
            else
                asu.delta_sample_time - numtodsinterval(1, 'SECOND')
        end  as elapsed,
        case
            when gap.column_value = 1 then
                asu.cnt_samp
        end  as cnt_samp,
        case
            when gap.column_value = 1 then
                asu.cnt_current_sql
        end  as cnt_current_sql,
        case
            when gap.column_value = 1 then
                asu.in_parse
        end  as in_parse,
        case
            when gap.column_value = 1 then
                asu.in_hard_parse
        end  as in_hard_parse,
        case
            when gap.column_value = 1 then
                asu.sql_opcode
        end  as sql_opcode,
        case
            when gap.column_value = 1 then
                asu.force_matching_signature
        end  as force_matching_signature,
        case
            when gap.column_value = 1 then
                asu.sql_id
        end  as sql_id,
        case
            when gap.column_value = 1 then
                asu.sql_exec_id
        end  as sql_exec_id,
        case
            when gap.column_value = 1 then
                asu.sql_exec_start
        end  as sql_exec_start,
        case
            when gap.column_value = 1 then
                asu.sql_full_plan_hash_value
        end  as sql_full_plan_hash_value,     -- 12.1 and higher
        case
            when gap.column_value = 1 then
                asu.sql_plan_hash_value
        end  as sql_plan_hash_value,
        case
            when gap.column_value = 1 then
                asu.cpu_time_s
        end  as cpu_time_s,
        case
            when gap.column_value = 1 then
                asu.db_time_s
        end  as db_time_s,
        case
            when gap.column_value = 1 then
                asu.pga_allocated
        end  as pga_allocated,
        case
            when gap.column_value = 1 then
                asu.temp_space_allocated
        end  as temp_space_allocated,
        case
            when gap.column_value = 1 then
                asu.module
        end  as module,
        case
            when gap.column_value = 1 then
                asu.action
        end  as action,
        case
            when gap.column_value = 1 then
                asu.client_id
        end  as client_id,
        case
            when gap.column_value = 1 then
                asu.xid
        end  as xid,
        case
            when gap.column_value = 1 then
                asu.ecid
        end  as ecid
    from
        ash_summary asu,
        table(cast(multiset(
                select level from dual
                connect by level <= least(nvl(asu.delta_sample_id, 1), 2)
            ) as sys.odcinumberlist)) gap
)
select
    asg.inst_id                                     as "Inst_id",
    asg.session_id                                  as "Sid",
    asg.session_serial#                             as "Serial#",
    asg.sample_id_start                             as "From_sample_id",
    asg.sample_id_end                               as "To_sample_id",
    asg.sample_time_start                           as "From_sample_time",
    asg.sample_time_end                             as "To_sample_time",
    asg.status                                      as "Status",
    asg.elapsed                                     as "Elapsed",
    c##pkg_pub_utility.prec_round(
        extract(second from asg.elapsed) * 1
        + extract(minute from asg.elapsed) * 60
        + extract(hour from asg.elapsed) * 3600
        + extract(day from asg.elapsed) * 86400)    as "Ela (s)",
    c##pkg_pub_utility.prec_round(asg.cpu_time_s)   as "CPU time (s)",
    c##pkg_pub_utility.prec_round(asg.db_time_s)    as "DB time (s)",
    asg.cnt_samp                                    as "# Samp",
    asg.cnt_current_sql                             as "# Samp curr. SQL",
    asg.in_parse                                    as "In parse?",
    asg.in_hard_parse                               as "In hard parse?",
    cmd.command_name                                as "SQL cmd",
    asg.force_matching_signature                    as "Force matching signature",
    asg.sql_id,
    asg.sql_exec_id                                 as "Sql_exec_id",
    asg.sql_exec_start                              as "Sql_exec_start",
    asg.sql_full_plan_hash_value                    as "Full_plan_hash_value",  -- 12.1 and higher
    asg.sql_plan_hash_value                         as "Plan_hash_value",
    c##pkg_pub_utility.prec_round(asg.pga_allocated / power(2,20))          as "PGA alloc (Mb)",
    c##pkg_pub_utility.prec_round(asg.temp_space_allocated / power(2,20))   as "Temp space (Mb)",
    asg.module                                      as "Module",
    asg.action                                      as "Action",
    asg.client_id                                   as "Client_identifier",
    asg.xid,
    asg.ecid,
    sqla.sql_fulltext                               as "SQL_fulltext"
from
    ash_summary_plus_gaps asg,
    v$sqlcommand cmd,
    gv$sqlarea sqla
where
    asg.sql_opcode = cmd.command_type (+)
    and sqla.inst_id (+) = asg.inst_id
    and sqla.sql_id (+) = asg.sql_id
order by
    asg.sample_id_end desc,
    asg.sample_id_start desc]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Serial#">
                            <prompt><![CDATA[Serial#]]></prompt>
                            <tooltip><![CDATA[Serial#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Bind_data">
                            <prompt><![CDATA[Bind_data]]></prompt>
                            <tooltip><![CDATA[Bind_data]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
                <query>
                    <sql><![CDATA[with
bind_values as (
    select
        ash_summary_mins
    from
        xmltable(
            '/bindData' passing xmlparse(document :Bind_data)
            columns
                ash_summary_mins varchar2(200) path 'ashSummaryTimespan'
        )
),
ash_detail as (
    select
        ash1.*,
        extract(second from sample_time - sql_exec_start) * 1
            + extract(minute from sample_time - sql_exec_start) * 60
            + extract(hour from sample_time - sql_exec_start) * 3600
            + extract(day from sample_time - sql_exec_start) * 86400  as sql_exec_ela_s,
        extract(second from sample_time - grp_start_sample_time) * 1
            + extract(minute from sample_time - grp_start_sample_time) * 60
            + extract(hour from sample_time - grp_start_sample_time) * 3600
            + extract(day from sample_time - grp_start_sample_time) * 86400  as group_ela_s
    from
        (select
            ash0.*,
            last_value(ash0.grp_1st_sample_time) ignore nulls
                over (order by sample_id)  as grp_start_sample_time
        from
            (select
                inst_id,
                session_id,
                session_serial#,
                sample_id,
                sample_time,
                module,
                action,
                client_id,
                xid,
                ecid,
                in_parse,
                in_hard_parse,
                is_sqlid_current,
                sql_opcode,
                force_matching_signature,
                sql_id,
                sql_exec_id,
                sql_exec_start,
                sql_plan_hash_value,
                tm_delta_time,
                tm_delta_cpu_time,
                tm_delta_db_time,
                temp_space_allocated,
                pga_allocated,
                case
                    when lag(sample_id) over (order by sample_id) is null then
                        sample_time
                    when sys_op_map_nonnull(in_parse)
                            <> sys_op_map_nonnull(lag(in_parse) over (order by sample_id))
                        or sys_op_map_nonnull(in_hard_parse)
                            <> sys_op_map_nonnull(lag(in_hard_parse) over (order by sample_id))
                        or sys_op_map_nonnull(sql_id) 
                            <> sys_op_map_nonnull(lag(sql_id) over (order by sample_id))
                        or sys_op_map_nonnull(sql_exec_id)
                            <> sys_op_map_nonnull(lag(sql_exec_id) over (order by sample_id))
                        or sys_op_map_nonnull(sql_exec_start)
                            <> sys_op_map_nonnull(lag(sql_exec_start) over (order by sample_id))
                        or sys_op_map_nonnull(sql_plan_hash_value)
                            <> sys_op_map_nonnull(lag(sql_plan_hash_value) over (order by sample_id))
                    then
                        sample_time
                end  as grp_1st_sample_time
            from
                gv$active_session_history 
            where
                inst_id = :Inst_id
                and session_id = :Sid
                and session_serial# = :Serial#
                and sample_time >= nvl((select localtimestamp
                                                - numtodsinterval(bnd.ash_summary_mins, 'MINUTE')
                                        from bind_values bnd), timestamp '1970-01-01 00:00:00')
            ) ash0
        ) ash1
),
ash_summary as (
    select
        ash.inst_id,
        ash.session_id,
        ash.session_serial#,
        min(sample_id)          as sample_id_start,
        max(sample_id)          as sample_id_end,
        min(sample_time)        as sample_time_start,
        max(sample_time)        as sample_time_end,
        max(sample_time) - min(sample_time)  as elapsed,
        count(*)                as cnt_samp,
        count(case
                  when is_sqlid_current = 'Y' then
                      1
              end)              as cnt_current_sql,
        ash.in_parse,
        ash.in_hard_parse,
        max(ash.sql_opcode) keep (dense_rank first order by sample_id desc)  as sql_opcode,
        max(ash.force_matching_signature)
                keep (dense_rank first order by sample_id desc)             as force_matching_signature,
        ash.sql_id,
        ash.sql_exec_id,
        ash.sql_exec_start,
        ash.sql_plan_hash_value,
        sum(ash.tm_delta_cpu_time
                * least((nvl(sql_exec_ela_s, group_ela_s)
                            * power(10,6) / ash.tm_delta_time)
                        , 1))
            / power(10, 6)                                                  as cpu_time_s,
        sum(ash.tm_delta_db_time
                * least((nvl(sql_exec_ela_s, group_ela_s)
                            * power(10,6) / ash.tm_delta_time)
                        , 1))
            / power(10, 6)                                                  as db_time_s,
        max(ash.pga_allocated)                                              as pga_allocated,
        max(ash.temp_space_allocated)                                       as temp_space_allocated,
        max(ash.module) keep (dense_rank first order by sample_id desc)     as module,
        max(ash.action) keep (dense_rank first order by sample_id desc)     as action,
        max(ash.client_id) keep (dense_rank first order by sample_id desc)  as client_id,
        max(ash.xid) keep (dense_rank first order by sample_id desc)        as xid,
        max(ash.ecid) keep (dense_rank first order by sample_id desc)       as ecid,
        lag(max(sample_id)) over (order by min(sample_id))                  as prev_sample_id_end,
        lag(max(sample_time)) over (order by min(sample_id))                as prev_sample_time_end,
        min(sample_id) - lag(max(sample_id)) over (order by min(sample_id)) as delta_sample_id,
        min(sample_time) - lag(max(sample_time)) over (order by min(sample_id)) as delta_sample_time
    from
        ash_detail ash
    group by
        ash.inst_id,
        ash.session_id,
        ash.session_serial#,
        ash.grp_start_sample_time,
        ash.in_parse,
        ash.in_hard_parse,
        ash.sql_id,
        ash.sql_exec_id,
        ash.sql_exec_start,
        ash.sql_plan_hash_value
),
ash_summary_plus_gaps as (
    select
        asu.inst_id,
        asu.session_id,
        asu.session_serial#,
        case
            when gap.column_value = 1 then
                asu.sample_id_start
            else
                asu.prev_sample_id_end + 1
        end  as sample_id_start,
        case
            when gap.column_value = 1 then
                asu.sample_id_end
            else
                asu.sample_id_start - 1
        end  as sample_id_end,
        case
            when gap.column_value = 1 then
                asu.sample_time_start
            else
                asu.prev_sample_time_end + numtodsinterval(1, 'SECOND')
        end  as sample_time_start,
        case
            when gap.column_value = 1 then
                asu.sample_time_end
            else
                asu.sample_time_start - numtodsinterval(1, 'SECOND')
        end  as sample_time_end,
        case
            when gap.column_value = 1 then
                'ACTIVE'
            else
                'INACTIVE'
        end  as status,
        case
            when gap.column_value = 1 then
                asu.elapsed
            else
                asu.delta_sample_time - numtodsinterval(1, 'SECOND')
        end  as elapsed,
        case
            when gap.column_value = 1 then
                asu.cnt_samp
        end  as cnt_samp,
        case
            when gap.column_value = 1 then
                asu.cnt_current_sql
        end  as cnt_current_sql,
        case
            when gap.column_value = 1 then
                asu.in_parse
        end  as in_parse,
        case
            when gap.column_value = 1 then
                asu.in_hard_parse
        end  as in_hard_parse,
        case
            when gap.column_value = 1 then
                asu.sql_opcode
        end  as sql_opcode,
        case
            when gap.column_value = 1 then
                asu.force_matching_signature
        end  as force_matching_signature,
        case
            when gap.column_value = 1 then
                asu.sql_id
        end  as sql_id,
        case
            when gap.column_value = 1 then
                asu.sql_exec_id
        end  as sql_exec_id,
        case
            when gap.column_value = 1 then
                asu.sql_exec_start
        end  as sql_exec_start,
        case
            when gap.column_value = 1 then
                asu.sql_plan_hash_value
        end  as sql_plan_hash_value,
        case
            when gap.column_value = 1 then
                asu.cpu_time_s
        end  as cpu_time_s,
        case
            when gap.column_value = 1 then
                asu.db_time_s
        end  as db_time_s,
        case
            when gap.column_value = 1 then
                asu.pga_allocated
        end  as pga_allocated,
        case
            when gap.column_value = 1 then
                asu.temp_space_allocated
        end  as temp_space_allocated,
        case
            when gap.column_value = 1 then
                asu.module
        end  as module,
        case
            when gap.column_value = 1 then
                asu.action
        end  as action,
        case
            when gap.column_value = 1 then
                asu.client_id
        end  as client_id,
        case
            when gap.column_value = 1 then
                asu.xid
        end  as xid,
        case
            when gap.column_value = 1 then
                asu.ecid
        end  as ecid
    from
        ash_summary asu,
        table(cast(multiset(
                select level from dual
                connect by level <= least(nvl(asu.delta_sample_id, 1), 2)
            ) as sys.odcinumberlist)) gap
)
select
    asg.inst_id                                     as "Inst_id",
    asg.session_id                                  as "Sid",
    asg.session_serial#                             as "Serial#",
    asg.sample_id_start                             as "From_sample_id",
    asg.sample_id_end                               as "To_sample_id",
    asg.sample_time_start                           as "From_sample_time",
    asg.sample_time_end                             as "To_sample_time",
    asg.status                                      as "Status",
    asg.elapsed                                     as "Elapsed",
    c##pkg_pub_utility.prec_round(
        extract(second from asg.elapsed) * 1
        + extract(minute from asg.elapsed) * 60
        + extract(hour from asg.elapsed) * 3600
        + extract(day from asg.elapsed) * 86400)    as "Ela (s)",
    c##pkg_pub_utility.prec_round(asg.cpu_time_s)   as "CPU time (s)",
    c##pkg_pub_utility.prec_round(asg.db_time_s)    as "DB time (s)",
    asg.cnt_samp                                    as "# Samp",
    asg.cnt_current_sql                             as "# Samp curr. SQL",
    asg.in_parse                                    as "In parse?",
    asg.in_hard_parse                               as "In hard parse?",
    cmd.command_name                                as "SQL cmd",
    asg.force_matching_signature                    as "Force matching signature",
    asg.sql_id,
    asg.sql_exec_id                                 as "Sql_exec_id",
    asg.sql_exec_start                              as "Sql_exec_start",
    asg.sql_plan_hash_value                         as "Plan_hash_value",
    c##pkg_pub_utility.prec_round(asg.pga_allocated / power(2,20))          as "PGA alloc (Mb)",
    c##pkg_pub_utility.prec_round(asg.temp_space_allocated / power(2,20))   as "Temp space (Mb)",
    asg.module                                      as "Module",
    asg.action                                      as "Action",
    asg.client_id                                   as "Client_identifier",
    asg.xid,
    asg.ecid,
    sqla.sql_fulltext                               as "SQL_fulltext"
from
    ash_summary_plus_gaps asg,
    v$sqlcommand cmd,
    gv$sqlarea sqla
where
    asg.sql_opcode = cmd.command_type (+)
    and sqla.inst_id (+) = asg.inst_id
    and sqla.sql_id (+) = asg.sql_id
order by
    asg.sample_id_end desc,
    asg.sample_id_start desc]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Serial#">
                            <prompt><![CDATA[Serial#]]></prompt>
                            <tooltip><![CDATA[Serial#]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Bind_data">
                            <prompt><![CDATA[Bind_data]]></prompt>
                            <tooltip><![CDATA[Bind_data]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Script" enable="true">
            <name><![CDATA[Snapper]]></name>
            <description><![CDATA[This tab runs Tanel Poder's Snapper script on the specified session.]]></description>
            <tooltip><![CDATA[Tanel Poder's Snapper]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
            </CustomValues>
            <query>
                <sql><![CDATA[
define def_tpt_oracle_dir   = ""
define def_snapper_interval = ""
define def_session_id       = ""

set termout off

column tpt_oracle_dir   noprint new_value def_tpt_oracle_dir
column snapper_interval noprint new_value def_snapper_interval
column session_id       noprint new_value def_session_id

select
    to_char(:Sid)  as session_id,
    bnd.snapper_interval,
    bnd.tpt_oracle_dir
from
    xmltable(
        '/bindData' passing xmlparse(document :Bind_data)
        columns
            snapper_interval  number         path 'snapperInterval',
            tpt_oracle_dir    varchar2(500)  path 'TPTOracleDir'
    ) bnd;

column tpt_oracle_dir   clear
column snapper_interval clear
column session_id       clear

whenever sqlerror exit failure rollback

-- "Exit" script silently if the session_id is not set yet
column is_session_id_set noprint
select
    to_number(case 
                  when '&&def_session_id' is null then
                      'NULL_SO_FAR'
              end) as is_session_id_set
from
    dual;
column is_session_id_set clear

whenever sqlerror continue none

set verify off
set termout on

@&&def_tpt_oracle_dir/snapper ash,stats,gather=stw &&def_snapper_interval 1 sid=&&def_session_id

undefine def_tpt_oracle_dir
undefine def_snapper_interval
undefine def_session_id
]]></sql>
                <binds>
                    <bind id="Sid">
                        <prompt><![CDATA[Sid]]></prompt>
                        <tooltip><![CDATA[Sid]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="Bind_data">
                        <prompt><![CDATA[Bind_data]]></prompt>
                        <tooltip><![CDATA[Bind_data]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
        </display>
        <display id="null" type="" style="Script" enable="true">
            <name><![CDATA[ASH Report (text)]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[whenever sqlerror exit failure rollback
clear screen
set feedback off
set pagesize 0
set verify off
set termout off

-- "Exit" script silently if binds are not set yet
column is_inst_id_set     noprint
column is_session_id_set  noprint
column is_bind_data_set   noprint
select
    to_number(case 
                  when :Inst_id is null then
                      'NULL_SO_FAR'
              end) as is_inst_id_set,
    to_number(case
                  when :Sid is null then
                      'NULL_SO_FAR'
              end) as is_session_id_set,
    to_number(case
                  when :Bind_data is null then
                      'NULL_SO_FAR'
              end) as is_bind_data_set
from
    dual;
column is_inst_id_set     clear
column is_session_id_set  clear
column is_bind_data_set   clear

set termout on

select
    rep.* 
from
    xmltable(
        '/bindData' passing xmlparse(document :Bind_data)
        columns
            ash_time_span   number  path 'ashTimespan',
            ash_time_bucket number  path 'ashTimeBucket'
    ) bnd,
    table(
        dbms_workload_repository.ash_report_text(
            l_dbid => (select dbid from v$database),
            l_inst_num => :Inst_id,
            l_sid => :Sid,
            l_btime => sysdate - bnd.ash_time_span / 1440,
            l_etime => sysdate,
            l_slot_width => bnd.ash_time_bucket,
            l_data_src => 0
        )) rep
;

undefine def_default_ash_time_span
undefine def_default_ash_time_bucket
]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Bind_data">
                            <prompt><![CDATA[Bind_data]]></prompt>
                            <tooltip><![CDATA[Bind_data]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
        <display id="null" type="" style="Script" enable="true">
            <name><![CDATA[ASH Report (HTML)]]></name>
            <description><![CDATA[]]></description>
            <tooltip><![CDATA[]]></tooltip>
            <drillclass><![CDATA[]]></drillclass>
            <CustomValues>
            </CustomValues>
            <queries>
                <query>
                    <sql><![CDATA[whenever sqlerror exit failure rollback
whenever oserror exit failure rollback

set long 5000000
set linesize 10000
set trimspool on
set heading off
set feedback off
set pagesize 0

set termout off
set verify off

define def_spool_directory = ""
define def_spool_filename  = ""
define def_instance_name   = ""
define def_ash_time_span   = ""
define def_ash_time_bucket = ""

-- "Exit" script silently if binds are not set yet
column is_inst_id_set     noprint
column is_session_id_set  noprint
column is_bind_data_set   noprint
select
    to_number(case 
                  when :Inst_id is null then
                      'NULL_SO_FAR'
              end) as is_inst_id_set,
    to_number(case
                  when :Sid is null then
                      'NULL_SO_FAR'
              end) as is_session_id_set,
    to_number(case
                  when :Bind_data is null then
                      'NULL_SO_FAR'
              end) as is_bind_data_set
from
    dual;
column is_inst_id_set     clear
column is_session_id_set  clear
column is_bind_data_set   clear

column instance_name   noprint new_value def_instance_name
column spool_directory noprint new_value def_spool_directory
column spool_filename  noprint new_value def_spool_filename
column ash_time_span   noprint new_value def_ash_time_span
column ash_time_bucket noprint new_value def_ash_time_bucket

select
    instance_name
from
    gv$instance
where
    inst_id = :Inst_id;

select
    bnd.ash_time_span,
    bnd.ash_time_bucket,
    bnd.spool_directory,
    'ASH'
        || '-&&def_instance_name'
        || '-' || to_char(sysdate - bnd.ash_time_span / 1440, 'YYYYMMDD_HH24MISS')
        || '-' || to_char(sysdate, 'YYYYMMDD_HH24MISS')
        || '-' || to_char(:Sid)
        || '.html'  as spool_filename
from
    xmltable(
        '/bindData' passing xmlparse(document :Bind_data)
        columns
            ash_time_span     number         path 'ashTimespan',
            ash_time_bucket   number         path 'ashTimeBucket',
            spool_directory   varchar2(500)  path 'spoolDirectory'
    ) bnd;

cd "&&def_spool_directory"

spool "&&def_spool_filename"

select * from table(
    dbms_workload_repository.ash_report_html(
        l_dbid => (select dbid from v$database),
        l_inst_num => :Inst_id,
        l_sid => :Sid,
        l_btime => sysdate - &&def_ash_time_span / 1440,
        l_etime => sysdate,
        l_slot_width => &&def_ash_time_bucket,
        l_data_src => 0
    ))
;

spool off

set termout on

select 'ASH report completed: ' 
    || '&&def_spool_filename' 
    || chr(10) || '(directory: &&def_spool_directory)'
from dual;

undefine def_spool_directory
undefine def_spool_filename
undefine def_instance_name
undefine def_default_ash_time_span
undefine def_default_ash_time_bucket

column spool_directory clear
column spool_filename  clear
column instance_name   clear
column ash_time_span   clear
column ash_time_bucket clear
]]></sql>
                    <binds>
                        <bind id="Inst_id">
                            <prompt><![CDATA[Inst_id]]></prompt>
                            <tooltip><![CDATA[Inst_id]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Sid">
                            <prompt><![CDATA[Sid]]></prompt>
                            <tooltip><![CDATA[Sid]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                        <bind id="Bind_data">
                            <prompt><![CDATA[Bind_data]]></prompt>
                            <tooltip><![CDATA[Bind_data]]></tooltip>
                            <value><![CDATA[NULL_VALUE]]></value>
                            <bracket><![CDATA[null]]></bracket>
                        </bind>
                    </binds>
                </query>
            </queries>
        </display>
	</display>
</display>
</folder>
</displays>
