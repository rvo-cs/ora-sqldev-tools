<?xml version="1.0" encoding="UTF-8" ?>
<!--
  SPDX-FileCopyrightText: 2020-2023 R.Vassallo
  SPDX-License-Identifier: BSD Zero Clause License
 -->
<displays>
<folder>
<name><![CDATA[Data Dictionary]]></name>
<display id="760631de-0167-1000-8001-c0a83801ccfc" type="" style="Table" enable="true">
	<name><![CDATA[Data Dict - Enhanced table viewer (v2)]]></name>
	<description><![CDATA[Warning: this is a 3-level report; don't edit in SQL Developer!]]></description>
	<tooltip><![CDATA[]]></tooltip>
	<drillclass><![CDATA[]]></drillclass>
	<CustomValues>
		<TYPE><![CDATA[horizontal]]></TYPE>
	</CustomValues>
    <queries>
        <query minversion="23.0">
            <sql><![CDATA[with 
table_like_in as (
    select
        :TABLE_LIKE_LIST  as str,
        '\s* ( ( [^"[:space:]] "? )+ | " ( [^"] )* " ) \s*'  as rex
    from
        dual
),
table_pattrn_raw as (
    select
        regexp_substr(a.str, a.rex, 1, level, 'x')  as tok
    from
        table_like_in a
    connect by
        regexp_instr (a.str, a.rex, 1, level, 0, 'x') > 0
),
table_pattrn_trimmed as (
    select
        regexp_replace(regexp_replace(b.tok, '^\s*'), '\s*$')  as tok
    from
        table_pattrn_raw b
),
table_pattrn_dequoted as (
    select 
        regexp_replace(c.tok, '^" (.*) "$', '\1', 1, 1, 'nx')  as tok
    from
        table_pattrn_trimmed c
),
table_like_list as (
    select /*+ materialize */
        d.tok  as table_like
    from
        table_pattrn_dequoted d
    where
        d.tok is not null
),
matching_tables as (
    select
        listagg(b.table_like, ' | ') within group (order by b.table_like)
            as matching_patterns,
        a.owner, a.table_name
    from
        dba_all_tables a,
        table_like_list b
    where
        (:OWNER_LIKE is null or upper(a.owner) like upper(:OWNER_LIKE) escape '\') 
        and (:OWNER_RE is null or regexp_like(a.owner, :OWNER_RE, 'i'))
        and upper(a.table_name) like upper(b.table_like) escape '\'
    group by
        a.owner, a.table_name
),
matching_table_annotations as (
    select
        aus.annotation_owner  as owner,
        aus.object_name       as table_name,
        json_serialize(json_objectagg(key aus.annotation_name
                                      value aus.annotation_value
                                      null on null)
                       returning varchar2(4000)
                       pretty ordered)  as annotations
    from
        dba_annotations_usage aus,
        matching_tables tab
    where
        aus.annotation_owner = tab.owner
        and aus.object_name = tab.table_name
        and aus.object_type = 'TABLE'
        and aus.column_name is null
    group by
        aus.annotation_owner,
        aus.object_name
)
select /*+ noparallel */
    b.owner,
    b.table_name,
    b.num_rows           as "Num rows",
    b.blocks             as "Blocks",
    b.avg_row_len        as "Avg row len",
    b.iot_type           as "IOT type",
    b.iot_name           as "IOT name",
    b.status             as "Status",
    b.partitioned        as "Partitioned?",
    b.nested             as "Nested?",
    nvl2(b.table_type, 'YES', 'NO') as "Object?",
    b.temporary          as "Temporary?",
    b.duration           as "Duration", 
    b.sample_size        as "Sample size",
    b.last_analyzed      as "Last analyzed",
    c.comments           as "Comments",
    d.annotations        as "Annotations",
    a.matching_patterns  as "Matching patterns"
from
    matching_tables a,
    dba_all_tables b,
    dba_tab_comments c,
    matching_table_annotations d
where
    a.owner = b.owner
    and a.table_name = b.table_name
    and a.owner = c.owner (+)
    and a.table_name = c.table_name (+)
    and a.owner = d.owner (+)
    and a.table_name = d.table_name (+)
order by
    b.owner,
    b.table_name]]></sql>
            <binds>
                <bind id="TABLE_LIKE_LIST">
                    <prompt><![CDATA[Table like?]]></prompt>
                    <tooltip><![CDATA[LIKE pattern (escape '\') for matching tables -- optionally: list of pattens separated by blanks]]></tooltip>
                    <value><![CDATA[FOO%]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="OWNER_LIKE">
                    <prompt><![CDATA[Owner like?]]></prompt>
                    <tooltip><![CDATA[LIKE pattern for matching the name of the table owner]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="OWNER_RE">
                    <prompt><![CDATA[Owner regexp?]]></prompt>
                    <tooltip><![CDATA[Regular expression for matching the name of the table owner]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
        <query>
            <sql><![CDATA[with 
table_like_in as (
    select
        :TABLE_LIKE_LIST  as str,
        '\s* ( ( [^"[:space:]] "? )+ | " ( [^"] )* " ) \s*'  as rex
    from
        dual
),
table_pattrn_raw as (
    select
        regexp_substr(a.str, a.rex, 1, level, 'x')  as tok
    from
        table_like_in a
    connect by
        regexp_instr (a.str, a.rex, 1, level, 0, 'x') > 0
),
table_pattrn_trimmed as (
    select
        regexp_replace(regexp_replace(b.tok, '^\s*'), '\s*$')  as tok
    from
        table_pattrn_raw b
),
table_pattrn_dequoted as (
    select 
        regexp_replace(c.tok, '^" (.*) "$', '\1', 1, 1, 'nx')  as tok
    from
        table_pattrn_trimmed c
),
table_like_list as (
    select /*+ materialize */
        d.tok  as table_like
    from
        table_pattrn_dequoted d
    where
        d.tok is not null
),
matching_tables as (
    select
        listagg(b.table_like, ' | ') within group (order by b.table_like)
            as matching_patterns,
        a.owner, a.table_name
    from
        dba_all_tables a,
        table_like_list b
    where
        (:OWNER_LIKE is null or upper(a.owner) like upper(:OWNER_LIKE) escape '\') 
        and (:OWNER_RE is null or regexp_like(a.owner, :OWNER_RE, 'i'))
        and upper(a.table_name) like upper(b.table_like) escape '\'
    group by
        a.owner, a.table_name
)
select /*+ noparallel */
    b.owner,
    b.table_name,
    b.num_rows           as "Num rows",
    b.blocks             as "Blocks",
    b.avg_row_len        as "Avg row len",
    b.iot_type           as "IOT Type",
    b.iot_name           as "IOT Name",
    b.status             as "Status",
    b.partitioned        as "Partitioned?",
    b.nested             as "Nested?",
    nvl2(b.table_type, 'YES', 'NO') as "Object?",
    b.temporary          as "Temporary?",
    b.duration           as "Duration", 
    b.sample_size        as "Sample size",
    b.last_analyzed      as "Last analyzed",
    c.comments           as "Comments",
    a.matching_patterns  as "Matching patterns"
from
    matching_tables a,
    dba_all_tables b,
    dba_tab_comments c
where
    a.owner = b.owner
    and a.table_name = b.table_name
    and a.owner = c.owner (+)
    and a.table_name = c.table_name (+)
order by
    b.owner,
    b.table_name]]></sql>
            <binds>
                <bind id="TABLE_LIKE_LIST">
                    <prompt><![CDATA[Table like?]]></prompt>
                    <tooltip><![CDATA[LIKE pattern (escape '\') for matching tables -- optionally: list of pattens separated by blanks]]></tooltip>
                    <value><![CDATA[FOO%]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="OWNER_LIKE">
                    <prompt><![CDATA[Owner like?]]></prompt>
                    <tooltip><![CDATA[LIKE pattern for matching the name of the table owner]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="OWNER_RE">
                    <prompt><![CDATA[Owner regexp?]]></prompt>
                    <tooltip><![CDATA[Regular expression for matching the name of the table owner]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
    </queries>
    <item reload="true" reloadparent="false" removeFromParent="false">
        <title>Gather Stats...</title>
        <help><![CDATA[This gathers statistics on the specified table.

BEWARE: this may take a while!]]></help>
        <prompt type="confirm">
            <label>Confirm gather stats on #"OWNER"#.#"TABLE_NAME"# ?</label>
        </prompt>
        <prompt type="text/combo" required="true">  <!-- index: 1 -->
            <label>Scope:</label>
            <default><![CDATA[STATIC:TABLE]]></default>
            <value><![CDATA[select 'TABLE' from dual union all
select 'PARTITION' from dba_part_tables where owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#' union all
select 'SUBPARTITION' from dba_part_tables where owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#' and subpartitioning_type <> 'NONE']]></value>
        </prompt>
        <prompt reload="true:1" type="text/combo" required="false"> <!-- index: 2 -->
            <label>Partition / subpartition:</label>
            <value><![CDATA[select pname from
(select partition_name as pname, partition_position as ppos, null as sppos
from dba_tab_partitions
where table_owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#' and :1 = 'PARTITION'
union all
select a.subpartition_name as pname, b.partition_position as ppos, a.subpartition_position as sppos
from dba_tab_subpartitions a, dba_tab_partitions b
where b.table_owner = q'#"OWNER"#' and b.table_name = q'#"TABLE_NAME"#' and :1 = 'SUBPARTITION'
  and a.table_owner = b.table_owner and a.table_name = b.table_name and a.partition_name = b.partition_name
)
order by ppos, sppos, pname]]></value>
        </prompt>
        <prompt reload="true:1" type="text/combo" required="true">  <!-- index: 3 -->
            <label>Granularity:</label>
            <default><![CDATA[select decode(:1, 'PARTITION', 'PARTITION', 'SUBPARTITION', 'SUBPARTITION', 'AUTO') from dual]]></default>
            <value><![CDATA[select 'AUTO' from dual 
 union all
select regexp_substr(granularity_list, '([^,]+)', 1, level)
  from (select 'ALL,GLOBAL,GLOBAL AND PARTITION,APPROX_GLOBAL AND PARTITION,PARTITION'
               || case when subpartitioning_type <> 'NONE' then ',SUBPARTITION' end  as granularity_list
          from dba_part_tables
         where owner = q'#"OWNER"#'
           and table_name = q'#"TABLE_NAME"#'
       )
 connect by instr(granularity_list, ',', 1, level - 1) > 0]]></value>
        </prompt>
        <prompt type="radio" required="true">   <!-- index: 4 -->
            <label>Degree:</label>
            <default><![CDATA[STATIC:1]]></default>
            <value><![CDATA[STATIC:1:2:4:8:16]]></value>
        </prompt>
        <prompt type="check">                   <!-- index: 5 -->
            <label>Invalidate cursors:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="check">                   <!-- index: 6 -->
            <label>Cascade:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <sql><![CDATA[begin
    dbms_stats.gather_table_stats(
        ownname       => q'#"OWNER"#'
      , tabname       => q'#"TABLE_NAME"#'
      , partname      => q'#"2"#'
      , granularity   => '#3#'
      , degree        => #4#
      , no_invalidate => (nvl('#5#', 'N') = 'N')
      , cascade       => (nvl('#6#', 'N') = 'Y')
    );
end;]]></sql>
        <confirmation>
            <title>Statistics gathered</title>
            <sql><![CDATA[select
    to_char(max(last_analyzed), 'YYYY-MM-DD HH24:MI:SS')  as dte_last_analyzed
  , lower(max(object_type)
        keep (dense_rank first order by
            last_analyzed desc nulls last,
            decode(object_type, 'TABLE', 1, 'PARTITION', 2, 'SUBPARTITION', 3),
            partition_position desc, subpartition_position desc))  as last_object_type
  , max(decode(object_type, 'TABLE', table_name, 'PARTITION', partition_name, 'SUBPARTITION', subpartition_name))
        keep (dense_rank first order by
            last_analyzed desc nulls last,
            decode(object_type, 'TABLE', 1, 'PARTITION', 2, 'SUBPARTITION', 3),
            partition_position desc, subpartition_position desc)  as last_object_name
from dba_tab_statistics
where owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#']]></sql>
            <prompt><![CDATA[Statistics on #"OWNER"#.#"TABLE_NAME"# gathered. Last analyzed: #0.LAST_OBJECT_NAME#
(type: #0.LAST_OBJECT_TYPE#) on #0.DTE_LAST_ANALYZED#]]></prompt>
        </confirmation>
    </item>
    <item reload="true" reloadparent="false" removeFromParent="false">
        <title>Gather Stats in Job...</title>
        <help><![CDATA[This will start a DBMS_SCHEDULER job for gathering statistics on the specified table.]]></help>
        <prompt type="confirm">
            <label>Confirm stats job for #"OWNER"#.#"TABLE_NAME"# ?</label>
        </prompt>
        <prompt type="text/combo" required="true">  <!-- index: 1 -->
            <label>Scope:</label>
            <default><![CDATA[STATIC:TABLE]]></default>
            <value><![CDATA[select 'TABLE' from dual union all
select 'PARTITION' from dba_part_tables where owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#' union all
select 'SUBPARTITION' from dba_part_tables where owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#' and subpartitioning_type <> 'NONE']]></value>
        </prompt>
        <prompt reload="true:1" type="text/combo" required="false"> <!-- index: 2 -->
            <label>Partition / subpartition:</label>
            <value><![CDATA[select pname from
(select partition_name as pname, partition_position as ppos, null as sppos
from dba_tab_partitions
where table_owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#' and :1 = 'PARTITION'
union all
select a.subpartition_name as pname, b.partition_position as ppos, a.subpartition_position as sppos
from dba_tab_subpartitions a, dba_tab_partitions b
where b.table_owner = q'#"OWNER"#' and b.table_name = q'#"TABLE_NAME"#' and :1 = 'SUBPARTITION'
  and a.table_owner = b.table_owner and a.table_name = b.table_name and a.partition_name = b.partition_name
)
order by ppos, sppos, pname]]></value>
        </prompt>
        <prompt reload="true:1" type="text/combo" required="true">  <!-- index: 3 -->
            <label>Granularity:</label>
            <default><![CDATA[select decode(:1, 'PARTITION', 'PARTITION', 'SUBPARTITION', 'SUBPARTITION', 'AUTO') from dual]]></default>
            <value><![CDATA[select 'AUTO' from dual 
 union all
select regexp_substr(granularity_list, '([^,]+)', 1, level)
  from (select 'ALL,GLOBAL,GLOBAL AND PARTITION,APPROX_GLOBAL AND PARTITION,PARTITION'
               || case when subpartitioning_type <> 'NONE' then ',SUBPARTITION' end  as granularity_list
          from dba_part_tables
         where owner = q'#"OWNER"#'
           and table_name = q'#"TABLE_NAME"#'
       )
 connect by instr(granularity_list, ',', 1, level - 1) > 0]]></value>
        </prompt>
        <prompt type="radio" required="true">   <!-- index: 4 -->
            <label>Degree:</label>
            <default><![CDATA[STATIC:1]]></default>
            <value><![CDATA[STATIC:1:2:4:8:16]]></value>
        </prompt>
        <prompt type="check">                   <!-- index: 5 -->
            <label>Invalidate cursors:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="check">                   <!-- index: 6 -->
            <label>Cascade:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="text/combo">              <!-- index: 7 -->
            <label>Job Class:</label>
            <default><![CDATA[STATIC:DEFAULT_JOB_CLASS]]></default>
            <value><![CDATA[select job_class_name from dba_scheduler_job_classes
 where not regexp_like(job_class_name, '^(ORA\$)')
   and job_class_name not in ('SCHED$_LOG_ON_ERRORS_CLASS', 'XMLDB_NFS_JOBCLASS', 'DBMS_JOB$', 'AQ$_PROPAGATION_JOB_CLASS')
 order by job_class_name]]></value>
        </prompt>
        <sql><![CDATA[declare
    l_job_name user_scheduler_jobs.job_name%type :=
            dbms_scheduler.generate_job_name('"sqldev_stats_$"');
begin
    dbms_scheduler.create_job(
        job_name   => '#"OWNER"#."' || l_job_name || '"'
      , job_type   => 'PLSQL_BLOCK'
      , enabled    => false
      , comments   => q'{Statistics gathering job on #"OWNER"#.#"TABLE_NAME"#}'
      , job_class  => q'#"7"#'
      , job_action => q'{begin
            dbms_stats.gather_table_stats(
                ownname       => q'#"OWNER"#'
              , tabname       => q'#"TABLE_NAME"#'
              , partname      => q'#"2"#'
              , granularity   => '#3#'
              , degree        => #4#
              , no_invalidate => (nvl('#5#', 'N') = 'N')
              , cascade       => (nvl('#6#', 'N') = 'Y')
            );
        end;}'
    );
    dbms_scheduler.set_attribute(
        name   => '#"OWNER"#."' || l_job_name || '"'
      , attribute => 'logging_level'
      , value    => dbms_scheduler.logging_full
    );
    dbms_scheduler.enable(
        name   => '#"OWNER"#."' || l_job_name || '"'
    );
end;]]></sql>
        <confirmation>
            <title>Statistics job created</title>
            <sql><![CDATA[with latest_enabled_job as (
    select owner, job_name, log_date
      from (select owner, job_name, log_date
              from dba_scheduler_job_log
             where owner = q'#"OWNER"#'
               and regexp_like(job_name, '^sqldev_stats_\$\d+$')
               and user_name = sys_context('USERENV', 'SESSION_USER')
               and operation = 'ENABLE'
               and log_date >= current_timestamp - numtodsinterval(5, 'SECOND')
             union all
            select null, null, null from dual
             order by log_date desc nulls last
           )
     where rownum = 1
),
latest_job_info as (
    select a.owner
         , a.job_name
         , case
               when c.status is not null
               then c.status || ', date: ' || to_char(c.log_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null and b.last_start_date is not null
               then b.state || ', start date: ' || to_char(b.last_start_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null and b.next_run_date is not null
               then b.state || ', run date: ' || to_char(b.next_run_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null
               then b.state || ', enabled on: ' || to_char(a.log_date, 'YYYY-MM-DD HH24:MI:SS')
               else 'ENABLED, date: ' || to_char(a.log_date, 'YYYY-MM-DD HH24:MI:SS')
           end   as state_info
      from latest_enabled_job a
         , dba_scheduler_jobs b
         , dba_scheduler_job_log c
     where a.owner = b.owner (+)
       and a.job_name = b.job_name (+)
       and a.owner = c.owner (+)
       and a.job_name = c.job_name (+)
       and c.operation (+) = 'RUN'
)
select case
           when job_name is null
           then '*** Job information not found ***'
           else 'Latest job: "' || owner || '"."' || job_name || '", status: ' || state_info
       end  as job_state_info
  from latest_job_info]]></sql>
            <prompt><![CDATA[#0.JOB_STATE_INFO#]]></prompt>
        </confirmation>
    </item>
    <item reload="true" reloadparent="false" removeFromParent="false">
        <title>Rebuild Indexes...</title>
        <help><![CDATA[This rebuilds one or more indexes of the specified table, using DBMS_INDEX_UTL.

BEWARE: this may take a while!]]></help>
        <prompt type="confirm">
            <label>Confirm index rebuild for table #"OWNER"#.#"TABLE_NAME"# ?</label>
        </prompt>
        <prompt type="text/combo" required="false"> <!-- index: 1 -->
            <label>Only this index:</label>
            <value><![CDATA[select '"' || owner || '"."' || index_name || '"' from dba_indexes
where table_owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#'
order by owner, index_name]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 2 -->
            <label>Just unusable:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="radio" required="true">       <!-- index: 3 -->
            <label>Locality:</label>
            <default><![CDATA[STATIC:ALL]]></default>
            <value><![CDATA[STATIC:ALL:GLOBAL:LOCAL]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 4 -->
            <label>Concurrent:</label>
            <default><![CDATA[STATIC:N]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 5 -->
            <label>Continue after error:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="text/combo" required="true">  <!-- index: 6 -->
            <label>Max slaves:</label>
            <default><![CDATA[STATIC:1]]></default>
            <value><![CDATA[STATIC:1:2:4:8:16:32]]></value>
        </prompt>
        <prompt type="text/combo" required="true">  <!-- index: 7 -->
            <label>Forced degree:</label>
            <default><![CDATA[STATIC:null]]></default>
            <value><![CDATA[STATIC:null:1:2:4:8:16]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 8 -->
            <label>Retry online:</label>
            <default><![CDATA[STATIC:N]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="codearea" required="false">   <!-- index: 9 -->
            <label>List of indexes:</label>
            <default><![CDATA[select listagg('"' || owner || '"."' || index_name || '"', ', ')
            within group (order by index_name)
  from dba_indexes
 where table_owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#']]></default>
        </prompt>
        <sql><![CDATA[declare
    l_cnt_error pls_integer;
begin
    dbms_index_utl.build_indexes (
        list           => nvl( q'{#1#}'
                             , q'{#9#}' )
      , just_unusable  => (nvl('#2#', 'N') = 'Y')
      , locality       => '#3#'
      , concurrent     => (nvl('#4#', 'N') = 'Y')
      , cont_after_err => (nvl('#5#', 'N') = 'Y')
      , max_slaves     => #6#
      , forced_degree  => #7#
      , retry_online   => (nvl('#8#', 'N') = 'Y')
      , num_errors     => l_cnt_error
    );
    if l_cnt_error > 0 then
        raise_application_error(-20000, 'Completed with ' || to_char(l_cnt_error)
                || ' error' || case when l_cnt_error > 1 then 's' end
                || '--see alert.log for details.');
    end if;
end;]]></sql>
    </item>
    <item reload="true" reloadparent="false" removeFromParent="false">
        <title>Rebuild Indexes in Job...</title>
        <help><![CDATA[This will start a DBMS_SCHEDULER job for rebuilding 1 or more indexes of the specified table.]]></help>
        <prompt type="confirm">
            <label>Confirm index rebuild job for #"OWNER"#.#"TABLE_NAME"# ?</label>
        </prompt>
        <prompt type="text/combo" required="false"> <!-- index: 1 -->
            <label>Only this index:</label>
            <value><![CDATA[select '"' || owner || '"."' || index_name || '"' from dba_indexes
where table_owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#'
order by owner, index_name]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 2 -->
            <label>Just unusable:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="radio" required="true">       <!-- index: 3 -->
            <label>Locality:</label>
            <default><![CDATA[STATIC:ALL]]></default>
            <value><![CDATA[STATIC:ALL:GLOBAL:LOCAL]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 4 -->
            <label>Concurrent:</label>
            <default><![CDATA[STATIC:N]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 5 -->
            <label>Continue after error:</label>
            <default><![CDATA[STATIC:Y]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="text/combo" required="true">  <!-- index: 6 -->
            <label>Max slaves:</label>
            <default><![CDATA[STATIC:1]]></default>
            <value><![CDATA[STATIC:1:2:4:8:16:32]]></value>
        </prompt>
        <prompt type="text/combo" required="true">  <!-- index: 7 -->
            <label>Forced degree:</label>
            <default><![CDATA[STATIC:null]]></default>
            <value><![CDATA[STATIC:null:1:2:4:8:16]]></value>
        </prompt>
        <prompt type="check" required="true">       <!-- index: 8 -->
            <label>Retry online:</label>
            <default><![CDATA[STATIC:N]]></default>
            <value><![CDATA[STATIC:Y]]></value>
        </prompt>
        <prompt type="codearea" required="false">   <!-- index: 9 -->
            <label>List of indexes:</label>
            <default><![CDATA[select listagg('"' || owner || '"."' || index_name || '"', ', ')
            within group (order by index_name)
  from dba_indexes
 where table_owner = q'#"OWNER"#' and table_name = q'#"TABLE_NAME"#']]></default>
        </prompt>
        <prompt type="text/combo">                  <!-- index: 10 -->
            <label>Job Class:</label>
            <default><![CDATA[STATIC:DEFAULT_JOB_CLASS]]></default>
            <value><![CDATA[select job_class_name from dba_scheduler_job_classes
 where not regexp_like(job_class_name, '^(ORA\$)')
   and job_class_name not in ('SCHED$_LOG_ON_ERRORS_CLASS', 'XMLDB_NFS_JOBCLASS', 'DBMS_JOB$', 'AQ$_PROPAGATION_JOB_CLASS')
 order by job_class_name]]></value>
        </prompt>
        <sql><![CDATA[declare
    l_job_name user_scheduler_jobs.job_name%type :=
            dbms_scheduler.generate_job_name('"sqldev_idx_build_$"');
begin
    dbms_scheduler.create_job(
        job_name   => '#"OWNER"#."' || l_job_name || '"'
      , job_type   => 'PLSQL_BLOCK'
      , enabled    => false
      , comments   => 'Rebuild job for indexes of #"OWNER"#.#"TABLE_NAME"#'
      , job_class  => q'#"10"#'
      , job_action => q'{declare
                l_cnt_error pls_integer;
            begin
                dbms_index_utl.build_indexes (
                    list           => nvl( q'[#1#]'
                                         , q'[#9#]' )
                  , just_unusable  => (nvl('#2#', 'N') = 'Y')
                  , locality       => '#3#'
                  , concurrent     => (nvl('#4#', 'N') = 'Y')
                  , cont_after_err => (nvl('#5#', 'N') = 'Y')
                  , max_slaves     => #6#
                  , forced_degree  => #7#
                  , retry_online   => (nvl('#8#', 'N') = 'Y')
                  , num_errors     => l_cnt_error
                );
                if l_cnt_error > 0 then
                    raise_application_error(-20000, 'Completed with ' || to_char(l_cnt_error)
                            || ' error' || case when l_cnt_error > 1 then 's' end
                            || '--see alert.log for details.');
                end if;
            end;}'
    );
    dbms_scheduler.set_attribute(
        name   => '#"OWNER"#."' || l_job_name || '"'
      , attribute => 'logging_level'
      , value    => dbms_scheduler.logging_full
    );
    dbms_scheduler.enable(
        name   => '#"OWNER"#."' || l_job_name || '"'
    );
end;]]></sql>
        <confirmation>
            <title>Index rebuild job created</title>
            <sql><![CDATA[with latest_enabled_job as (
    select owner, job_name, log_date
      from (select owner, job_name, log_date
              from dba_scheduler_job_log
             where owner = q'#"OWNER"#'
               and regexp_like(job_name, '^sqldev_idx_build_\$\d+$')
               and user_name = sys_context('USERENV', 'SESSION_USER')
               and operation = 'ENABLE'
               and log_date >= current_timestamp - numtodsinterval(5, 'SECOND')
             union all
            select null, null, null from dual
             order by log_date desc nulls last
           )
     where rownum = 1
),
latest_job_info as (
    select a.owner
         , a.job_name
         , case
               when c.status is not null
               then c.status || ', date: ' || to_char(c.log_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null and b.last_start_date is not null
               then b.state || ', start date: ' || to_char(b.last_start_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null and b.next_run_date is not null
               then b.state || ', run date: ' || to_char(b.next_run_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null
               then b.state || ', enabled on: ' || to_char(a.log_date, 'YYYY-MM-DD HH24:MI:SS')
               else 'ENABLED, date: ' || to_char(a.log_date, 'YYYY-MM-DD HH24:MI:SS')
           end   as state_info
      from latest_enabled_job a
         , dba_scheduler_jobs b
         , dba_scheduler_job_log c
     where a.owner = b.owner (+)
       and a.job_name = b.job_name (+)
       and a.owner = c.owner (+)
       and a.job_name = c.job_name (+)
       and c.operation (+) = 'RUN'
)
select case
           when job_name is null
           then '*** Job information not found ***'
           else 'Latest job: "' || owner || '"."' || job_name || '", status: ' || state_info
       end  as job_state_info
  from latest_job_info]]></sql>
            <prompt><![CDATA[#0.JOB_STATE_INFO#]]></prompt>
        </confirmation>
    </item>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Details]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[vertical]]></TYPE>
		</CustomValues>
        <queries>
            <query minversion="12.2">
                <sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.partitioned,
    a.row_movement,
    a.tablespace_name,
    a.iot_name,
    a.iot_type,
    a.table_type_owner,
    a.table_type,
    a.nested,
    a.temporary,
    a.duration,
    a.cluster_name,
    a.cluster_owner,
    a.status,
    a.dropped,
    d.read_only,
    a.backed_up,
    a.degree,
    d.default_collation,
    a.buffer_pool,
    a.cache,
    a.flash_cache,
    d.result_cache,
    a.cell_flash_cache,
    a.pct_free,
    a.pct_increase,
    a.pct_used,
    a.ini_trans,
    a.initial_extent,
    a.next_extent,
    a.min_extents,
    a.max_extents,
    a.freelists,
    a.freelist_groups,
    a.instances,
    a.logging,
    a.monitoring,
    a.compression,
    a.compress_for,
    a.dependencies,
    a.segment_created,
    a.skip_corrupt,
    a.table_lock,
    c.created,
    c.last_ddl_time,
    b.comments
from
    dba_all_tables a,
    dba_tab_comments b,
    dba_objects c,
    dba_tables d
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner (+)
    and a.table_name = b.table_name (+)
    and a.owner = c.owner (+)
    and a.table_name = c.object_name (+)
    and c.object_type (+) = 'TABLE'
    and a.owner = d.owner (+)
    and a.table_name = d.table_name (+)]]></sql>
                <binds>
                    <bind id="OWNER">
                        <prompt><![CDATA[OWNER]]></prompt>
                        <tooltip><![CDATA[OWNER]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="TABLE_NAME">
                        <prompt><![CDATA[TABLE_NAME]]></prompt>
                        <tooltip><![CDATA[TABLE_NAME]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
            <query>
                <sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.partitioned,
    a.row_movement,
    a.tablespace_name,
    a.iot_name,
    a.iot_type,
    a.table_type_owner,
    a.table_type,
    a.nested,
    a.temporary,
    a.duration,
    a.cluster_name,
    a.cluster_owner,
    a.status,
    a.dropped,
    d.read_only,
    a.backed_up,
    a.degree,
    a.buffer_pool,
    a.cache,
    a.flash_cache,
    d.result_cache,
    a.cell_flash_cache,
    a.pct_free,
    a.pct_increase,
    a.pct_used,
    a.ini_trans,
    a.initial_extent,
    a.next_extent,
    a.min_extents,
    a.max_extents,
    a.freelists,
    a.freelist_groups,
    a.instances,
    a.logging,
    a.monitoring,
    a.compression,
    a.compress_for,
    a.dependencies,
    a.segment_created,
    a.skip_corrupt,
    a.table_lock,
    c.created,
    c.last_ddl_time,
    b.comments
from
    dba_all_tables a,
    dba_tab_comments b,
    dba_objects c,
    dba_tables d
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner (+)
    and a.table_name = b.table_name (+)
    and a.owner = c.owner (+)
    and a.table_name = c.object_name (+)
    and c.object_type (+) = 'TABLE'
    and a.owner = d.owner (+)
    and a.table_name = d.table_name (+)]]></sql>
                <binds>
                    <bind id="OWNER">
                        <prompt><![CDATA[OWNER]]></prompt>
                        <tooltip><![CDATA[OWNER]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="TABLE_NAME">
                        <prompt><![CDATA[TABLE_NAME]]></prompt>
                        <tooltip><![CDATA[TABLE_NAME]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
        </queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Statistics]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[vertical]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    b.stattype_locked,
    a.num_rows,
    a.blocks,
    a.avg_row_len,
    a.partitioned,
    a.avg_space,
    a.avg_space_freelist_blocks,
    a.num_freelist_blocks,
    a.empty_blocks,
    b.avg_cached_blocks,
    b.avg_cache_hit_ratio,
    a.chain_cnt,
    a.sample_size,
    a.last_analyzed,
    a.global_stats,
    a.user_stats,
    b.stale_stats,
    c.inserts,
    c.updates,
    c.deletes,
    c.truncated,
    c.drop_segments,
    c.timestamp
from
    dba_all_tables a,
    dba_tab_statistics b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner (+)
    and a.table_name = b.table_name (+)
    and b.partition_name (+) is null
    and b.subpartition_name (+) is null
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and c.partition_name (+) is null
    and c.subpartition_name (+) is null]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Stats prefs]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[with
all_stat_pref ( name
              , min_version
              , is_table_pref
              , is_global_pref
              ) 
as (
    select /*+ no_merge */ 'APPROXIMATE_NDV_ALGORITHM'      , '12.02'  , 'Y'    , 'Y'   from dual
    union all       select 'AUTO_STAT_EXTENSIONS'           , '12.02'  , 'Y'    , 'Y'   from dual
    --union all       select 'AUTO_TASK_STATUS'               , '19.00'  , null   , 'Y'   from dual   /* high-freq. auto stats collection (EE-ES only!) */
    --union all       select 'AUTO_TASK_MAX_RUN_TIME'         , '19.00'  , null   , 'Y'   from dual   /* high-freq. auto stats collection (EE-ES only!) */
    --union all       select 'AUTO_TASK_INTERVAL'             , '19.00'  , null   , 'Y'   from dual   /* high-freq. auto stats collection (EE-ES only!) */
    union all       select 'AUTOSTATS_TARGET'               , '11.02'  , null   , 'Y'   from dual
    union all       select 'CASCADE'                        , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'CONCURRENT'                     , '11.02'  , null   , 'Y'   from dual
    --union all       select 'COORDINATOR_TRIGGER_SHARD'      , '19.00'  , 'Y'    , 'Y'   from dual   /* If using sharding only */
    union all       select 'DEGREE'                         , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'ESTIMATE_PERCENT'               , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'GLOBAL_TEMP_TABLE_STATS'        , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'GRANULARITY'                    , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'INCREMENTAL'                    , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'INCREMENTAL_LEVEL'              , '12.01'  , 'Y'    , null  from dual
    union all       select 'INCREMENTAL_STALENESS'          , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'METHOD_OPT'                     , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'OPTIONS'                        , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'NO_INVALIDATE'                  , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'PREFERENCE_OVERRIDES_PARAMETER' , '12.02'  , 'Y'    , 'Y'   from dual
    union all       select 'PUBLISH'                        , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'ROOT_TRIGGER_PDB'               , '19.00'  , 'Y'    , 'Y'   from dual   /* if using App. PDB only */
    union all       select 'STALE_PERCENT'                  , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'STAT_CATEGORY'                  , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'TABLE_CACHED_BLOCKS'            , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'WAIT_TIME_TO_UPDATE_STATS'      , '12.02'  , 'Y'    , 'Y'   from dual
),
v_instance_version (mm_nn_version) as (
    select /*+ no_merge */
        lpad(regexp_substr(version, '([^\.]+)', 1, 1), 2, '0') 
            || '.' || lpad(regexp_substr(version, '([^\.]+)', 1, 2), 2, '0')
    from
        v$instance
),
global_stat_pref (pref_name) as (
    select
        a.name
    from
        all_stat_pref a,
        v_instance_version b
    where
        a.is_global_pref = 'Y'
        and a.min_version <= b.mm_nn_version
),
table_stat_pref (pref_name) as (
    select
        a.name
    from
        all_stat_pref a,
        v_instance_version b
    where
        a.is_table_pref = 'Y'
        and a.min_version <= b.mm_nn_version
)
select /*+ noparallel */
    null as owner,
    null as table_name,
    a.pref_name as preference_name,
    dbms_stats.get_prefs(a.pref_name) as preference_value
from
    global_stat_pref a
union all
select /*+ noparallel */
    :OWNER as owner,
    :TABLE_NAME as table_name,
    a.pref_name as preference_name,
    c.preference_value
from
    table_stat_pref a,
    dba_tab_stat_prefs c
where
    :OWNER = c.owner (+)
    and :TABLE_NAME = c.table_name (+)
    and a.pref_name = c.preference_name (+)
order by
    owner nulls first, 
    table_name nulls first, 
    preference_name]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Partitioning]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[vertical]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.partitioning_type,
    a.interval,
    a.subpartitioning_type,
    a.partition_count,
    (
        select count(*) from dba_tab_subpartitions b
        where b.table_owner = a.owner and b.table_name = a.table_name
    ) 
    as subpartition_count,
    a.partitioning_key_count,
    (
        select
            listagg(b.column_name || case when c.virtual_column = 'YES' then ' (*)' end, ', ')
                    within group (order by b.column_position) as list_cols
        from
            dba_part_key_columns b,
            dba_tab_cols c
        where
            b.owner = c.owner
            and b.name = c.table_name
            and b.column_name = c.column_name
            and b.object_type = 'TABLE'
            and b.owner = a.owner
            and b.name = a.table_name
    ) 
    as partition_keys,
    a.subpartitioning_key_count,
    (
        select
            listagg(b.column_name || case when c.virtual_column = 'YES' then ' (*)' end, ', ')
                    within group (order by b.column_position) as list_cols
        from
            dba_subpart_key_columns b,
            dba_tab_cols c
        where
            b.owner = c.owner
            and b.name = c.table_name
            and b.column_name = c.column_name
            and b.object_type = 'TABLE'
            and b.owner = a.owner
            and b.name = a.table_name
    ) 
    as subpartition_keys,
    a.status,
    a.is_nested,
    a.def_subpartition_count,
    a.def_tablespace_name,
    a.def_logging,
    a.def_compression,
    a.def_compress_for,
    a.def_segment_creation,
    a.def_pct_free,
    a.def_pct_used,
    a.def_ini_trans,
    a.def_max_trans,
    a.def_initial_extent,
    a.def_next_extent,
    a.def_min_extents,
    a.def_max_extents,
    a.def_max_size,
    a.def_pct_increase,
    a.def_freelists,
    a.def_freelist_groups,
    a.def_buffer_pool,
    a.def_flash_cache,
    a.def_cell_flash_cache,
    a.ref_ptn_constraint_name
from
    dba_part_tables a
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME]]></sql>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Segments]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[with
related_tables (owner, table_name) as (
    select
        ata.owner,
        ata.table_name
    from
        dba_all_tables ata
    where
        ata.owner = :OWNER
        and ata.table_name = :TABLE_NAME
    union all
    select
        chld.owner,
        chld.table_name
    from
        (select
            nt.owner,
            nt.table_name,
            nt.parent_table_name
        from
            dba_nested_tables nt
        union
        select
            iot.owner,
            iot.table_name,
            iot.iot_name as parent_table_name
        from
            dba_all_tables iot
        where
            iot.iot_type = 'IOT_OVERFLOW'
        ) chld,
        related_tables par
    where
        chld.owner = par.owner
        and chld.parent_table_name = par.table_name
)
select /*+ noparallel */
    nvl(b.tablespace_name, '-- Grand total --') as tablespace_name,
    nvl(b.segment_type, nvl2(b.tablespace_name, '-- Total for TBS --', null)) as segment_type, 
    b.segment_subtype,
    b.owner, b.segment_name,
    count(*) as cnt_seg,
    round(sum(b.bytes) / power(2, 20), 1) as total_size_mb,
    sum(b.blocks) as total_blocks,
    b.lob_column_name
from
    (select
        seg.tablespace_name,
        seg.segment_type, seg.segment_subtype,
        seg.owner, seg.segment_name, null as lob_column_name,
        seg.bytes, seg.blocks
    from
        dba_segments seg,
        related_tables tbl
    where
        seg.owner = tbl.owner
        and seg.segment_name = tbl.table_name
        and seg.segment_type in ('TABLE', 'NESTED TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
    union all
    select
        seg.tablespace_name,
        seg.segment_type, seg.segment_subtype,
        seg.owner, seg.segment_name, null as lob_column_name,
        seg.bytes, seg.blocks
    from
        dba_segments seg,
        dba_tables tbl
    where
        tbl.owner = :OWNER
        and tbl.table_name = :TABLE_NAME
        and seg.owner = tbl.owner
        and seg.segment_name = tbl.cluster_name
        and seg.segment_type = 'CLUSTER'
    union all
    select
        seg.tablespace_name,
        seg.segment_type, seg.segment_subtype,
        seg.owner, seg.segment_name, null as lob_column_name,
        seg.bytes, seg.blocks
    from
        dba_segments seg,
        dba_indexes ind,
        related_tables tbl
    where
        ind.table_owner = tbl.owner
        and ind.table_name = tbl.table_name
        and ind.index_type <> 'LOB'
        and seg.owner = ind.owner
        and seg.segment_name = ind.index_name
        and seg.segment_type in ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
    union all
    select
        seg.tablespace_name,
        seg.segment_type, seg.segment_subtype,
        seg.owner, seg.segment_name, lob.column_name as lob_column_name,
        seg.bytes, seg.blocks
    from
        dba_segments seg,
        dba_lobs lob,
        related_tables tbl
    where
        lob.owner = tbl.owner
        and lob.table_name = tbl.table_name
        and seg.owner = lob.owner
        and seg.segment_name = lob.segment_name
    union all
    select
        seg.tablespace_name,
        seg.segment_type, seg.segment_subtype,
        seg.owner, seg.segment_name, lob.column_name as lob_column_name,
        seg.bytes, seg.blocks
    from
        dba_segments seg,
        dba_lobs lob,
        related_tables tbl
    where
        lob.owner = tbl.owner
        and lob.table_name = tbl.owner
        and seg.owner = lob.owner
        and seg.segment_name = lob.index_name
    ) b
group by 
    grouping sets (
        (tablespace_name,
        segment_type, segment_subtype,
        owner, segment_name, lob_column_name),
        (tablespace_name), 
        ()
)
order by
    nvl2(b.tablespace_name, 0, 1), nvl2(b.segment_type, 0, 1),
    b.tablespace_name,
    case when b.segment_type like 'CLUS%' then 0 
        when b.segment_type like 'TABLE%' then 1
        when b.segment_type = 'NESTED TABLE' then 2
        when b.segment_type like 'INDEX%' and b.segment_name not like 'SYS_IL%' then 3
        when b.segment_type like 'INDEX%' and b.segment_name like 'SYS_IL%' then 5
        when b.segment_type like 'LOB%' then 4 end,
    b.segment_type, b.segment_subtype, 
    b.owner, b.segment_name, b.lob_column_name]]></sql>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Columns]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="23.0">
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    a.data_default,
    a.domain_owner,
    a.domain_name,
    decode(a.default_on_null, 'NO', 'N', 'YES', 'Y') as default_on_null,
    decode(a.default_on_null_upd, 'NO', 'N', 'YES', 'Y') as default_on_null_upd,
    a.data_type_mod,
    a.data_type_owner,
    decode(a.identity_column, 'NO', 'N', 'YES', 'Y')  as identity_column,
    decode(a.hidden_column, 'NO', 'N', 'YES', 'Y')    as hidden_column,
    decode(a.virtual_column, 'NO', 'N', 'YES', 'Y')   as virtual_column,
    a.collated_column_id,
    decode(a.sensitive_column, 'NO', 'N', 'YES', 'Y') as sensitive_column,
    a.segment_column_id,
    a.internal_column_id,
    a.qualified_col_name,
    a.collation,
    b.comments,
    h.cnt_indexes,
    h.index_list,
    cau.annotations
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h,
    (select
        aus.annotation_owner as table_owner,
        aus.object_name      as table_name,
        aus.column_name, 
        json_serialize(json_objectagg(key aus.annotation_name 
                                      value aus.annotation_value 
                                      null on null) 
                       returning varchar2(4000)
                       pretty ordered)  as annotations
    from
        dba_annotations_usage aus
    where
        aus.annotation_owner = :OWNER
        and aus.object_name = :TABLE_NAME
        and aus.object_type = 'TABLE'
        and aus.column_name is not null
    group by
        aus.annotation_owner,
        aus.object_name,
        aus.column_name
    ) cau
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
    and  a.owner = cau.table_owner (+)
    and  a.table_name = cau.table_name (+)
    and  a.column_name = cau.column_name (+)
order by
    a.internal_column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query minversion="12.2">
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    a.data_default,
    decode(a.default_on_null, 'NO', 'N', 'YES', 'Y') as default_on_null,
    a.data_type_mod,
    a.data_type_owner,
    decode(a.identity_column, 'NO', 'N', 'YES', 'Y')  as identity_column,
    decode(a.hidden_column, 'NO', 'N', 'YES', 'Y')    as hidden_column,
    decode(a.virtual_column, 'NO', 'N', 'YES', 'Y')   as virtual_column,
    a.collated_column_id,
    decode(a.sensitive_column, 'NO', 'N', 'YES', 'Y') as sensitive_column,
    a.segment_column_id,
    a.internal_column_id,
    a.qualified_col_name,
    a.collation,
    b.comments,
    h.cnt_indexes,
    h.index_list
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
order by
    a.internal_column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    a.data_default,
    decode(a.default_on_null, 'NO', 'N', 'YES', 'Y') as default_on_null,
    a.data_type_mod,
    a.data_type_owner,
    decode(a.identity_column, 'NO', 'N', 'YES', 'Y')  as identity_column,
    decode(a.hidden_column, 'NO', 'N', 'YES', 'Y')    as hidden_column,
    decode(a.virtual_column, 'NO', 'N', 'YES', 'Y')   as virtual_column,
    decode(a.sensitive_column, 'NO', 'N', 'YES', 'Y') as sensitive_column,
    a.segment_column_id,
    a.internal_column_id,
    a.qualified_col_name,
    b.comments,
    h.cnt_indexes,
    h.index_list
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
order by
    a.internal_column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
        <query>
			<sql><![CDATA[select
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    a.data_default,
    a.data_type_mod,
    a.data_type_owner,
    decode(a.hidden_column, 'NO', 'N', 'YES', 'Y') as hidden_column,
    decode(a.virtual_column, 'NO', 'N', 'YES', 'Y') as virtual_column,
    a.segment_column_id,
    a.internal_column_id,
    a.qualified_col_name,
    b.comments,
    h.cnt_indexes,
    h.index_list
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
order by
    a.column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		</queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Constraints]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
            <query minversion="23.0">
                <sql><![CDATA[select /*+ noparallel */
    a.constraint_name,
    a.constraint_type,
    a.domain_owner,
    a.domain_name,
    a.domain_constraint_name  as domain_constraint,
    a.search_condition,
    a.r_owner,
    a.r_constraint_name,
    a.delete_rule,
    a.status,
    a.deferrable,
    a.deferred,
    a.validated,
    a.generated,
    a.bad,
    a.rely,
    a.last_change,
    a.index_owner,
    a.index_name,
    (select listagg(b.column_name, ', ') within group (order by b.position)
    from dba_cons_columns b 
    where 
        b.owner = a.owner 
        and b.constraint_name = a.constraint_name 
        and b.table_name = a.table_name
    ) as column_list
from 
    dba_constraints a
where 
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
order by
    decode(a.constraint_type, 'P', 1, 'U', 2, 'R', 3, 'C', 4, 99),
    a.constraint_name]]></sql>
                <binds>
                    <bind id="OWNER">
                        <prompt><![CDATA[OWNER]]></prompt>
                        <tooltip><![CDATA[OWNER]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="TABLE_NAME">
                        <prompt><![CDATA[TABLE_NAME]]></prompt>
                        <tooltip><![CDATA[TABLE_NAME]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
            <query>
                <sql><![CDATA[select /*+ noparallel */
    a.constraint_name,
    a.constraint_type,
    a.search_condition,
    a.r_owner,
    a.r_constraint_name,
    a.delete_rule,
    a.status,
    a.deferrable,
    a.deferred,
    a.validated,
    a.generated,
    a.bad,
    a.rely,
    a.last_change,
    a.index_owner,
    a.index_name,
    (select listagg(b.column_name, ', ') within group (order by b.position)
    from dba_cons_columns b 
    where 
        b.owner = a.owner 
        and b.constraint_name = a.constraint_name 
        and b.table_name = a.table_name
    ) as column_list
from 
    dba_constraints a
where 
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
order by
    decode(a.constraint_type, 'P', 1, 'U', 2, 'R', 3, 'C', 4, 99),
    a.constraint_name]]></sql>
                <binds>
                    <bind id="OWNER">
                        <prompt><![CDATA[OWNER]]></prompt>
                        <tooltip><![CDATA[OWNER]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="TABLE_NAME">
                        <prompt><![CDATA[TABLE_NAME]]></prompt>
                        <tooltip><![CDATA[TABLE_NAME]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
        </queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Indexes]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="23.0">
			<sql><![CDATA[select /*+ noparallel */
    a.owner, 
    a.index_name, 
    a.index_type, 
    a.visibility,
    a.degree,
    a.uniqueness, 
    a.compression, 
    a.prefix_length, 
    a.partitioned,
    d.locality,
    a.indexing,
    a.orphaned_entries,
    a.tablespace_name, 
    a.logging, 
    a.status, 
    a.num_rows, 
    a.blevel, 
    a.leaf_blocks, 
    a.distinct_keys, 
    a.avg_leaf_blocks_per_key, 
    a.avg_data_blocks_per_key, 
    a.clustering_factor,
    case when b.blocks > 0 then round(a.clustering_factor / b.blocks, 2) end as scaled_clustr_factor,
    a.sample_size,
    a.last_analyzed, 
    a.temporary, 
    a.generated, 
    a.global_stats, 
    a.funcidx_status, 
    a.join_index, 
    a.pct_threshold, 
    a.include_column, 
    a.pct_direct_access, 
    a.iot_redundant_pkey_elim, 
    a.dropped, 
    (select
        listagg(e.column_name 
                    || case when e.descend = 'DESC' then ' desc' end, ', ')
            within group (order by e.column_position)
    from
        dba_ind_columns e
    where
        e.index_owner = a.owner
        and e.index_name = a.index_name
    ) as ind_columns,
    c.column_name as lob_col_name,
    iau.annotations
from 
    dba_indexes a,
    dba_all_tables b,
    dba_lobs c,
    dba_part_indexes d,
    (select
        aus.annotation_owner as index_owner,
        aus.object_name      as index_name,
        json_serialize(json_objectagg(key aus.annotation_name 
                                      value aus.annotation_value 
                                      null on null) 
                       returning varchar2(4000)
                       pretty ordered)  as annotations
    from
        dba_indexes ind,
        dba_annotations_usage aus
    where
        ind.table_owner = :OWNER
        and ind.table_name = :TABLE_NAME
        and aus.annotation_owner = ind.owner
        and aus.object_name = ind.index_name
        and aus.object_type = 'INDEX'
        and aus.column_name is null
    group by
        aus.annotation_owner,
        aus.object_name
    ) iau
where
    a.table_owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.table_owner = b.owner
    and a.table_name = b.table_name
    and a.table_owner = c.owner (+)
    and a.table_name = c.table_name (+)
    and a.index_name = c.index_name (+)
    and a.owner = d.owner (+)
    and a.index_name = d.index_name (+)
    and a.owner = iau.index_owner (+)
    and a.index_name = iau.index_name (+)
order by
    decode(index_type, 'CLUSTER', 1, 'IOT - TOP', 2, 'DOMAIN', 3, 'LOB', 100, 10),
    index_name
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner, 
    a.index_name, 
    a.index_type, 
    a.visibility,
    a.degree,
    a.uniqueness, 
    a.compression, 
    a.prefix_length, 
    a.partitioned,
    d.locality,
    a.indexing,
    a.orphaned_entries, 
    a.tablespace_name, 
    a.logging, 
    a.status, 
    a.num_rows, 
    a.blevel, 
    a.leaf_blocks, 
    a.distinct_keys, 
    a.avg_leaf_blocks_per_key, 
    a.avg_data_blocks_per_key, 
    a.clustering_factor,
    case when b.blocks > 0 then round(a.clustering_factor / b.blocks, 2) end as scaled_clustr_factor,
    a.sample_size,
    a.last_analyzed, 
    a.temporary, 
    a.generated, 
    a.global_stats, 
    a.funcidx_status, 
    a.join_index, 
    a.pct_threshold, 
    a.include_column, 
    a.pct_direct_access, 
    a.iot_redundant_pkey_elim, 
    a.dropped, 
    (select
        listagg(e.column_name 
                    || case when e.descend = 'DESC' then ' desc' end, ', ')
            within group (order by e.column_position)
    from
        dba_ind_columns e
    where
        e.index_owner = a.owner
        and e.index_name = a.index_name
    ) as ind_columns,
    c.column_name as lob_col_name
from 
    dba_indexes a,
    dba_all_tables b,
    dba_lobs c,
    dba_part_indexes d
where
    a.table_owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.table_owner = b.owner
    and a.table_name = b.table_name
    and a.table_owner = c.owner (+)
    and a.table_name = c.table_name (+)
    and a.index_name = c.index_name (+)
    and a.owner = d.owner (+)
    and a.index_name = d.index_name (+)
order by
    decode(index_type, 'CLUSTER', 1, 'IOT - TOP', 2, 'DOMAIN', 3, 'LOB', 100, 10),
    index_name
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query>
			<sql><![CDATA[select
    a.owner, 
    a.index_name, 
    a.index_type, 
    a.visibility,
    a.degree,
    a.uniqueness, 
    a.compression, 
    a.prefix_length, 
    a.partitioned,
    d.locality,
    a.tablespace_name, 
    a.logging, 
    a.status, 
    a.num_rows, 
    a.blevel, 
    a.leaf_blocks, 
    a.distinct_keys, 
    a.avg_leaf_blocks_per_key, 
    a.avg_data_blocks_per_key, 
    a.clustering_factor,
    case when b.blocks > 0 then round(a.clustering_factor / b.blocks, 2) end as scaled_clustr_factor,
    a.sample_size,
    a.last_analyzed, 
    a.temporary, 
    a.generated, 
    a.global_stats, 
    a.funcidx_status, 
    a.join_index, 
    a.pct_threshold, 
    a.include_column, 
    a.pct_direct_access, 
    a.iot_redundant_pkey_elim, 
    a.dropped, 
    (select
        listagg(e.column_name 
                    || case when e.descend = 'DESC' then ' desc' end, ', ')
            within group (order by e.column_position)
    from
        dba_ind_columns e
    where
        e.index_owner = a.owner
        and e.index_name = a.index_name
    ) as ind_columns,
    c.column_name as lob_col_name
from 
    dba_indexes a,
    dba_all_tables b,
    dba_lobs c,
    dba_part_indexes d
where
    a.table_owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.table_owner = b.owner
    and a.table_name = b.table_name
    and a.table_owner = c.owner (+)
    and a.table_name = c.table_name (+)
    and a.index_name = c.index_name (+)
    and a.owner = d.owner (+)
    and a.index_name = d.index_name (+)
order by
    decode(index_type, 'CLUSTER', 1, 'IOT - TOP', 2, 'DOMAIN', 3, 'LOB', 100, 10),
    index_name
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
        <item reload="true" reloadparent="false" removeFromParent="false">
            <title>Gather Index Stats...</title>
            <help><![CDATA[This gathers statistics on the specified index.

BEWARE: this may take a while!]]></help>
            <prompt type="confirm">
                <label>Confirm gather index stats?</label>
            </prompt>
            <prompt type="text/combo" required="true">  <!-- index: 1 -->
                <label>Index:</label>
                <default><![CDATA[select qualified_index_name
  from ( select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"INDEX_NAME"#' <> '#'||'"INDEX_NAME"'||'#'
            and owner = q'#"OWNER"#'    -- index_owner
            and index_name = q'#"INDEX_NAME"#'
          union all
         select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"TABLE_NAME"#' <> '#'||'"TABLE_NAME"'||'#'
            and table_owner = q'#"OWNER"#'    -- table_owner
            and table_name = q'#"TABLE_NAME"#'
          order by qualified_index_name
       )
 where rownum = 1]]></default>
                <value><![CDATA[select qualified_index_name
  from ( select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"INDEX_NAME"#' <> '#'||'"INDEX_NAME"'||'#'
            and owner = q'#"OWNER"#'
            and index_name = q'#"INDEX_NAME"#'
          union all
         select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"TABLE_NAME"#' <> '#'||'"TABLE_NAME"'||'#'
            and table_owner = q'#"OWNER"#'
            and table_name = q'#"TABLE_NAME"#'
       )
 order by qualified_index_name]]></value>
            </prompt>
            <prompt reload="true:1" type="text/combo" required="true">  <!-- index: 2 -->
                <label>Scope:</label>
                <default><![CDATA[STATIC:INDEX]]></default>
                <value><![CDATA[select 'INDEX' from dual union all
select 'PARTITION' from dba_part_indexes
 where owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
   and index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
 union all
select 'SUBPARTITION' from dba_part_indexes
 where owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
   and index_name =  regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
   and subpartitioning_type <> 'NONE']]></value>
            </prompt>
            <prompt reload="true:1,2" type="text/combo" required="false"> <!-- index: 3 -->
                <label>Partition / subpartition:</label>
                <value><![CDATA[select pname from
(select partition_name as pname, partition_position as ppos, null as sppos
   from dba_ind_partitions
  where index_owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
    and index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
    and :2 = 'PARTITION'
  union all
 select a.subpartition_name as pname, b.partition_position as ppos, a.subpartition_position as sppos
   from dba_ind_subpartitions a, dba_ind_partitions b
  where b.index_owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
    and b.index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
    and :2 = 'SUBPARTITION'
    and a.index_owner = b.index_owner and a.index_name = b.index_name and a.partition_name = b.partition_name
)
order by ppos, sppos, pname]]></value>
            </prompt>
            <prompt reload="true:1,2" type="text/combo" required="true">  <!-- index: 4 -->
                <label>Granularity:</label>
                <default><![CDATA[select decode(:2, 'PARTITION', 'PARTITION', 'SUBPARTITION', 'SUBPARTITION', 'AUTO') from dual]]></default>
                <value><![CDATA[select 'AUTO' from dual 
 union all
select regexp_substr(granularity_list, '([^,]+)', 1, level)
  from (select 'ALL,GLOBAL,GLOBAL AND PARTITION,PARTITION'
               || case when subpartitioning_type <> 'NONE' then ',SUBPARTITION' end  as granularity_list
          from dba_part_indexes
         where owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
           and index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
       )
 connect by instr(granularity_list, ',', 1, level - 1) > 0]]></value>
            </prompt>
            <prompt type="radio" required="true">   <!-- index: 5 -->
                <label>Degree:</label>
                <default><![CDATA[STATIC:1]]></default>
                <value><![CDATA[STATIC:1:2:4:8:16]]></value>
            </prompt>
            <prompt type="check">                   <!-- index: 6 -->
                <label>Invalidate cursors:</label>
                <default><![CDATA[STATIC:Y]]></default>
                <value><![CDATA[STATIC:Y]]></value>
            </prompt>
            <sql><![CDATA[begin
    dbms_stats.gather_index_stats(
        ownname       => regexp_substr(q'#"1"#', '"([^"]*)"', 1, 1, null, 1)
      , indname       => regexp_substr(q'#"1"#', '"([^"]*)"', 1, 2, null, 1)
      , partname      => q'#"3"#'
      , granularity   => '#4#'
      , degree        => #5#
      , no_invalidate => (nvl('#6#', 'N') = 'N')
    );
end;]]></sql>
            <confirmation>
                <title>Statistics gathered</title>
                <sql><![CDATA[select
      to_char(max(last_analyzed), 'YYYY-MM-DD HH24:MI:SS')  as dte_last_analyzed
    , lower(max(object_type)
          keep (dense_rank first order by
              last_analyzed desc nulls last,
              decode(object_type, 'INDEX', 1, 'PARTITION', 2, 'SUBPARTITION', 3),
              partition_position desc, subpartition_position desc))  as last_object_type
    , max(decode(object_type, 'INDEX', index_name, 'PARTITION', partition_name, 'SUBPARTITION', subpartition_name))
          keep (dense_rank first order by
              last_analyzed desc nulls last,
              decode(object_type, 'INDEX', 1, 'PARTITION', 2, 'SUBPARTITION', 3),
              partition_position desc, subpartition_position desc)  as last_object_name
 from dba_ind_statistics
where ( q'#"INDEX_NAME"#' <> '#'||'"INDEX_NAME"'||'#'
        and owner = q'#"OWNER"#'    -- index_owner
        and index_name = q'#"INDEX_NAME"#'
      )
   or ( q'#"TABLE_NAME"#' <> '#'||'"TABLE_NAME"'||'#'
        and table_owner = q'#"OWNER"#'    -- table_owner
        and table_name = q'#"TABLE_NAME"#'
      )]]></sql>
                <prompt><![CDATA[Statistics on #1# gathered. Last analyzed: #0.LAST_OBJECT_NAME#
(type: #0.LAST_OBJECT_TYPE#) on #0.DTE_LAST_ANALYZED#]]></prompt>
            </confirmation>
        </item>
        <item reload="true" reloadparent="false" removeFromParent="false">
            <title>Gather Index Stats in Job...</title>
            <help><![CDATA[This will start a DBMS_SCHEDULER job for gathering statistics on the specified index.]]></help>
            <prompt type="confirm">
                <label>Confirm create index stats job?</label>
            </prompt>
            <prompt type="text/combo" required="true">  <!-- index: 1 -->
                <label>Index:</label>
                <default><![CDATA[select qualified_index_name
  from ( select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"INDEX_NAME"#' <> '#'||'"INDEX_NAME"'||'#'
            and owner = q'#"OWNER"#'    -- index_owner
            and index_name = q'#"INDEX_NAME"#'
          union all
         select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"TABLE_NAME"#' <> '#'||'"TABLE_NAME"'||'#'
            and table_owner = q'#"OWNER"#'    -- table_owner
            and table_name = q'#"TABLE_NAME"#'
          order by qualified_index_name
       )
 where rownum = 1]]></default>
                <value><![CDATA[select qualified_index_name
  from ( select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"INDEX_NAME"#' <> '#'||'"INDEX_NAME"'||'#'
            and owner = q'#"OWNER"#'
            and index_name = q'#"INDEX_NAME"#'
          union all
         select '"' || owner || '"."' || index_name || '"'  as qualified_index_name
           from dba_indexes
          where q'#"TABLE_NAME"#' <> '#'||'"TABLE_NAME"'||'#'
            and table_owner = q'#"OWNER"#'
            and table_name = q'#"TABLE_NAME"#'
       )
 order by qualified_index_name]]></value>
            </prompt>
            <prompt reload="true:1" type="text/combo" required="true">  <!-- index: 2 -->
                <label>Scope:</label>
                <default><![CDATA[STATIC:INDEX]]></default>
                <value><![CDATA[select 'INDEX' from dual union all
select 'PARTITION' from dba_part_indexes
 where owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
   and index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
 union all
select 'SUBPARTITION' from dba_part_indexes
 where owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
   and index_name =  regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
   and subpartitioning_type <> 'NONE']]></value>
        </prompt>
            <prompt reload="true:1,2" type="text/combo" required="false"> <!-- index: 3 -->
                <label>Partition / subpartition:</label>
                <value><![CDATA[select pname from
(select partition_name as pname, partition_position as ppos, null as sppos
   from dba_ind_partitions
  where index_owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
    and index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
    and :2 = 'PARTITION'
  union all
 select a.subpartition_name as pname, b.partition_position as ppos, a.subpartition_position as sppos
   from dba_ind_subpartitions a, dba_ind_partitions b
  where b.index_owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
    and b.index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
    and :2 = 'SUBPARTITION'
    and a.index_owner = b.index_owner and a.index_name = b.index_name and a.partition_name = b.partition_name
)
order by ppos, sppos, pname]]></value>
            </prompt>
            <prompt reload="true:1,2" type="text/combo" required="true">  <!-- index: 4 -->
                <label>Granularity:</label>
                <default><![CDATA[select decode(:2, 'PARTITION', 'PARTITION', 'SUBPARTITION', 'SUBPARTITION', 'AUTO') from dual]]></default>
                <value><![CDATA[select 'AUTO' from dual 
 union all
select regexp_substr(granularity_list, '([^,]+)', 1, level)
  from (select 'ALL,GLOBAL,GLOBAL AND PARTITION,PARTITION'
               || case when subpartitioning_type <> 'NONE' then ',SUBPARTITION' end  as granularity_list
          from dba_part_indexes
         where owner = regexp_substr(:1, '"([^"]*)"', 1, 1, null, 1)
           and index_name = regexp_substr(:1, '"([^"]*)"', 1, 2, null, 1)
       )
 connect by instr(granularity_list, ',', 1, level - 1) > 0]]></value>
            </prompt>
            <prompt type="radio" required="true">   <!-- index: 5 -->
                <label>Degree:</label>
                <default><![CDATA[STATIC:1]]></default>
                <value><![CDATA[STATIC:1:2:4:8:16]]></value>
            </prompt>
            <prompt type="check">                   <!-- index: 6 -->
                <label>Invalidate cursors:</label>
                <default><![CDATA[STATIC:Y]]></default>
                <value><![CDATA[STATIC:Y]]></value>
            </prompt>
            <prompt type="text/combo">              <!-- index: 7 -->
                <label>Job Class:</label>
                <default><![CDATA[STATIC:DEFAULT_JOB_CLASS]]></default>
                <value><![CDATA[select job_class_name from dba_scheduler_job_classes
 where not regexp_like(job_class_name, '^(ORA\$)')
   and job_class_name not in ('SCHED$_LOG_ON_ERRORS_CLASS', 'XMLDB_NFS_JOBCLASS', 'DBMS_JOB$', 'AQ$_PROPAGATION_JOB_CLASS')
 order by job_class_name]]></value>
            </prompt>
            <sql><![CDATA[declare
    l_qual_index_name  varchar2(300);
    l_index_owner      varchar2(130);
    l_index_name       varchar2(130);
    l_job_name         user_scheduler_jobs.job_name %type;

    function as_vc2_lit (p_str in varchar2) return varchar2
    is begin
        return '''' || regexp_replace(p_str, '''', q'{''}') || '''';
    end as_vc2_lit;
begin
    l_qual_index_name := q'#"1"#';
    l_job_name        := dbms_scheduler.generate_job_name('"sqldev_idx_stats_$"');
    l_index_owner     := regexp_substr(l_qual_index_name, '"([^"]*)"', 1, 1, null, 1);
    l_index_name      := regexp_substr(l_qual_index_name, '"([^"]*)"', 1, 2, null, 1);

    dbms_scheduler.create_job(
        job_name   => '"' || l_index_owner || '"."' || l_job_name || '"'
      , job_type   => 'PLSQL_BLOCK'
      , enabled    => false
      , comments   => 'Statistics gathering job on ' || l_qual_index_name
      , job_class  => q'#"7"#'
      , job_action => q'{begin
            dbms_stats.gather_index_stats(
                ownname       => }' || as_vc2_lit(l_index_owner) || q'{
              , indname       => }' || as_vc2_lit(l_index_name)  || q'{
              , partname      => q'#"3"#'
              , granularity   => '#4#'
              , degree        => #5#
              , no_invalidate => (nvl('#6#', 'N') = 'N')
            );
        end;}'
    );
    dbms_scheduler.set_attribute(
        name      => '"' || l_index_owner || '"."' || l_job_name || '"'
      , attribute => 'logging_level'
      , value     => dbms_scheduler.logging_full
    );
    dbms_scheduler.enable(
        name  => '"' || l_index_owner || '"."' || l_job_name || '"'
    );
end;]]></sql>
        <confirmation>
            <title>Statistics job created</title>
            <sql><![CDATA[with latest_enabled_job as (
    select owner, job_name, log_date
      from (select owner, job_name, log_date
              from dba_scheduler_job_log
             where owner = q'#"OWNER"#'
               and regexp_like(job_name, '^sqldev_idx_stats_\$\d+$')
               and user_name = sys_context('USERENV', 'SESSION_USER')
               and operation = 'ENABLE'
               and log_date >= current_timestamp - numtodsinterval(5, 'SECOND')
             union all
            select null, null, null from dual
             order by log_date desc nulls last
           )
     where rownum = 1
),
latest_job_info as (
    select a.owner
         , a.job_name
         , case
               when c.status is not null
               then c.status || ', date: ' || to_char(c.log_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null and b.last_start_date is not null
               then b.state || ', start date: ' || to_char(b.last_start_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null and b.next_run_date is not null
               then b.state || ', run date: ' || to_char(b.next_run_date, 'YYYY-MM-DD HH24:MI:SS')
               when b.state is not null
               then b.state || ', enabled on: ' || to_char(a.log_date, 'YYYY-MM-DD HH24:MI:SS')
               else 'ENABLED, date: ' || to_char(a.log_date, 'YYYY-MM-DD HH24:MI:SS')
           end   as state_info
      from latest_enabled_job a
         , dba_scheduler_jobs b
         , dba_scheduler_job_log c
     where a.owner = b.owner (+)
       and a.job_name = b.job_name (+)
       and a.owner = c.owner (+)
       and a.job_name = c.job_name (+)
       and c.operation (+) = 'RUN'
)
select case
           when job_name is null
           then '*** Job information not found ***'
           else 'Latest job: "' || owner || '"."' || job_name || '", status: ' || state_info
       end  as job_state_info
  from latest_job_info]]></sql>
            <prompt><![CDATA[#0.JOB_STATE_INFO#]]></prompt>
        </confirmation>
        </item>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Col usage]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    l.equality_preds, 
    l.equijoin_preds, 
    l.nonequijoin_preds, 
    l.range_preds, 
    l.like_preds, 
    l.null_preds, 
    l.timestamp,
    b.comments,
    h.cnt_indexes,
    h.index_list    
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h,
    (select 
        i.owner,
        j.table_name,
        j.column_name,
        k.equality_preds, 
        k.equijoin_preds, 
        k.nonequijoin_preds, 
        k.range_preds, 
        k.like_preds, 
        k.null_preds, 
        k.timestamp
    from
        sys.col_usage$ k,
        dba_objects i,
        dba_tab_cols j
    where
        k.obj# = i.object_id
        and i.object_type = 'TABLE'
        and i.owner = :OWNER
        and i.object_name = :TABLE_NAME
        and j.owner = i.owner
        and j.table_name = i.object_name
        and j.internal_column_id = k.intcol#
    ) l
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
    and  a.owner = l.owner (+)
    and  a.table_name = l.table_name (+)
    and  a.column_name = l.column_name (+)
order by
    a.internal_column_id]]></sql>
		</query>
		<query>
			<sql><![CDATA[select
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    l.equality_preds, 
    l.equijoin_preds, 
    l.nonequijoin_preds, 
    l.range_preds, 
    l.like_preds, 
    l.null_preds, 
    l.timestamp,
    b.comments,
    h.cnt_indexes,
    h.index_list    
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h,
    (select 
        i.owner,
        j.table_name,
        j.column_name,
        k.equality_preds, 
        k.equijoin_preds, 
        k.nonequijoin_preds, 
        k.range_preds, 
        k.like_preds, 
        k.null_preds, 
        k.timestamp
    from
        sys.col_usage$ k,
        dba_objects i,
        dba_tab_cols j
    where
        k.obj# = i.object_id
        and i.object_type = 'TABLE'
        and i.owner = :OWNER
        and i.object_name = :TABLE_NAME
        and j.owner = i.owner
        and j.table_name = i.object_name
        and j.internal_column_id = k.intcol#
    ) l
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
    and  a.owner = l.owner (+)
    and  a.table_name = l.table_name (+)
    and  a.column_name = l.column_name (+)
order by
    a.column_id]]></sql>
		</query>
        </queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Tab mod.]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
        a.table_owner, a.table_name, a.partition_name, a.subpartition_name,
        a.inserts,
        a.updates,
        a.deletes,
        a.timestamp,
        a.truncated,
        a.drop_segments
    from 
        dba_tab_modifications a
    where
        a.table_owner = :OWNER
        and a.table_name = :TABLE_NAME
    order by
        a.table_owner, a.table_name, a.partition_name, a.subpartition_name]]></sql>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Col stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    dba_tab_col_statistics b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and a.column_name = b.column_name
order by
    a.column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Part stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select  /*+ noparallel */
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name) as part_hv,
    b.interval,
    b.compression,
    b.compress_for,
    b.indexing,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    --a.scan_rate, /* 12.2, external tables only */
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    a.scope,
    c.inserts, c.deletes, c.updates, 
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_partitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'PARTITION'
    and a.partition_name is not null
    and a.subpartition_name is null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_position = b.partition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and c.subpartition_name (+) is null
order by
    a.object_type, a.partition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query>
			<sql><![CDATA[select 
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name) as part_hv,
    b.interval,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    c.inserts, c.deletes, c.updates, 
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_partitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'PARTITION'
    and a.partition_name is not null
    and a.subpartition_name is null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_position = b.partition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and c.subpartition_name (+) is null
order by
    a.object_type, a.partition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Part col stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    b.partition_name as part_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    dba_part_col_statistics b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and a.column_name = b.column_name
    and b.partition_name = :PARTITION_NAME
order by
    a.column_id]]></sql>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Part segments]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    nvl(b.tablespace_name, '-- Grand total --') as tablespace_name,
    nvl(b.segment_type, nvl2(b.tablespace_name, '-- Total for TBS --', null)) as segment_type, 
    b.segment_subtype,
    b.owner, b.segment_name,
    count(*) as cnt_seg,
    round(sum(b.bytes) / power(2, 20), 1) as total_size_mb,
    sum(b.blocks) as total_blocks,
    b.lob_column_name
from
    (select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tab_partitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.subpartition_count = 0
        and b.table_owner = a.owner
        and b.table_name = a.segment_name
        and b.partition_name = a.partition_name
        and a.segment_type = 'TABLE PARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tab_subpartitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.table_owner = a.owner
        and b.table_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'TABLE SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_ind_partitions b,
        dba_indexes c,
        dba_part_indexes d,
        dba_tab_partitions e
    where
        e.table_owner = :OWNER
        and e.table_name = :TABLE_NAME
        and e.partition_name = :PARTITION_NAME
        and e.table_owner = c.table_owner
        and e.table_name = c.table_name
        and c.index_type <> 'LOB'
        and c.owner = d.owner
        and c.index_name = d.index_name
        and d.locality = 'LOCAL'
        and d.subpartitioning_key_count = 0
        and c.owner = b.index_owner
        and c.index_name = b.index_name
        and e.partition_position = b.partition_position
        and b.index_owner = a.owner
        and b.index_name = a.segment_name
        and b.partition_name = a.partition_name
        and a.segment_type = 'INDEX PARTITION'
    union all
    select /*+ no_query_transformation leading(f d e c b a) */
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_ind_subpartitions b,
        dba_ind_partitions c,
        dba_indexes d,
        dba_part_indexes e,
        dba_tab_partitions f
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and f.partition_name = :PARTITION_NAME
        and f.table_owner = d.table_owner
        and f.table_name = d.table_name
        and d.index_type <> 'LOB'
        and d.owner = e.owner
        and d.index_name = e.index_name
        and e.locality = 'LOCAL'
        and e.subpartitioning_key_count > 0
        and d.owner = c.index_owner
        and d.index_name = c.index_name
        and f.partition_position = c.partition_position
        and c.index_owner = b.index_owner
        and c.index_name = b.index_name
        and c.partition_name = b.partition_name
        and b.index_owner = a.owner
        and b.index_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lob_partitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.composite = 'NO'
        and b.table_owner = a.owner
        and b.lob_name = a.segment_name
        and b.lob_partition_name = a.partition_name
        and a.segment_type = 'LOB PARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        c.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lob_subpartitions b,
        dba_lob_partitions c
    where
        c.table_owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.partition_name = :PARTITION_NAME
        and c.composite = 'YES'
        and c.table_owner = b.table_owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and c.lob_partition_name = b.lob_partition_name
        and b.table_owner = a.owner
        and b.lob_name = a.segment_name
        and b.lob_subpartition_name = a.partition_name
        and a.segment_type = 'LOB SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b,
        dba_lob_partitions c
    where
        c.table_owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.partition_name = :PARTITION_NAME
        and c.composite = 'NO'
        and c.table_owner = b.owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and b.owner = a.owner
        and b.index_name = a.segment_name
        and c.lob_indpart_name = a.partition_name
        and a.segment_type = 'INDEX PARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b,
        dba_lob_subpartitions c,
        dba_lob_partitions d
    where
        d.table_owner = :OWNER
        and d.table_name = :TABLE_NAME
        and d.partition_name = :PARTITION_NAME
        and d.composite = 'YES'
        and d.table_owner = c.table_owner
        and d.table_name = c.table_name
        and d.column_name = c.column_name
        and d.lob_partition_name = c.lob_partition_name
        and c.table_owner = b.owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and b.owner = a.owner
        and b.index_name = a.segment_name
        and c.lob_indsubpart_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    ) b
group by 
    grouping sets (
        (tablespace_name,
        segment_type, segment_subtype,
        owner, segment_name, lob_column_name),
        (tablespace_name), 
        ()
)
order by
    nvl2(b.tablespace_name, 0, 1), nvl2(b.segment_type, 0, 1),
    b.tablespace_name,
    case when b.segment_type like 'TABLE%' then 1
        when b.segment_type like 'INDEX%' and b.segment_name not like 'SYS_IL%' then 2
        when b.segment_type like 'INDEX%' and b.segment_name like 'SYS_IL%' then 4
        when b.segment_type like 'LOB%' then 3 end,
    b.segment_type, b.segment_subtype, 
    b.owner, b.segment_name, b.lob_column_name]]></sql>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Subpart stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    a.subpartition_position as subpart_pos, 
    a.subpartition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name, p_subpart_name => b.subpartition_name) as subpart_hv,
    b.compression,
    b.compress_for,
    b.indexing,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    --a.scan_rate,  /* 12.2, external tables only */
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    a.scope,
    c.inserts, c.deletes, c.updates,
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_subpartitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'SUBPARTITION'
    and a.partition_name = :PARTITION_NAME
    and a.subpartition_name is not null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_name = b.partition_name
    and a.subpartition_position = b.subpartition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and a.subpartition_name = c.subpartition_name (+)
order by
    a.object_type, a.partition_position, a.subpartition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PARTITION_NAME">
					<prompt><![CDATA[PARTITION_NAME]]></prompt>
					<tooltip><![CDATA[PARTITION_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query>
			<sql><![CDATA[select 
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    a.subpartition_position as subpart_pos, 
    a.subpartition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name, p_subpart_name => b.subpartition_name) as subpart_hv,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    c.inserts, c.deletes, c.updates,
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_subpartitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'SUBPARTITION'
    and a.partition_name = :PARTITION_NAME
    and a.subpartition_name is not null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_name = b.partition_name
    and a.subpartition_position = b.subpartition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and a.subpartition_name = c.subpartition_name (+)
order by
    a.object_type, a.partition_position, a.subpartition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PARTITION_NAME">
					<prompt><![CDATA[PARTITION_NAME]]></prompt>
					<tooltip><![CDATA[PARTITION_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Subpart col stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    b.subpartition_name as subpart_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    dba_subpart_col_statistics b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and a.column_name = b.column_name
    and b.subpartition_name = :SUBPARTITION_NAME
order by
    column_id]]></sql>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Subpart segments]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    nvl(b.tablespace_name, '-- Grand total --') as tablespace_name,
    nvl(b.segment_type, nvl2(b.tablespace_name, '-- Total for TBS --', null)) as segment_type, 
    b.segment_subtype,
    b.owner, b.segment_name,
    count(*) as cnt_seg,
    round(sum(b.bytes) / power(2, 20), 1) as total_size_mb,
    sum(b.blocks) as total_blocks,
    b.lob_column_name
from
    (select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, 
        b.subpartition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tab_subpartitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.subpartition_name = :SUBPARTITION_NAME
        and b.table_owner = a.owner
        and b.table_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'TABLE SUBPARTITION'
    union all
    select /*+ no_query_transformation leading(g f d e c b a) */
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, 
        g.subpartition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_ind_subpartitions b,
        dba_ind_partitions c,
        dba_indexes d,
        dba_part_indexes e,
        dba_tab_partitions f,
        dba_tab_subpartitions g
    where
        g.table_owner = :OWNER
        and g.table_name = :TABLE_NAME
        and g.partition_name = :PARTITION_NAME
        and g.subpartition_name = :SUBPARTITION_NAME
        and g.table_owner = f.table_owner
        and g.table_name = f.table_name
        and g.partition_name = f.partition_name
        and f.table_owner = d.table_owner
        and f.table_name = d.table_name
        and d.index_type <> 'LOB'
        and d.owner = e.owner
        and d.index_name = e.index_name
        and e.locality = 'LOCAL'
        and e.subpartitioning_key_count > 0
        and d.owner = c.index_owner
        and d.index_name = c.index_name
        and f.partition_position = c.partition_position
        and c.index_owner = b.index_owner
        and c.index_name = b.index_name
        and c.partition_name = b.partition_name
        and g.subpartition_position = b.subpartition_position
        and b.index_owner = a.owner
        and b.index_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name,
        b.subpartition_name,
        c.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lob_subpartitions b,
        dba_lob_partitions c
    where
        c.table_owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.partition_name = :PARTITION_NAME
        and c.composite = 'YES'
        and c.table_owner = b.table_owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and c.lob_partition_name = b.lob_partition_name
        and b.subpartition_name = :SUBPARTITION_NAME
        and b.table_owner = a.owner
        and b.lob_name = a.segment_name
        and b.lob_subpartition_name = a.partition_name
        and a.segment_type = 'LOB SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, 
        c.subpartition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b,
        dba_lob_subpartitions c,
        dba_lob_partitions d
    where
        d.table_owner = :OWNER
        and d.table_name = :TABLE_NAME
        and d.partition_name = :PARTITION_NAME
        and d.composite = 'YES'
        and d.table_owner = c.table_owner
        and d.table_name = c.table_name
        and d.column_name = c.column_name
        and d.lob_partition_name = c.lob_partition_name
        and c.subpartition_name = :SUBPARTITION_NAME
        and c.table_owner = b.owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and b.owner = a.owner
        and b.index_name = a.segment_name
        and c.lob_indsubpart_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    ) b
group by 
    grouping sets (
        (tablespace_name,
        segment_type, segment_subtype,
        owner, segment_name, lob_column_name),
        (tablespace_name), 
        ()
)
order by
    nvl2(b.tablespace_name, 0, 1), nvl2(b.segment_type, 0, 1),
    b.tablespace_name,
    case when b.segment_type like 'TABLE%' then 1
        when b.segment_type like 'INDEX%' and b.segment_name not like 'SYS_IL%' then 2
        when b.segment_type like 'INDEX%' and b.segment_name like 'SYS_IL%' then 4
        when b.segment_type like 'LOB%' then 3 end,
    b.segment_type, b.segment_subtype, 
    b.owner, b.segment_name, b.lob_column_name]]></sql>
		</query>
	</display>
	</display>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[All subp stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[
select /*+ noparallel */ *
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        null as subpart_pos,
        null as subpartition_name,
        null as subpart_hv,
        b.compression,
        b.compress_for,
        b.indexing,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        --a.scan_rate,  /* 12.2, external tables only */
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        a.scope,
        c.inserts, c.deletes, c.updates, 
        c.drop_segments, c.truncated, c.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_modifications c
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'PARTITION'
        and a.partition_name is not null
        and a.subpartition_name is null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner (+)
        and a.table_name = c.table_name (+)
        and a.partition_name = c.partition_name (+)
        and c.subpartition_name (+) is null
    order by
        a.partition_position
    )
union all
select * 
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        a.subpartition_position as subpart_pos, 
        a.subpartition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => c.table_owner, p_table_name => c.table_name,
                p_part_name => c.partition_name, p_subpart_name => c.subpartition_name) as subpart_hv,
        c.compression,
        c.compress_for,
        c.indexing,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        --a.scan_rate,  /* 12.2, external tables only */
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        a.scope,
        d.inserts, d.deletes, d.updates, 
        d.drop_segments, d.truncated, d.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_subpartitions c,
        dba_tab_modifications d
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'SUBPARTITION'
        and a.partition_name is not null
        and a.subpartition_name is not null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner
        and a.table_name = c.table_name
        and a.partition_name = c.partition_name
        and a.subpartition_position = c.subpartition_position
        and a.owner = d.table_owner (+)
        and a.table_name = d.table_name (+)
        and a.partition_name = d.partition_name (+)
        and a.subpartition_name = d.subpartition_name (+)
    order by
        a.partition_position, a.subpartition_position
    )
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query>
			<sql><![CDATA[
select *
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        null as subpart_pos,
        null as subpartition_name,
        null as subpart_hv,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        c.inserts, c.deletes, c.updates, 
        c.drop_segments, c.truncated, c.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_modifications c
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'PARTITION'
        and a.partition_name is not null
        and a.subpartition_name is null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner (+)
        and a.table_name = c.table_name (+)
        and a.partition_name = c.partition_name (+)
        and c.subpartition_name (+) is null
    order by
        a.partition_position
    )
union all
select * 
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        a.subpartition_position as subpart_pos, 
        a.subpartition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => c.table_owner, p_table_name => c.table_name,
                p_part_name => c.partition_name, p_subpart_name => c.subpartition_name) as subpart_hv,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        d.inserts, d.deletes, d.updates, 
        d.drop_segments, d.truncated, d.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_subpartitions c,
        dba_tab_modifications d
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'SUBPARTITION'
        and a.partition_name is not null
        and a.subpartition_name is not null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner
        and a.table_name = c.table_name
        and a.partition_name = c.partition_name
        and a.subpartition_position = c.subpartition_position
        and a.owner = d.table_owner (+)
        and a.table_name = d.table_name (+)
        and a.partition_name = d.partition_name (+)
        and a.subpartition_name = d.subpartition_name (+)
    order by
        a.partition_position, a.subpartition_position
    )
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Column stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    :OBJECT_TYPE as object_type,
    b.part_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    (select
        partition_name as part_name,
        column_name,
        num_distinct,
        num_nulls,
        density,
        low_value,
        high_value,
        histogram,
        num_buckets,
        avg_col_len,
        sample_size,
        user_stats,
        global_stats,
        last_analyzed
    from
        dba_part_col_statistics
    where
        owner = :OWNER
        and table_name = :TABLE_NAME
        and partition_name = :PARTITION_NAME
        and :OBJECT_TYPE = 'PARTITION'
    union all
    select
        subpartition_name as part_name,
        column_name,
        num_distinct,
        num_nulls,
        density,
        low_value,
        high_value,
        histogram,
        num_buckets,
        avg_col_len,
        sample_size,
        user_stats,
        global_stats,
        last_analyzed
    from
        dba_subpart_col_statistics
    where
        owner = :OWNER
        and table_name = :TABLE_NAME
        and subpartition_name = :SUBPARTITION_NAME
        and :OBJECT_TYPE = 'SUBPARTITION'
    ) b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.column_name = b.column_name
order by
    a.column_id]]></sql>
		</query>
	</display>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Grants]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select
    grantee
    , nvl((select 'Y' from dba_roles r where r.role = d.grantee), 'N')  as is_role
    , max(decode(rn, 1, privilege))
            || max(decode(rn, 2, ', ' || privilege))
            || max(decode(rn, 3, ', ' || privilege))
            || max(decode(rn, 4, ', ' || privilege))
            || max(decode(rn, 5, ', ' || privilege))
            || max(decode(rn, 6, ', ' || privilege))
            || max(decode(rn, 7, ', ' || privilege))
            || max(decode(rn, 8, ', ' || privilege))
            || max(decode(rn, 9, ', ' || privilege))
            || max(decode(rn, 10, ', ' || privilege))
            || max(decode(rn, 11, ', ' || privilege))
            || max(decode(rn, 12, ', ' || privilege))
            || max(decode(rn, 13, ', ' || privilege))
            || max(decode(rn, 14, ', ' || privilege))
            || max(decode(rn, 15, ', ' || privilege))
            || max(decode(rn, 16, ', ' || privilege))
            || /* 
                  This purposely raises ORA-01722 invalid number if there are 
                  more than 16 distinct privileges in the same group.
                */
               max(decode(rn, 17, to_char(to_number('too many privs!'))))
        as object_privs
    , owner
    , object_name 
            || case 
                when column_name is not null 
                then '.' || column_name
               end
        as object_name
    , object_type
    , grantable
    , hierarchy
    , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
from
    (select
        c.grantee
        , c.privilege
        , c.owner
        , c.object_type
        , c.object_name
        , c.column_name
        , c.grantable
        , c.hierarchy
        , c.common       /* DB version >= 12.1 */
        -- , c.inherited    /* DB version >= 12.2 */
        , /* Fancy ordering of privileges in the same group */ 
          row_number() over (
                partition by
                    c.grantee
                    , c.owner
                    , c.object_type
                    , c.object_name
                    , c.column_name
                    , c.grantable
                    , c.hierarchy
                    , c.common       /* DB version >= 12.1 */
                    -- , c.inherited    /* DB version >= 12.2 */
                order by
                    case c.object_type
                        when 'TABLE' 
                            then decode(c.privilege, 'ALTER', '1', 'READ', '2', 'SELECT', '3',
                                        'INSERT', '4', 'UPDATE', '5', 'DELETE', '6', c.privilege)
                        else
                            c.privilege
                    end)
            as rn
    from
        (select distinct  /* Note: each priv may have been granted
                             more than once by distinct grantors */
            a.grantee
            , a.privilege
            , b.owner
            , b.object_type
            , b.object_name
            , null as column_name
            , a.grantable
            , a.hierarchy
            , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_tab_privs a,
            dba_objects b
        where
            a.owner = b.owner
            and a.table_name = b.object_name
            and a.type = b.object_type   /* DB version >= 12.1 */
            and b.owner = :OWNER
            and b.object_type = 'TABLE'
            and b.object_name = :TABLE_NAME
        union all
        select distinct
            a.grantee
            , a.privilege
            , a.owner
            , 'TABLE COLUMN'    as object_type
            , a.table_name      as object_name
            , a.column_name
            , a.grantable
            , null              as hierarchy
            , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_col_privs a
        where
            a.owner = :OWNER
            and a.table_name = :TABLE_NAME
        ) c
    ) d
group by
    grantee
    , owner
    , object_type
    , object_name
    , column_name
    , grantable
    , hierarchy
    , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
order by
    owner
    , d.object_name
    , grantee
    , d.column_name  nulls first
    , object_privs
    , grantable
    , hierarchy
    , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query>
			<sql><![CDATA[select
    grantee
    , nvl((select 'Y' from dba_roles r where r.role = d.grantee), 'N')  as is_role
    , max(decode(rn, 1, privilege))
            || max(decode(rn, 2, ', ' || privilege))
            || max(decode(rn, 3, ', ' || privilege))
            || max(decode(rn, 4, ', ' || privilege))
            || max(decode(rn, 5, ', ' || privilege))
            || max(decode(rn, 6, ', ' || privilege))
            || max(decode(rn, 7, ', ' || privilege))
            || max(decode(rn, 8, ', ' || privilege))
            || max(decode(rn, 9, ', ' || privilege))
            || max(decode(rn, 10, ', ' || privilege))
            || max(decode(rn, 11, ', ' || privilege))
            || max(decode(rn, 12, ', ' || privilege))
            || max(decode(rn, 13, ', ' || privilege))
            || max(decode(rn, 14, ', ' || privilege))
            || max(decode(rn, 15, ', ' || privilege))
            || max(decode(rn, 16, ', ' || privilege))
            || /* 
                  This purposely raises ORA-01722 invalid number if there are 
                  more than 16 distinct privileges in the same group.
                */
               max(decode(rn, 17, to_char(to_number('too many privs!'))))
        as object_privs
    , owner
    , object_name 
            || case 
                when column_name is not null 
                then '.' || column_name
               end
        as object_name
    , object_type
    , grantable
    , hierarchy
    -- , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
from
    (select
        c.grantee
        , c.privilege
        , c.owner
        , c.object_type
        , c.object_name
        , c.column_name
        , c.grantable
        , c.hierarchy
        -- , c.common       /* DB version >= 12.1 */
        -- , c.inherited    /* DB version >= 12.2 */
        , /* Fancy ordering of privileges in the same group */ 
          row_number() over (
                partition by
                    c.grantee
                    , c.owner
                    , c.object_type
                    , c.object_name
                    , c.column_name
                    , c.grantable
                    , c.hierarchy
                    -- , c.common       /* DB version >= 12.1 */
                    -- , c.inherited    /* DB version >= 12.2 */
                order by
                    case c.object_type
                        when 'TABLE' 
                            then decode(c.privilege, 'ALTER', '1', 'READ', '2', 'SELECT', '3',
                                        'INSERT', '4', 'UPDATE', '5', 'DELETE', '6', c.privilege)
                        else
                            c.privilege
                    end)
            as rn
    from
        (select distinct  /* Note: each priv may have been granted
                             more than once by distinct grantors */
            a.grantee
            , a.privilege
            , b.owner
            , b.object_type
            , b.object_name
            , null as column_name
            , a.grantable
            , a.hierarchy
            -- , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_tab_privs a,
            dba_objects b
        where
            a.owner = b.owner
            and a.table_name = b.object_name
            -- and a.type = b.object_type   /* DB version >= 12.1 */
            and b.owner = :OWNER
            and b.object_type = 'TABLE'
            and b.object_name = :TABLE_NAME
        union all
        select distinct
            a.grantee
            , a.privilege
            , a.owner
            , 'TABLE COLUMN'    as object_type
            , a.table_name      as object_name
            , a.column_name
            , a.grantable
            , null              as hierarchy
            -- , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_col_privs a
        where
            a.owner = :OWNER
            and a.table_name = :TABLE_NAME
        ) c
    ) d
group by
    grantee
    , owner
    , object_type
    , object_name
    , column_name
    , grantable
    , hierarchy
    -- , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
order by
    owner
    , d.object_name
    , grantee
    , d.column_name  nulls first
    , object_privs
    , grantable
    , hierarchy
    -- , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Annot.]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
            <query minversion="23.0">
                <sql><![CDATA[select /*+ no_parallel no_merge(aus) no_merge(col) */
    aus.annotation_owner        as owner,
    aus.object_name             as table_name,
    aus.column_name,
    col.column_id,
    cast(null as varchar2(128)) as index_name,
    aus.annotation_name,
    aus.annotation_value,
    aus.domain_owner,
    aus.domain_name
from
    dba_annotations_usage aus,
    dba_tab_cols col
where
    aus.annotation_owner = :OWNER
    and aus.object_type = 'TABLE'
    and aus.object_name = :TABLE_NAME
    and col.owner (+) = aus.annotation_owner
    and col.table_name (+) = aus.object_name
    and col.column_name (+) = aus.column_name
union all
select /*+ no_merge(ind) no_merge(aus) */
    aus.annotation_owner  as owner,
    ind.table_name,
    aus.column_name,
    cast(null as number)  as column_id,
    ind.index_name,
    aus.annotation_name,
    aus.annotation_value,
    aus.domain_owner,
    aus.domain_name
from
    dba_indexes ind,
    dba_annotations_usage aus
where
    ind.table_owner = :OWNER
    and ind.table_name = :TABLE_NAME
    and aus.annotation_owner = ind.owner
    and aus.object_name = ind.index_name
    and aus.object_type = 'INDEX'
    and aus.column_name is null
order by
    index_name nulls first,
    column_id nulls first,
    annotation_name]]></sql>
                <binds>
                    <bind id="OWNER">
                        <prompt><![CDATA[OWNER]]></prompt>
                        <tooltip><![CDATA[OWNER]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                    <bind id="TABLE_NAME">
                        <prompt><![CDATA[TABLE_NAME]]></prompt>
                        <tooltip><![CDATA[TABLE_NAME]]></tooltip>
                        <value><![CDATA[NULL_VALUE]]></value>
                        <bracket><![CDATA[null]]></bracket>
                    </bind>
                </binds>
            </query>
            <query>
                <sql><![CDATA[select
    'Annotations require Oracle 23c or higher.'  as "Unavailable feature"
from
    dual]]></sql>
            </query>
        </queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[References]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select 
    owner,
    name,
    type,
    referenced_owner,
    referenced_name,
    referenced_type,
    dependency_type
from 
    dba_dependencies
where
    referenced_owner = :OWNER
    and referenced_name = :TABLE_NAME
    and referenced_type = 'TABLE'
order by
    owner, name, type
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Dependencies]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select 
    owner,
    name,
    type,
    referenced_owner,
    referenced_name,
    referenced_type,
    dependency_type
from 
    dba_dependencies
where
    owner = :OWNER
    and name = :TABLE_NAME
    and type = 'TABLE'
order by
    owner, name, type
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
</display>
</folder>
</displays>
