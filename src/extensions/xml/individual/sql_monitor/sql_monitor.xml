<?xml version="1.0" encoding="UTF-8" ?>
<!--
  SPDX-FileCopyrightText: 2020-2024 R.Vassallo
  SPDX-License-Identifier: BSD Zero Clause License
 -->
<displays>
<folder>
<name><![CDATA[Real Time SQL Monitor]]></name>
<display id="6c2e0247-a8ac-4f25-a7c6-e56a448bb500" type="" style="Table" enable="true">
	<name><![CDATA[SQL Monitoring reports (live)]]></name>
	<description><![CDATA[]]></description>
	<tooltip><![CDATA[]]></tooltip>
	<drillclass><![CDATA[]]></drillclass>
	<CustomValues>
		<TYPE><![CDATA[horizontal]]></TYPE>
	</CustomValues>
    <queries>
    <query minversion="12.1">
		<sql><![CDATA[select /*+ no_parallel */
    con_name, service_name, inst_id, 
    sid, session_serial#, 
    awr_id, status, 
    sql_id, sql_exec_id, 
    to_char(sql_exec_start, 'YYYY-MM-DD HH24:MI:SS') as sql_exec_start,  /* <-- Note: TO_CHAR needed here because SQL Dev seems to
                                                                                have trouble passing DATE binds to child reports */
    username, 
    is_full_sqltext, sql_text, 
    last_refresh_time, refresh_count, 
    case
        when px_maxdop is null then
            elapsed_time_s
        else
            greatest(elapsed_time_s, round(86400 * (last_refresh_time - sql_exec_start)))
    end as elapsed_time_s,
    cpu_time_s, queing_time_s, 
    force_matching_signature, sql_full_plan_hash_value, sql_plan_hash_value,
    is_adaptive_plan, is_final_plan, 
    fetches, buffer_gets, 
    disk_reads, direct_writes, io_interconnect_mb, 
    phys_read_req, phys_read_mb, 
    phys_write_req, phys_write_mb, 
    io_cell_uncompressed_mb, io_cell_offload_eli_mb, io_cell_offload_ret_mb, 
    user_io_wait_time_s, app_wait_time_s, conc_wait_time_s, 
    clus_wait_time_s, plsql_exec_time_s, java_exec_time_s, 
    dop_downgrade, px_maxdop, px_servers_requested, 
    px_servers_allocated, px_is_cross_instance, px_maxdop_instances, 
    error_code, error_message, 
    program, module, action, 
    client_identifier, client_info,
    :B_PLAN_DISPLAY_FORMAT as plan_display_fmt,
    coalesce(:B_SPOOL_DIRECTORY, :B_DEFAULT_SPOOL_DIRECTORY) as spool_directory
from 
    (select
        con_name,
        max(case when px_server# is null /* ignore PX workers */ then service_name end)    as service_name,
        nvl2(px_server#, px_qcinst_id, inst_id)         as inst_id,
        nvl2(px_server#, px_qcsid, sid)                 as sid,
        max(case when px_server# is null /* ignore PX workers */ then session_serial# end) as session_serial#,
        max(report_id)                                  as awr_id,
        max(case when px_server# is null /* ignore PX workers */ then status end)          as status,
        sql_id,
        sql_exec_id,
        sql_exec_start,
        max(username)                           as username,
        max(is_full_sqltext)                    as is_full_sqltext,
        max(sql_text)                           as sql_text,
        max(last_refresh_time)                  as last_refresh_time,
        sum(refresh_count)                      as refresh_count,
        round( max(elapsed_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( max(elapsed_time) / power(10,6) ), 0), 1)))) )  as elapsed_time_s,
        round( sum(cpu_time)     / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(cpu_time)     / power(10,6) ), 0), 1)))) )  as cpu_time_s,
        round( max(queuing_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( max(queuing_time) / power(10,6) ), 0), 1)))) )  as queing_time_s,
        max(case when px_maxdop is null /* ignore QC */ then force_matching_signature end)  as force_matching_signature,
        max(case when px_maxdop is null /* ignore QC */ then sql_plan_hash_value end)       as sql_plan_hash_value,
        max(case when px_maxdop is null /* ignore QC */ then sql_full_plan_hash_value end)  as sql_full_plan_hash_value,
        max(case when px_maxdop is null /* ignore QC */ then is_adaptive_plan end)          as is_adaptive_plan,
        max(case when px_maxdop is null /* ignore QC */ then is_final_plan end)             as is_final_plan,
        sum(fetches)                            as fetches,
        sum(buffer_gets)                        as buffer_gets,
        sum(disk_reads)                         as disk_reads,
        sum(direct_writes)                      as direct_writes,
        round( sum(io_interconnect_bytes) / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(io_interconnect_bytes) / power(2,20) ), 0), 1)))) )  as io_interconnect_mb,
        sum(physical_read_requests)             as phys_read_req,
        round( sum(physical_read_bytes)   / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(physical_read_bytes)   / power(2,20) ), 0), 1)))) )  as phys_read_mb,
        sum(physical_write_requests)            as phys_write_req,
        round( sum(physical_write_bytes)  / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(physical_write_bytes)  / power(2,20) ), 0), 1)))) )  as phys_write_mb,
        round( sum(io_cell_uncompressed_bytes)     / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(io_cell_uncompressed_bytes)     / power(2,20) ), 0), 1)))) )  as io_cell_uncompressed_mb,
        round( sum(io_cell_offload_eligible_bytes) / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(io_cell_offload_eligible_bytes) / power(2,20) ), 0), 1)))) )  as io_cell_offload_eli_mb,
        round( sum(io_cell_offload_returned_bytes) / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(io_cell_offload_returned_bytes) / power(2,20) ), 0), 1)))) )  as io_cell_offload_ret_mb,
        round( sum(user_io_wait_time)     / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(user_io_wait_time)     / power(10,6) ), 0), 1)))) )  as user_io_wait_time_s,
        round( sum(application_wait_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(application_wait_time) / power(10,6) ), 0), 1)))) )  as app_wait_time_s,
        round( sum(concurrency_wait_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(concurrency_wait_time) / power(10,6) ), 0), 1)))) )  as conc_wait_time_s,
        round( sum(cluster_wait_time)     / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(cluster_wait_time)     / power(10,6) ), 0), 1)))) )  as clus_wait_time_s,
        round( sum(plsql_exec_time)       / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(plsql_exec_time)       / power(10,6) ), 0), 1)))) )  as plsql_exec_time_s,
        round( sum(java_exec_time)        / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(java_exec_time)        / power(10,6) ), 0), 1)))) )  as java_exec_time_s,
        case
            when count(distinct px_server_set) * max(px_maxdop) < max(px_servers_requested) then 'Y'
            when count(distinct px_server_set) * max(px_maxdop) = max(px_servers_requested) then 'N'
            when count(distinct px_server_set) * max(px_maxdop) > max(px_servers_requested) then '??'
        end                                     as dop_downgrade,
        max(px_maxdop)                          as px_maxdop,
        max(px_servers_requested)               as px_servers_requested,
        max(px_servers_allocated)               as px_servers_allocated,
        max(px_is_cross_instance)               as px_is_cross_instance,
        max(px_maxdop_instances)                as px_maxdop_instances,
        min(error_facility) 
            keep (dense_rank first 
                  order by nvl2(error_facility, last_refresh_time, null) nulls last,
                           nvl2(error_facility, sid, null) nulls last)
            || min(nvl2(error_facility, '-', null))
            || min(error_number) 
                    keep (dense_rank first 
                          order by nvl2(error_facility, last_refresh_time, null) nulls last,
                                   nvl2(error_facility, sid, null) nulls last)              as error_code,
        min(error_message)
            keep (dense_rank first 
                  order by nvl2(error_facility, last_refresh_time, null) nulls last,
                           nvl2(error_facility, sid, null) nulls last)                      as error_message,
        max(program)                            as program,
        max(module)                             as module,
        max(action)                             as action,
        max(client_identifier)                  as client_identifier,
        max(client_info)                        as client_info
    from
        gv$sql_monitor
    where 1 = 1
        and lnnvl(upper(con_name) <> upper(:B_CON_NAME))
        and lnnvl(sql_id <> :B_SQL_ID)
        and lnnvl(sql_exec_start < sysdate - :B_STARTED_IN_LAST_N_MINS / 1440)
        and lnnvl(sql_exec_start < to_date(:B_STARTED_AFTER, 'YYYY-MM-DD HH24:MI:SS'))
    group by
        /* 
            PX_SERVER# is always NULL, unless this is a PX server process,
            PX_MAXDOP is always null, unless this the QC server process in a PX query 
         */
        con_name,
        nvl2(px_server#, px_qcinst_id, inst_id),
        nvl2(px_server#, px_qcsid, sid),
        sql_id,
        sql_exec_id,
        sql_exec_start
)
where 1 = 1
    and lnnvl(elapsed_time_s < to_number(:B_ELAPSED_TIME_S_MIN))
    and lnnvl(inst_id <> to_number(:B_INST_ID))
    and (:B_USERNAME_LIKE is null or upper(username) like upper(:B_USERNAME_LIKE))
    and (:B_USERNAME_RE is null or regexp_like(username, :B_USERNAME_RE, 'i'))
    and (:B_USERNAME_NOT_LIKE is null or lnnvl(upper(username) like upper(:B_USERNAME_NOT_LIKE)))
    and (:B_USERNAME_NOT_RE is null or lnnvl(regexp_like(username, :B_USERNAME_NOT_RE, 'i')))
    and (:B_MODULE_LIKE is null or upper(module) like upper(:B_MODULE_LIKE))
    and (:B_MODULE_RE is null or regexp_like(module, :B_MODULE_RE, 'i'))
    and (:B_ACTION_LIKE is null or upper(action) like upper(:B_ACTION_LIKE))
    and (:B_ACTION_RE is null or regexp_like(action, :B_ACTION_RE, 'i'))
    and (:B_CLIENT_INFO_LIKE is null or upper(client_info) like upper(:B_CLIENT_INFO_LIKE))
    and (:B_CLIENT_INFO_RE is null or regexp_like(client_info, :B_CLIENT_INFO_RE, 'i'))
    and (:B_CLIENT_IDENTIFIER_LIKE is null or upper(client_identifier) like upper(:B_CLIENT_IDENTIFIER_LIKE))
    and (:B_CLIENT_IDENTIFIER_RE is null or regexp_like(client_identifier, :B_CLIENT_IDENTIFIER_RE, 'i'))
    and (lnnvl(upper(:B_EXCLUDE_BACKGROUND) = 'Y') or service_name <> 'SYS$BACKGROUND')
order by
    case when status like '%EXECUTING%' then 1 else 2 end,
    sql_exec_start desc,
    last_refresh_time desc,
    sql_id,
    sql_exec_id desc]]></sql>
		<binds>
			<bind id="B_CON_NAME">
				<prompt><![CDATA[Container name?]]></prompt>
				<tooltip><![CDATA[Show reports for the specified container only]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_INST_ID">
				<prompt><![CDATA[Instance number?]]></prompt>
				<tooltip><![CDATA[Show only queries from the specified instance]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_SQL_ID">
				<prompt><![CDATA[SQL id?]]></prompt>
				<tooltip><![CDATA[Show reports for the specified SQL id only]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_ELAPSED_TIME_S_MIN">
				<prompt><![CDATA[Min. elapsed time?]]></prompt>
				<tooltip><![CDATA[Show only queries with elapsed time >= N seconds]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_STARTED_IN_LAST_N_MINS">
				<prompt><![CDATA[Last N minutes?]]></prompt>
				<tooltip><![CDATA[Show only queries started in the last N minutes]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_STARTED_AFTER">
				<prompt><![CDATA[After date/time?]]></prompt>
				<tooltip><![CDATA[Show only queries started after date/time; format: YYYY-MM-DD HH24:MI:SS]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_LIKE">
				<prompt><![CDATA[Username like?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching users (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_RE">
				<prompt><![CDATA[Username regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching users (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_NOT_LIKE">
				<prompt><![CDATA[Username NOT like?]]></prompt>
				<tooltip><![CDATA[Hide queries of matching users (LIKE pattern)]]></tooltip>
				<value><![CDATA[SYS]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_NOT_RE">
				<prompt><![CDATA[Username negative regexp?]]></prompt>
				<tooltip><![CDATA[Hide queries of matching users (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_MODULE_LIKE">
				<prompt><![CDATA[Module like?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching module (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_MODULE_RE">
				<prompt><![CDATA[Module regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching module (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_ACTION_LIKE">
				<prompt><![CDATA[Action like?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching action (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_ACTION_RE">
				<prompt><![CDATA[Action regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching action (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_INFO_LIKE">
				<prompt><![CDATA[Client info like?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client info (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_INFO_RE">
				<prompt><![CDATA[Client info regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client info (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_IDENTIFIER_LIKE">
				<prompt><![CDATA[Client identifier like?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client identifier (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_IDENTIFIER_RE">
				<prompt><![CDATA[Client identifier regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client identifier (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_EXCLUDE_BACKGROUND">
				<prompt><![CDATA[Exclude background?]]></prompt>
				<tooltip><![CDATA[If 'Y', hide queries of background processes]]></tooltip>
				<value><![CDATA[y]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_PLAN_DISPLAY_FORMAT">
				<prompt><![CDATA[Plan display format?]]></prompt>
				<tooltip><![CDATA[Plan display format; default: Advanced -projection +allstats last]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_SPOOL_DIRECTORY">
				<prompt><![CDATA[Spool directory?]]></prompt>
				<tooltip><![CDATA[Directory where ACTIVE reports will be spooled]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_DEFAULT_SPOOL_DIRECTORY">
				<prompt><![CDATA[Default spool directory?]]></prompt>
				<tooltip><![CDATA[Default spool directory]]></tooltip>
				<!--##USER_CONFIG##--><value><![CDATA[E:\Home\romain\SQL_Developer\output\sql_mon]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
		</binds>
    </query>
    <query>
		<sql><![CDATA[select 
    service_name, inst_id, 
    sid, session_serial#, 
    status, 
    sql_id, sql_exec_id, 
    to_char(sql_exec_start, 'YYYY-MM-DD HH24:MI:SS') as sql_exec_start,  /* <-- Note: TO_CHAR needed here because SQL Dev seems to
                                                                                have trouble passing DATE binds to child reports */
    username, 
    is_full_sqltext, sql_text, 
    last_refresh_time, refresh_count, 
    case
        when px_maxdop is null then
            elapsed_time_s
        else
            greatest(elapsed_time_s, round(86400 * (last_refresh_time - sql_exec_start)))
    end as elapsed_time_s,
    cpu_time_s, queing_time_s, 
    force_matching_signature, sql_plan_hash_value,
    fetches, buffer_gets, 
    disk_reads, direct_writes, io_interconnect_mb, 
    phys_read_req, phys_read_mb, 
    phys_write_req, phys_write_mb, 
    user_io_wait_time_s, app_wait_time_s, conc_wait_time_s, 
    clus_wait_time_s, plsql_exec_time_s, java_exec_time_s, 
    dop_downgrade, px_maxdop, px_servers_requested, 
    px_servers_allocated, px_is_cross_instance, px_maxdop_instances, 
    error_code, error_message, 
    program, module, action, 
    client_identifier, client_info,
    :B_PLAN_DISPLAY_FORMAT as plan_display_fmt,
    coalesce(:B_SPOOL_DIRECTORY, :B_DEFAULT_SPOOL_DIRECTORY) as spool_directory
from 
    (select
        max(case when px_server# is null /* ignore PX workers */ then service_name end)    as service_name,
        nvl2(px_server#, px_qcinst_id, inst_id)         as inst_id,
        nvl2(px_server#, px_qcsid, sid)                 as sid,
        max(case when px_server# is null /* ignore PX workers */ then session_serial# end) as session_serial#,
        max(case when px_server# is null /* ignore PX workers */ then status end)          as status,
        sql_id,
        sql_exec_id,
        sql_exec_start,
        max(username)                           as username,
        max(is_full_sqltext)                    as is_full_sqltext,
        max(sql_text)                           as sql_text,
        max(last_refresh_time)                  as last_refresh_time,
        sum(refresh_count)                      as refresh_count,
        round( max(elapsed_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( max(elapsed_time) / power(10,6) ), 0), 1)))) )  as elapsed_time_s,
        round( sum(cpu_time)     / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(cpu_time)     / power(10,6) ), 0), 1)))) )  as cpu_time_s,
        round( max(queuing_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( max(queuing_time) / power(10,6) ), 0), 1)))) )  as queing_time_s,
        max(case when px_maxdop is null /* ignore QC */ then force_matching_signature end)  as force_matching_signature,
        max(case when px_maxdop is null /* ignore QC */ then sql_plan_hash_value end)       as sql_plan_hash_value,
        sum(fetches)                            as fetches,
        sum(buffer_gets)                        as buffer_gets,
        sum(disk_reads)                         as disk_reads,
        sum(direct_writes)                      as direct_writes,
        round( sum(io_interconnect_bytes) / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(io_interconnect_bytes) / power(2,20) ), 0), 1)))) )  as io_interconnect_mb,
        sum(physical_read_requests)             as phys_read_req,
        round( sum(physical_read_bytes)   / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(physical_read_bytes)   / power(2,20) ), 0), 1)))) )  as phys_read_mb,
        sum(physical_write_requests)            as phys_write_req,
        round( sum(physical_write_bytes)  / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(physical_write_bytes)  / power(2,20) ), 0), 1)))) )  as phys_write_mb,
        round( sum(user_io_wait_time)     / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(user_io_wait_time)     / power(10,6) ), 0), 1)))) )  as user_io_wait_time_s,
        round( sum(application_wait_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(application_wait_time) / power(10,6) ), 0), 1)))) )  as app_wait_time_s,
        round( sum(concurrency_wait_time) / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(concurrency_wait_time) / power(10,6) ), 0), 1)))) )  as conc_wait_time_s,
        round( sum(cluster_wait_time)     / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(cluster_wait_time)     / power(10,6) ), 0), 1)))) )  as clus_wait_time_s,
        round( sum(plsql_exec_time)       / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(plsql_exec_time)       / power(10,6) ), 0), 1)))) )  as plsql_exec_time_s,
        round( sum(java_exec_time)        / power(10,6) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( sum(java_exec_time)        / power(10,6) ), 0), 1)))) )  as java_exec_time_s,
        case
            when count(distinct px_server_set) * max(px_maxdop) < max(px_servers_requested) then 'Y'
            when count(distinct px_server_set) * max(px_maxdop) = max(px_servers_requested) then 'N'
            when count(distinct px_server_set) * max(px_maxdop) > max(px_servers_requested) then '??'
        end                                     as dop_downgrade,
        max(px_maxdop)                          as px_maxdop,
        max(px_servers_requested)               as px_servers_requested,
        max(px_servers_allocated)               as px_servers_allocated,
        max(px_is_cross_instance)               as px_is_cross_instance,
        max(px_maxdop_instances)                as px_maxdop_instances,
        min(error_facility) 
            keep (dense_rank first 
                  order by nvl2(error_facility, last_refresh_time, null) nulls last,
                           nvl2(error_facility, sid, null) nulls last)
            || min(nvl2(error_facility, '-', null))
            || min(error_number) 
                    keep (dense_rank first 
                          order by nvl2(error_facility, last_refresh_time, null) nulls last,
                                   nvl2(error_facility, sid, null) nulls last)              as error_code,
        min(error_message)
            keep (dense_rank first 
                  order by nvl2(error_facility, last_refresh_time, null) nulls last,
                           nvl2(error_facility, sid, null) nulls last)                      as error_message,
        max(program)                            as program,
        max(module)                             as module,
        max(action)                             as action,
        max(client_identifier)                  as client_identifier,
        max(client_info)                        as client_info
    from
        gv$sql_monitor
    where 1 = 1
        and lnnvl(sql_id <> :B_SQL_ID)
        and lnnvl(sql_exec_start < sysdate - :B_STARTED_IN_LAST_N_MINS / 1440)
        and lnnvl(sql_exec_start < to_date(:B_STARTED_AFTER, 'YYYY-MM-DD HH24:MI:SS'))
    group by
        /* 
            PX_SERVER# is always NULL, unless this is a PX server process,
            PX_MAXDOP is always null, unless this the QC server process in a PX query 
         */
        nvl2(px_server#, px_qcinst_id, inst_id),
        nvl2(px_server#, px_qcsid, sid),
        sql_id,
        sql_exec_id,
        sql_exec_start
)
where 1 = 1
    and lnnvl(elapsed_time_s < to_number(:B_ELAPSED_TIME_S_MIN))
    and lnnvl(inst_id <> to_number(:B_INST_ID))
    and (:B_USERNAME_LIKE is null or upper(username) like upper(:B_USERNAME_LIKE))
    and (:B_USERNAME_RE is null or regexp_like(username, :B_USERNAME_RE, 'i'))
    and (:B_USERNAME_NOT_LIKE is null or lnnvl(upper(username) like upper(:B_USERNAME_NOT_LIKE)))
    and (:B_USERNAME_NOT_RE is null or lnnvl(regexp_like(username, :B_USERNAME_NOT_RE, 'i')))
    and (:B_MODULE_LIKE is null or upper(module) like upper(:B_MODULE_LIKE))
    and (:B_MODULE_RE is null or regexp_like(module, :B_MODULE_RE, 'i'))
    and (:B_ACTION_LIKE is null or upper(action) like upper(:B_ACTION_LIKE))
    and (:B_ACTION_RE is null or regexp_like(action, :B_ACTION_RE, 'i'))
    and (:B_CLIENT_INFO_LIKE is null or upper(client_info) like upper(:B_CLIENT_INFO_LIKE))
    and (:B_CLIENT_INFO_RE is null or regexp_like(client_info, :B_CLIENT_INFO_RE, 'i'))
    and (:B_CLIENT_IDENTIFIER_LIKE is null or upper(client_identifier) like upper(:B_CLIENT_IDENTIFIER_LIKE))
    and (:B_CLIENT_IDENTIFIER_RE is null or regexp_like(client_identifier, :B_CLIENT_IDENTIFIER_RE, 'i'))
    and (lnnvl(upper(:B_EXCLUDE_BACKGROUND) = 'Y') or service_name <> 'SYS$BACKGROUND')
order by
    case when status like '%EXECUTING%' then 1 else 2 end,
    sql_exec_start desc,
    last_refresh_time desc,
    sql_id,
    sql_exec_id desc]]></sql>
		<binds>
			<bind id="B_INST_ID">
				<prompt><![CDATA[Instance number?]]></prompt>
				<tooltip><![CDATA[Show only queries from the specified instance]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_SQL_ID">
				<prompt><![CDATA[SQL id?]]></prompt>
				<tooltip><![CDATA[Show reports for the specified SQL id only]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_ELAPSED_TIME_S_MIN">
				<prompt><![CDATA[Min. elapsed time?]]></prompt>
				<tooltip><![CDATA[Show only queries with elapsed time >= N seconds]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_STARTED_IN_LAST_N_MINS">
				<prompt><![CDATA[Last N minutes?]]></prompt>
				<tooltip><![CDATA[Show only queries started in the last N minutes]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_STARTED_AFTER">
				<prompt><![CDATA[After date/time?]]></prompt>
				<tooltip><![CDATA[Show only queries started after date/time; format: YYYY-MM-DD HH24:MI:SS]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_LIKE">
				<prompt><![CDATA[Username like?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching users (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_RE">
				<prompt><![CDATA[Username regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching users (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_NOT_LIKE">
				<prompt><![CDATA[Username NOT like?]]></prompt>
				<tooltip><![CDATA[Hide queries of matching users (LIKE pattern)]]></tooltip>
				<value><![CDATA[SYS]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_USERNAME_NOT_RE">
				<prompt><![CDATA[Username negative regexp?]]></prompt>
				<tooltip><![CDATA[Hide queries of matching users (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_MODULE_LIKE">
				<prompt><![CDATA[Module like?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching module (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_MODULE_RE">
				<prompt><![CDATA[Module regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries of matching module (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_ACTION_LIKE">
				<prompt><![CDATA[Action like?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching action (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_ACTION_RE">
				<prompt><![CDATA[Action regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching action (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_INFO_LIKE">
				<prompt><![CDATA[Client info like?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client info (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_INFO_RE">
				<prompt><![CDATA[Client info regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client info (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_IDENTIFIER_LIKE">
				<prompt><![CDATA[Client identifier like?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client identifier (LIKE pattern)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_CLIENT_IDENTIFIER_RE">
				<prompt><![CDATA[Client identifier regexp?]]></prompt>
				<tooltip><![CDATA[Show only queries with matching client identifier (regexp)]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_EXCLUDE_BACKGROUND">
				<prompt><![CDATA[Exclude background?]]></prompt>
				<tooltip><![CDATA[If 'Y', hide queries of background processes]]></tooltip>
				<value><![CDATA[y]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_PLAN_DISPLAY_FORMAT">
				<prompt><![CDATA[Plan display format?]]></prompt>
				<tooltip><![CDATA[Plan display format; default: Advanced -projection +allstats last]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_SPOOL_DIRECTORY">
				<prompt><![CDATA[Spool directory?]]></prompt>
				<tooltip><![CDATA[Directory where ACTIVE reports will be spooled]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="B_DEFAULT_SPOOL_DIRECTORY">
				<prompt><![CDATA[Default spool directory?]]></prompt>
				<tooltip><![CDATA[Default spool directory]]></tooltip>
				<!--##USER_CONFIG##--><value><![CDATA[E:\Home\romain\SQL_Developer\output\sql_mon]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
		</binds>
	</query>
	</queries>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[SQL Plan (cursor cache)]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="19.0">
			<sql><![CDATA[with child_cursor as (
    select 
        sql_id, child_number
    from 
        v$sql
    where
        sql_id = :SQL_ID
        and lnnvl(plan_hash_value <> :SQL_PLAN_HASH_VALUE)
        and lnnvl(full_plan_hash_value <> :SQL_FULL_PLAN_HASH_VALUE)
        and lnnvl(plan_hash_value = 0)
    order by
        last_active_time desc
    fetch first 1 row only
)
select b.* 
from 
    child_cursor a,
    table(dbms_xplan.display_cursor(
            sql_id => a.sql_id,
            cursor_child_no => a.child_number,
            format => nvl(:PLAN_DISPLAY_FMT, 'Advanced +adaptive -projection -qbregistry +allstats last')
    )) b]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_FULL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_FULL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_FULL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_DISPLAY_FMT">
					<prompt><![CDATA[PLAN_DISPLAY_FMT]]></prompt>
					<tooltip><![CDATA[PLAN_DISPLAY_FMT]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query minversion="12.1">
			<sql><![CDATA[with child_cursor as (
    select 
        sql_id, child_number
    from 
        v$sql
    where
        sql_id = :SQL_ID
        and lnnvl(plan_hash_value <> :SQL_PLAN_HASH_VALUE)
        and lnnvl(full_plan_hash_value <> :SQL_FULL_PLAN_HASH_VALUE)
        and lnnvl(plan_hash_value = 0)
    order by
        last_active_time desc
    fetch first 1 row only
)
select b.* 
from 
    child_cursor a,
    table(dbms_xplan.display_cursor(
            sql_id => a.sql_id,
            cursor_child_no => a.child_number,
            format => nvl(:PLAN_DISPLAY_FMT, 'Advanced +adaptive -projection +allstats last')
    )) b]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_FULL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_FULL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_FULL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_DISPLAY_FMT">
					<prompt><![CDATA[PLAN_DISPLAY_FMT]]></prompt>
					<tooltip><![CDATA[PLAN_DISPLAY_FMT]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query>
			<sql><![CDATA[with child_cursor as (
    select
        sql_id, child_number
    from
        (select 
            sql_id, child_number,
            row_number() over (order by last_active_time desc) as rn
        from 
            v$sql
        where
            sql_id = :SQL_ID
            and lnnvl(plan_hash_value <> :SQL_PLAN_HASH_VALUE)
            and lnnvl(plan_hash_value = 0)
        )
    where
        rn <= 1
)
select b.* 
from 
    child_cursor a,
    table(dbms_xplan.display_cursor(
            sql_id => a.sql_id,
            cursor_child_no => a.child_number,
            format => nvl(:PLAN_DISPLAY_FMT, 'Advanced -projection +allstats last')
    )) b]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_DISPLAY_FMT">
					<prompt><![CDATA[PLAN_DISPLAY_FMT]]></prompt>
					<tooltip><![CDATA[PLAN_DISPLAY_FMT]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[SQL Plan (AWR)]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="19.0">
			<sql><![CDATA[with hist_plan as (
    select 
        dbid, sql_id, plan_hash_value
    from 
        dba_hist_sql_plan
    where
        sql_id = :SQL_ID
        and plan_hash_value = :SQL_PLAN_HASH_VALUE
        and rownum <= 1
)
select b.* 
from 
    hist_plan a,
    table(dbms_xplan.display_awr(
            sql_id => a.sql_id,
            plan_hash_value => a.plan_hash_value,
            format => nvl( :PLAN_DISPLAY_FMT, 'Advanced +adaptive -qbregistry' )
    )) b]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_DISPLAY_FMT">
					<prompt><![CDATA[PLAN_DISPLAY_FMT]]></prompt>
					<tooltip><![CDATA[PLAN_DISPLAY_FMT]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query minversion="12.1">
			<sql><![CDATA[with hist_plan as (
    select 
        dbid, sql_id, plan_hash_value
    from 
        dba_hist_sql_plan
    where
        sql_id = :SQL_ID
        and plan_hash_value = :SQL_PLAN_HASH_VALUE
        and rownum <= 1
)
select b.* 
from 
    hist_plan a,
    table(dbms_xplan.display_awr(
            sql_id => a.sql_id,
            plan_hash_value => a.plan_hash_value,
            format => nvl( :PLAN_DISPLAY_FMT, 'Advanced +adaptive' )
    )) b]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_DISPLAY_FMT">
					<prompt><![CDATA[PLAN_DISPLAY_FMT]]></prompt>
					<tooltip><![CDATA[PLAN_DISPLAY_FMT]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query>
			<sql><![CDATA[with hist_plan as (
    select 
        dbid, sql_id, plan_hash_value
    from 
        dba_hist_sql_plan
    where
        sql_id = :SQL_ID
        and plan_hash_value = :SQL_PLAN_HASH_VALUE
        and rownum <= 1
)
select b.* 
from 
    hist_plan a,
    table(dbms_xplan.display_awr(
            sql_id => a.sql_id,
            plan_hash_value => a.plan_hash_value,
            format => nvl( :PLAN_DISPLAY_FMT, 'Advanced' )
    )) b]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_PLAN_HASH_VALUE">
					<prompt><![CDATA[SQL_PLAN_HASH_VALUE]]></prompt>
					<tooltip><![CDATA[SQL_PLAN_HASH_VALUE]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PLAN_DISPLAY_FMT">
					<prompt><![CDATA[PLAN_DISPLAY_FMT]]></prompt>
					<tooltip><![CDATA[PLAN_DISPLAY_FMT]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
	</display>
	<display id="null" type="" style="Script" enable="true">
		<name><![CDATA[SQL Monitoring Report (text)]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
		</CustomValues>
		<query>
			<sql><![CDATA[whenever sqlerror exit failure rollback
whenever oserror exit failure rollback

set termout off
-- This would trigger the HIGH_LONG_MEM_WARNING message if TERMOUT was ON
set long 5000000
set termout on
set linesize 600
set heading off
set feedback off
set pagesize 0

column sql_monitor_report format a600 word_wrapped

select
    dbms_sqltune.report_sql_monitor(
        type => 'TEXT',
        sql_id => :SQL_ID,
        sql_exec_id => :SQL_EXEC_ID,
        sql_exec_start => to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'),
        report_level => 'ALL'
    ) as sql_monitor_report
from dual
where
    :SQL_ID is not null
    and :SQL_EXEC_ID is not null
    and :SQL_EXEC_START is not null]]></sql>
			<binds>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_EXEC_ID">
					<prompt><![CDATA[SQL_EXEC_ID]]></prompt>
					<tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_EXEC_START">
					<prompt><![CDATA[SQL_EXEC_START]]></prompt>
					<tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
	<display id="null" type="" style="Script" enable="true">
		<name><![CDATA[SQL Monitoring Report (active)]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
		</CustomValues>
		<query>
			<sql><![CDATA[whenever sqlerror exit failure rollback
whenever oserror exit failure rollback

set termout off
-- This would trigger the HIGH_LONG_MEM_WARNING message if TERMOUT was ON
set long 5000000
set termout on
set linesize 10000
set trimspool on
set heading off
set feedback off
set pagesize 0

set termout off
set verify off

define spool_directory
define spool_filename

column spool_directory noprint new_value spool_directory
column spool_filename noprint new_value spool_filename

select :SPOOL_DIRECTORY as spool_directory from dual 
where :SPOOL_DIRECTORY is not null;

select 'sql_mon-'
            || sys_context('USERENV', 'DB_NAME')
            || '-' || :SQL_ID
            || '-' || to_char(:SQL_EXEC_ID)
            || '-' || to_char(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'), 'YYYYMMDD_HH24MISS')
            || '.html'
    as spool_filename 
from dual
where :SPOOL_DIRECTORY is not null;

cd "&spool_directory"

spool "&spool_filename"

column sql_monitor_report format a600 word_wrapped

select
    dbms_sqltune.report_sql_monitor(
        type => 'ACTIVE',
        sql_id => :SQL_ID,
        sql_exec_id => :SQL_EXEC_ID,
        sql_exec_start => to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'),
        report_level => 'ALL'
    ) as sql_monitor_report
from dual
where
    :SPOOL_DIRECTORY is not null
    and :SQL_ID is not null
    and :SQL_EXEC_ID is not null
    and :SQL_EXEC_START is not null
;

spool off

set termout on

select 'SQL Monitoring report created: ' 
    || '&spool_filename' || chr(10)
    || '(directory: &spool_directory)'
from dual
where :SPOOL_DIRECTORY is not null;]]></sql>
			<binds>
				<bind id="SPOOL_DIRECTORY">
					<prompt><![CDATA[SPOOL_DIRECTORY]]></prompt>
					<tooltip><![CDATA[SPOOL_DIRECTORY]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_EXEC_ID">
					<prompt><![CDATA[SQL_EXEC_ID]]></prompt>
					<tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_EXEC_START">
					<prompt><![CDATA[SQL_EXEC_START]]></prompt>
					<tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>
	<display id="null" type="" style="Script" enable="true">
		<name><![CDATA[SQL Monitoring Report (xml)]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
		</CustomValues>
		<query>
			<sql><![CDATA[whenever sqlerror exit failure rollback
whenever oserror exit failure rollback

set termout off
-- This would trigger the HIGH_LONG_MEM_WARNING message if TERMOUT was ON
set long 5000000
set termout on
set linesize 10000
set trimspool on
set heading off
set feedback off
set pagesize 0

set termout off
set verify off

define spool_directory
define spool_filename

column spool_directory noprint new_value spool_directory
column spool_filename noprint new_value spool_filename

select :SPOOL_DIRECTORY as spool_directory from dual 
where :SPOOL_DIRECTORY is not null;

select 'sql_mon-'
            || sys_context('USERENV', 'DB_NAME')
            || '-' || :SQL_ID
            || '-' || to_char(:SQL_EXEC_ID)
            || '-' || to_char(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'), 'YYYYMMDD_HH24MISS')
            || '.xml'
    as spool_filename 
from dual
where :SPOOL_DIRECTORY is not null;

cd "&spool_directory"

spool "&spool_filename"

column sql_monitor_report format a600 word_wrapped

select
    dbms_sqltune.report_sql_monitor(
        type => 'XML',
        sql_id => :SQL_ID,
        sql_exec_id => :SQL_EXEC_ID,
        sql_exec_start => to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'),
        report_level => 'ALL'
    ) as sql_monitor_report
from dual
where
    :SPOOL_DIRECTORY is not null
    and :SQL_ID is not null
    and :SQL_EXEC_ID is not null
    and :SQL_EXEC_START is not null
;

spool off

set termout on

select 'SQL Monitoring report created: ' 
    || '&spool_filename' || chr(10)
    || '(directory: &spool_directory)'
from dual
where :SPOOL_DIRECTORY is not null;]]></sql>
			<binds>
				<bind id="SPOOL_DIRECTORY">
					<prompt><![CDATA[SPOOL_DIRECTORY]]></prompt>
					<tooltip><![CDATA[SPOOL_DIRECTORY]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_ID">
					<prompt><![CDATA[SQL_ID]]></prompt>
					<tooltip><![CDATA[SQL_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_EXEC_ID">
					<prompt><![CDATA[SQL_EXEC_ID]]></prompt>
					<tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="SQL_EXEC_START">
					<prompt><![CDATA[SQL_EXEC_START]]></prompt>
					<tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
	</display>

    <display id="null" type="" style="Chart" enable="true">
        <name><![CDATA[Metrics: IOPS]]></name>
        <description><![CDATA[]]></description>
        <tooltip><![CDATA[]]></tooltip>
        <drillclass><![CDATA[]]></drillclass>
        <CustomValues>
            <PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
            <Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
            <Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
            <Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
            <Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
            <LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
            <PLOT_SERIES_OPTIONS_COLOR><![CDATA[\,-26368,-3394816,-10066279,-16751002,-26368]]></PLOT_SERIES_OPTIONS_COLOR>
            <LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
            <XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
            <DATA_MAP_COLUMNS><![CDATA[\,"BUCKET_TS","BUCKET_TS",,]]></DATA_MAP_COLUMNS>
            <Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
            <XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
            <XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
            <Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
            <TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
            <GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
            <PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
            <FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
            <XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
            <DATA_MAP_COLNAMES><![CDATA[\,"BUCKET_TS","INTERCO_MBPS","PGA_ALLOC","READ_IOPS","READ_MBPS","TEMP_ALLOC","WRITE_IOPS","WRITE_MBPS"]]></DATA_MAP_COLNAMES>
            <DATA_MAP_SERIES><![CDATA[\,Read IOPS,Write IOPS,,]]></DATA_MAP_SERIES>
            <Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
            <DATA_MAP_COUNT><![CDATA[4]]></DATA_MAP_COUNT>
            <STYLE><![CDATA[Default]]></STYLE>
            <TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
            <Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
            <PLOT_SERIES_OPTIONS_LINE_WIDTH><![CDATA[\,THIN,THIN,THICKER,THICKER,THICKER]]></PLOT_SERIES_OPTIONS_LINE_WIDTH>
            <Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
            <DATA_MAP_VALUES><![CDATA[\,"READ_IOPS","WRITE_IOPS",,]]></DATA_MAP_VALUES>
            <Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
            <PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
            <Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
            <SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
        </CustomValues>
        <query>
            <sql><![CDATA[with
ash_samp as (
    select
        extract(second from (sample_time 
                            - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 60 * extract(minute from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 3600 * extract(hour from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 86400 * extract(day from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
            as obs_end_s,
        delta_time / 1000000        as delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        gv$active_session_history
    where
        ( ( inst_id             = :INST_ID
            and session_id      = :SID
            and session_serial# = :SESSION_SERIAL# )
          or
          ( qc_instance_id         = :INST_ID
            and qc_session_id      = :SID
            and qc_session_serial# = :SESSION_SERIAL# ) 
        )
        and sample_time between 
                cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
                and (select
                        cast(max(gm.last_refresh_time) as timestamp)
                    from
                        gv$sql_monitor gm
                    where
                        (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                        and gm.sql_id = :SQL_ID
                        and gm.sql_exec_id = :SQL_EXEC_ID
                        and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'))
        and delta_time > 0
),
ash_samp_2 as (
    select
        (select
            greatest(1, ceil( greatest(1, floor(avail_ash_sec))
                               / least(150, greatest(1, floor(avail_ash_sec))) * 20 ) / 20)
        from
            (select
                max( extract( day from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 86400
                   + extract( hour from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 3600
                   + extract( minute from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 60
                   + extract( second from
                         cast(gm.last_refresh_time as timestamp) 
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     )
                   )  as avail_ash_sec
            from
                gv$ash_info ai,
                gv$sql_monitor gm
            where
                ai.inst_id = gm.inst_id
                and (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                and gm.sql_id = :SQL_ID
                and gm.sql_exec_id = :SQL_EXEC_ID
                and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS')
            )
        )                           as bucket_width_s,
        obs_end_s - delta_s         as obs_start_s,
        obs_end_s,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp
),
ash_samp_3 as (
    select
        bucket_width_s,
        floor(obs_start_s / bucket_width_s)                                         as obs_start_bucket, 
        obs_start_s - floor(obs_start_s / bucket_width_s) * bucket_width_s          as obs_start_offset,
        floor(obs_end_s / bucket_width_s)                                           as obs_end_bucket,
        obs_end_s - floor(obs_end_s / bucket_width_s) * bucket_width_s              as obs_end_offset,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp_2
),
ash_samp_4 as (
    select
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket,
        case
            when obs_start_bucket < obs_end_bucket
            then (bucket_width_s - obs_start_offset) / delta_s   
            else 1
        end                                                 as start_bucket_weight,
        case
            when obs_start_bucket + 1 < obs_end_bucket
            then bucket_width_s / delta_s
            else 0
        end                                                 as inner_bucket_weight,
        case
            when obs_start_bucket < obs_end_bucket
            then obs_end_offset / delta_s
            else 0
        end                                                 as end_bucket_weight,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp_3
),
ash_bucket_grp as (
    select
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket,
        obs_end_bucket - obs_start_bucket + 1                   as obs_spanned_buckets,
        --
        sum(delta_read_io_requests * start_bucket_weight)       as delta_read_io_req_start,
        sum(delta_read_io_requests * inner_bucket_weight)       as delta_read_io_req_inner,
        sum(delta_read_io_requests * end_bucket_weight)         as delta_read_io_req_end,
        --
        sum(delta_write_io_requests * start_bucket_weight)      as delta_write_io_req_start, 
        sum(delta_write_io_requests * inner_bucket_weight)      as delta_write_io_req_inner, 
        sum(delta_write_io_requests * end_bucket_weight)        as delta_write_io_req_end, 
        --
        sum(delta_read_io_bytes * start_bucket_weight)          as delta_read_io_bytes_start, 
        sum(delta_read_io_bytes * inner_bucket_weight)          as delta_read_io_bytes_inner, 
        sum(delta_read_io_bytes * end_bucket_weight)            as delta_read_io_bytes_end, 
        --
        sum(delta_write_io_bytes * start_bucket_weight)         as delta_write_io_bytes_start,
        sum(delta_write_io_bytes * inner_bucket_weight)         as delta_write_io_bytes_inner,
        sum(delta_write_io_bytes * end_bucket_weight)           as delta_write_io_bytes_end,
        --
        sum(delta_interconnect_io_bytes * start_bucket_weight)  as delta_interco_io_bytes_start, 
        sum(delta_interconnect_io_bytes * inner_bucket_weight)  as delta_interco_io_bytes_inner, 
        sum(delta_interconnect_io_bytes * end_bucket_weight)    as delta_interco_io_bytes_end, 
        --
        sum(pga_allocated * delta_s * start_bucket_weight)      as pga_allocated_start, 
        sum(pga_allocated * delta_s * inner_bucket_weight)      as pga_allocated_inner, 
        sum(pga_allocated * delta_s * end_bucket_weight)        as pga_allocated_end, 
        --
        sum(temp_space_allocated * delta_s * start_bucket_weight)   as temp_space_allocated_start,
        sum(temp_space_allocated * delta_s * inner_bucket_weight)   as temp_space_allocated_inner,
        sum(temp_space_allocated * delta_s * end_bucket_weight)     as temp_space_allocated_end
    from
        ash_samp_4
    group by
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket
),
ash_all_bucket_grp as (
    select
        a.bucket_width_s,
        b.column_value as bucket_num,
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_read_io_req_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_read_io_req_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_read_io_req_inner
            end)                                                    as delta_read_io_req,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_write_io_req_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_write_io_req_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_write_io_req_inner
            end)                                                    as delta_write_io_req,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_read_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_read_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_read_io_bytes_inner
            end)                                                    as delta_read_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_write_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_write_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_write_io_bytes_inner
            end)                                                    as delta_write_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_interco_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_interco_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_interco_io_bytes_inner
            end)                                                    as delta_interco_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.pga_allocated_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.pga_allocated_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.pga_allocated_inner
            end)                                                    as pga_allocated,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.temp_space_allocated_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.temp_space_allocated_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.temp_space_allocated_inner
            end)                                                    as temp_space_allocated
    from
        ash_bucket_grp a,
        table(cast(multiset(
                select a.obs_start_bucket + (level - 1)  as bucket_num
                from dual
                connect by level <= 1 + (a.obs_end_bucket - a.obs_start_bucket)
            ) as sys.odcinumberlist)) b
    group by
        a.bucket_width_s,
        b.column_value
    having
        b.column_value >= 0
)
select 
    cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
            + numtodsinterval(bucket_num * bucket_width_s, 'SECOND')        as bucket_ts,
    round( delta_read_io_req  / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_read_io_req  / bucket_width_s ), 0), 1)))) )  as read_iops,
    round( delta_write_io_req / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_write_io_req / bucket_width_s ), 0), 1)))) )  as write_iops,
    round( delta_read_io_bytes    / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_read_io_bytes    / bucket_width_s / power(2,20) ), 0), 1)))) )  as read_mbps,
    round( delta_write_io_bytes   / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_write_io_bytes   / bucket_width_s / power(2,20) ), 0), 1)))) )  as write_mbps,
    round( delta_interco_io_bytes / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_interco_io_bytes / bucket_width_s / power(2,20) ), 0), 1)))) )  as interco_mbps,
    round( pga_allocated          / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( pga_allocated          / bucket_width_s / power(2,20) ), 0), 1)))) )  as pga_alloc,
    round( temp_space_allocated   / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( temp_space_allocated   / bucket_width_s / power(2,20) ), 0), 1)))) )  as temp_alloc
from 
    ash_all_bucket_grp 
order by 
    bucket_num]]></sql>
            <binds>
                <bind id="SQL_EXEC_START">
                    <prompt><![CDATA[SQL_EXEC_START]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="INST_ID">
                    <prompt><![CDATA[INST_ID]]></prompt>
                    <tooltip><![CDATA[INST_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SID">
                    <prompt><![CDATA[SID]]></prompt>
                    <tooltip><![CDATA[SID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SESSION_SERIAL#">
                    <prompt><![CDATA[SESSION_SERIAL#]]></prompt>
                    <tooltip><![CDATA[SESSION_SERIAL#]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_ID">
                    <prompt><![CDATA[SQL_ID]]></prompt>
                    <tooltip><![CDATA[SQL_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_EXEC_ID">
                    <prompt><![CDATA[SQL_EXEC_ID]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
    </display>
    <display id="null" type="" style="Chart" enable="true">
        <name><![CDATA[Metrics: MBPS]]></name>
        <description><![CDATA[]]></description>
        <tooltip><![CDATA[]]></tooltip>
        <drillclass><![CDATA[]]></drillclass>
        <CustomValues>
            <PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
            <Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
            <Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
            <Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
            <PLOT_SERIES_OPTIONS_FITLINE_TYPE><![CDATA[\,NONE,NONE,NONE,NONE,NONE]]></PLOT_SERIES_OPTIONS_FITLINE_TYPE>
            <Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
            <LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
            <PLOT_SERIES_OPTIONS_COLOR><![CDATA[\,-16750849,-26368,-3394816,-16751002,-26368]]></PLOT_SERIES_OPTIONS_COLOR>
            <LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
            <XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
            <DATA_MAP_COLUMNS><![CDATA[\,"BUCKET_TS","BUCKET_TS","BUCKET_TS",,]]></DATA_MAP_COLUMNS>
            <Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
            <XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
            <XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
            <Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
            <TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
            <GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
            <PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
            <FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
            <PLOT_SERIES_OPTIONS_LINE_TYPE><![CDATA[\,LINE,LINE,LINE,LINE,LINE]]></PLOT_SERIES_OPTIONS_LINE_TYPE>
            <XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
            <DATA_MAP_COLNAMES><![CDATA[\,"BUCKET_TS","INTERCO_MBPS","PGA_ALLOC","READ_IOPS","READ_MBPS","TEMP_ALLOC","WRITE_IOPS","WRITE_MBPS"]]></DATA_MAP_COLNAMES>
            <DATA_MAP_SERIES><![CDATA[\,Interco Mb/s,Read Mb/s,Write Mb/s,,]]></DATA_MAP_SERIES>
            <Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
            <DATA_MAP_COUNT><![CDATA[5]]></DATA_MAP_COUNT>
            <STYLE><![CDATA[Default]]></STYLE>
            <TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
            <Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
            <PLOT_SERIES_OPTIONS_LINE_WIDTH><![CDATA[\,THINNEST,THIN,THIN,THICKER,THICKER]]></PLOT_SERIES_OPTIONS_LINE_WIDTH>
            <Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
            <DATA_MAP_VALUES><![CDATA[\,"INTERCO_MBPS","READ_MBPS","WRITE_MBPS",,]]></DATA_MAP_VALUES>
            <Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
            <PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
            <Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
            <SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
        </CustomValues>
        <query>
            <sql><![CDATA[with
ash_samp as (
    select
        extract(second from (sample_time 
                            - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 60 * extract(minute from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 3600 * extract(hour from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 86400 * extract(day from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
            as obs_end_s,
        delta_time / 1000000        as delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        gv$active_session_history
    where
        ( ( inst_id             = :INST_ID
            and session_id      = :SID
            and session_serial# = :SESSION_SERIAL# )
          or
          ( qc_instance_id         = :INST_ID
            and qc_session_id      = :SID
            and qc_session_serial# = :SESSION_SERIAL# ) 
        )
        and sample_time between 
                cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
                and (select
                        cast(max(gm.last_refresh_time) as timestamp)
                    from
                        gv$sql_monitor gm
                    where
                        (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                        and gm.sql_id = :SQL_ID
                        and gm.sql_exec_id = :SQL_EXEC_ID
                        and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'))
        and delta_time > 0
),
ash_samp_2 as (
    select
        (select
            greatest(1, ceil( greatest(1, floor(avail_ash_sec))
                               / least(150, greatest(1, floor(avail_ash_sec))) * 20 ) / 20)
        from
            (select
                max( extract( day from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 86400
                   + extract( hour from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 3600
                   + extract( minute from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 60
                   + extract( second from
                         cast(gm.last_refresh_time as timestamp) 
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     )
                   )  as avail_ash_sec
            from
                gv$ash_info ai,
                gv$sql_monitor gm
            where
                ai.inst_id = gm.inst_id
                and (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                and gm.sql_id = :SQL_ID
                and gm.sql_exec_id = :SQL_EXEC_ID
                and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS')
            )
        )                           as bucket_width_s,
        obs_end_s - delta_s         as obs_start_s,
        obs_end_s,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp
),
ash_samp_3 as (
    select
        bucket_width_s,
        floor(obs_start_s / bucket_width_s)                                         as obs_start_bucket, 
        obs_start_s - floor(obs_start_s / bucket_width_s) * bucket_width_s          as obs_start_offset,
        floor(obs_end_s / bucket_width_s)                                           as obs_end_bucket,
        obs_end_s - floor(obs_end_s / bucket_width_s) * bucket_width_s              as obs_end_offset,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp_2
),
ash_samp_4 as (
    select
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket,
        case
            when obs_start_bucket < obs_end_bucket
            then (bucket_width_s - obs_start_offset) / delta_s   
            else 1
        end                                                 as start_bucket_weight,
        case
            when obs_start_bucket + 1 < obs_end_bucket
            then bucket_width_s / delta_s
            else 0
        end                                                 as inner_bucket_weight,
        case
            when obs_start_bucket < obs_end_bucket
            then obs_end_offset / delta_s
            else 0
        end                                                 as end_bucket_weight,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp_3
),
ash_bucket_grp as (
    select
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket,
        obs_end_bucket - obs_start_bucket + 1                   as obs_spanned_buckets,
        --
        sum(delta_read_io_requests * start_bucket_weight)       as delta_read_io_req_start,
        sum(delta_read_io_requests * inner_bucket_weight)       as delta_read_io_req_inner,
        sum(delta_read_io_requests * end_bucket_weight)         as delta_read_io_req_end,
        --
        sum(delta_write_io_requests * start_bucket_weight)      as delta_write_io_req_start, 
        sum(delta_write_io_requests * inner_bucket_weight)      as delta_write_io_req_inner, 
        sum(delta_write_io_requests * end_bucket_weight)        as delta_write_io_req_end, 
        --
        sum(delta_read_io_bytes * start_bucket_weight)          as delta_read_io_bytes_start, 
        sum(delta_read_io_bytes * inner_bucket_weight)          as delta_read_io_bytes_inner, 
        sum(delta_read_io_bytes * end_bucket_weight)            as delta_read_io_bytes_end, 
        --
        sum(delta_write_io_bytes * start_bucket_weight)         as delta_write_io_bytes_start,
        sum(delta_write_io_bytes * inner_bucket_weight)         as delta_write_io_bytes_inner,
        sum(delta_write_io_bytes * end_bucket_weight)           as delta_write_io_bytes_end,
        --
        sum(delta_interconnect_io_bytes * start_bucket_weight)  as delta_interco_io_bytes_start, 
        sum(delta_interconnect_io_bytes * inner_bucket_weight)  as delta_interco_io_bytes_inner, 
        sum(delta_interconnect_io_bytes * end_bucket_weight)    as delta_interco_io_bytes_end, 
        --
        sum(pga_allocated * delta_s * start_bucket_weight)      as pga_allocated_start, 
        sum(pga_allocated * delta_s * inner_bucket_weight)      as pga_allocated_inner, 
        sum(pga_allocated * delta_s * end_bucket_weight)        as pga_allocated_end, 
        --
        sum(temp_space_allocated * delta_s * start_bucket_weight)   as temp_space_allocated_start,
        sum(temp_space_allocated * delta_s * inner_bucket_weight)   as temp_space_allocated_inner,
        sum(temp_space_allocated * delta_s * end_bucket_weight)     as temp_space_allocated_end
    from
        ash_samp_4
    group by
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket
),
ash_all_bucket_grp as (
    select
        a.bucket_width_s,
        b.column_value as bucket_num,
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_read_io_req_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_read_io_req_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_read_io_req_inner
            end)                                                    as delta_read_io_req,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_write_io_req_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_write_io_req_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_write_io_req_inner
            end)                                                    as delta_write_io_req,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_read_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_read_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_read_io_bytes_inner
            end)                                                    as delta_read_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_write_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_write_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_write_io_bytes_inner
            end)                                                    as delta_write_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_interco_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_interco_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_interco_io_bytes_inner
            end)                                                    as delta_interco_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.pga_allocated_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.pga_allocated_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.pga_allocated_inner
            end)                                                    as pga_allocated,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.temp_space_allocated_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.temp_space_allocated_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.temp_space_allocated_inner
            end)                                                    as temp_space_allocated
    from
        ash_bucket_grp a,
        table(cast(multiset(
                select a.obs_start_bucket + (level - 1)  as bucket_num
                from dual
                connect by level <= 1 + (a.obs_end_bucket - a.obs_start_bucket)
            ) as sys.odcinumberlist)) b
    group by
        a.bucket_width_s,
        b.column_value
    having
        b.column_value >= 0
)
select 
    cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
            + numtodsinterval(bucket_num * bucket_width_s, 'SECOND')        as bucket_ts,
    round( delta_read_io_req  / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_read_io_req  / bucket_width_s ), 0), 1)))) )  as read_iops,
    round( delta_write_io_req / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_write_io_req / bucket_width_s ), 0), 1)))) )  as write_iops,
    round( delta_read_io_bytes    / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_read_io_bytes    / bucket_width_s / power(2,20) ), 0), 1)))) )  as read_mbps,
    round( delta_write_io_bytes   / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_write_io_bytes   / bucket_width_s / power(2,20) ), 0), 1)))) )  as write_mbps,
    round( delta_interco_io_bytes / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_interco_io_bytes / bucket_width_s / power(2,20) ), 0), 1)))) )  as interco_mbps,
    round( pga_allocated          / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( pga_allocated          / bucket_width_s / power(2,20) ), 0), 1)))) )  as pga_alloc,
    round( temp_space_allocated   / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( temp_space_allocated   / bucket_width_s / power(2,20) ), 0), 1)))) )  as temp_alloc
from 
    ash_all_bucket_grp 
order by 
    bucket_num]]></sql>
            <binds>
                <bind id="SQL_EXEC_START">
                    <prompt><![CDATA[SQL_EXEC_START]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="INST_ID">
                    <prompt><![CDATA[INST_ID]]></prompt>
                    <tooltip><![CDATA[INST_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SID">
                    <prompt><![CDATA[SID]]></prompt>
                    <tooltip><![CDATA[SID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SESSION_SERIAL#">
                    <prompt><![CDATA[SESSION_SERIAL#]]></prompt>
                    <tooltip><![CDATA[SESSION_SERIAL#]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_ID">
                    <prompt><![CDATA[SQL_ID]]></prompt>
                    <tooltip><![CDATA[SQL_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_EXEC_ID">
                    <prompt><![CDATA[SQL_EXEC_ID]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
    </display>
    <display id="null" type="" style="Chart" enable="true">
        <name><![CDATA[Metrics: PGA, Temp]]></name>
        <description><![CDATA[]]></description>
        <tooltip><![CDATA[]]></tooltip>
        <drillclass><![CDATA[]]></drillclass>
        <CustomValues>
            <PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
            <Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
            <Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
            <Y2AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL><![CDATA[EUR_SYMBOL]]></Y2AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL>
            <Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
            <PLOT_SERIES_OPTIONS_FITLINE_TYPE><![CDATA[\,NONE,NONE,NONE,NONE,NONE]]></PLOT_SERIES_OPTIONS_FITLINE_TYPE>
            <Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
            <LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
            <PLOT_SERIES_OPTIONS_COLOR><![CDATA[\,-10079233,-16737793,-3394816,-16751002,-26368]]></PLOT_SERIES_OPTIONS_COLOR>
            <LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
            <XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
            <DATA_MAP_COLUMNS><![CDATA[\,"BUCKET_TS","BUCKET_TS",,]]></DATA_MAP_COLUMNS>
            <Y1AXIS_NUMBER_FORMATS.TYPE><![CDATA[NUMBER]]></Y1AXIS_NUMBER_FORMATS.TYPE>
            <Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
            <Y2AXIS_NUMBER_FORMATS.DECIMAL_PLACES><![CDATA[1]]></Y2AXIS_NUMBER_FORMATS.DECIMAL_PLACES>
            <XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
            <XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
            <Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
            <TYPE><![CDATA[LINE_VERT_ABS_2Y]]></TYPE>
            <GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
            <PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
            <FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
            <PLOT_SERIES_OPTIONS_LINE_TYPE><![CDATA[\,LINE,LINE,LINE,LINE,LINE]]></PLOT_SERIES_OPTIONS_LINE_TYPE>
            <XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
            <Y1AXIS_NUMBER_FORMATS.SCALE_FACTOR><![CDATA[NONE]]></Y1AXIS_NUMBER_FORMATS.SCALE_FACTOR>
            <Y2AXIS_NUMBER_FORMATS.TYPE><![CDATA[NUMBER]]></Y2AXIS_NUMBER_FORMATS.TYPE>
            <Y1AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL><![CDATA[EUR_SYMBOL]]></Y1AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL>
            <DATA_MAP_COLNAMES><![CDATA[\,"BUCKET_TS","INTERCO_MBPS","PGA_ALLOC","READ_IOPS","READ_MBPS","TEMP_ALLOC","WRITE_IOPS","WRITE_MBPS"]]></DATA_MAP_COLNAMES>
            <DATA_MAP_SERIES><![CDATA[\,PGA allocated (Mb),Temp allocated (Mb),,]]></DATA_MAP_SERIES>
            <Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
            <DATA_MAP_COUNT><![CDATA[4]]></DATA_MAP_COUNT>
            <STYLE><![CDATA[Default]]></STYLE>
            <TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
            <Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
            <Y2AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT><![CDATA[BRACKETED]]></Y2AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT>
            <Y1AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT><![CDATA[BRACKETED]]></Y1AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT>
            <PLOT_SERIES_OPTIONS_LINE_WIDTH><![CDATA[\,THIN,THIN,THIN,THICKER,THICKER]]></PLOT_SERIES_OPTIONS_LINE_WIDTH>
            <NUMBER_FORMATS.DECIMAL_PLACES><![CDATA[1]]></NUMBER_FORMATS.DECIMAL_PLACES>
            <Y1AXIS_NUMBER_FORMATS.DECIMAL_PLACES><![CDATA[1]]></Y1AXIS_NUMBER_FORMATS.DECIMAL_PLACES>
            <Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
            <DATA_MAP_VALUES><![CDATA[\,"PGA_ALLOC","TEMP_ALLOC",,]]></DATA_MAP_VALUES>
            <Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_NUMBER_FORMATS.SCALE_FACTOR><![CDATA[NONE]]></Y2AXIS_NUMBER_FORMATS.SCALE_FACTOR>
            <Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
            <PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
            <Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
            <SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
        </CustomValues>
        <query>
            <sql><![CDATA[with
ash_samp as (
    select
        extract(second from (sample_time 
                            - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 60 * extract(minute from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 3600 * extract(hour from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 86400 * extract(day from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
            as obs_end_s,
        delta_time / 1000000        as delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        gv$active_session_history
    where
        ( ( inst_id             = :INST_ID
            and session_id      = :SID
            and session_serial# = :SESSION_SERIAL# )
          or
          ( qc_instance_id         = :INST_ID
            and qc_session_id      = :SID
            and qc_session_serial# = :SESSION_SERIAL# ) 
        )
        and sample_time between 
                cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
                and (select
                        cast(max(gm.last_refresh_time) as timestamp)
                    from
                        gv$sql_monitor gm
                    where
                        (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                        and gm.sql_id = :SQL_ID
                        and gm.sql_exec_id = :SQL_EXEC_ID
                        and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'))
        and delta_time > 0
),
ash_samp_2 as (
    select
        (select
            greatest(1, ceil( greatest(1, floor(avail_ash_sec))
                               / least(150, greatest(1, floor(avail_ash_sec))) * 20 ) / 20)
        from
            (select
                max( extract( day from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 86400
                   + extract( hour from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 3600
                   + extract( minute from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 60
                   + extract( second from
                         cast(gm.last_refresh_time as timestamp) 
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     )
                   )  as avail_ash_sec
            from
                gv$ash_info ai,
                gv$sql_monitor gm
            where
                ai.inst_id = gm.inst_id
                and (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                and gm.sql_id = :SQL_ID
                and gm.sql_exec_id = :SQL_EXEC_ID
                and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS')
            )
        )                           as bucket_width_s,
        obs_end_s - delta_s         as obs_start_s,
        obs_end_s,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp
),
ash_samp_3 as (
    select
        bucket_width_s,
        floor(obs_start_s / bucket_width_s)                                         as obs_start_bucket, 
        obs_start_s - floor(obs_start_s / bucket_width_s) * bucket_width_s          as obs_start_offset,
        floor(obs_end_s / bucket_width_s)                                           as obs_end_bucket,
        obs_end_s - floor(obs_end_s / bucket_width_s) * bucket_width_s              as obs_end_offset,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp_2
),
ash_samp_4 as (
    select
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket,
        case
            when obs_start_bucket < obs_end_bucket
            then (bucket_width_s - obs_start_offset) / delta_s   
            else 1
        end                                                 as start_bucket_weight,
        case
            when obs_start_bucket + 1 < obs_end_bucket
            then bucket_width_s / delta_s
            else 0
        end                                                 as inner_bucket_weight,
        case
            when obs_start_bucket < obs_end_bucket
            then obs_end_offset / delta_s
            else 0
        end                                                 as end_bucket_weight,
        delta_s,
        delta_read_io_requests,
        delta_write_io_requests, 
        delta_read_io_bytes, 
        delta_write_io_bytes,
        delta_interconnect_io_bytes, 
        pga_allocated, 
        temp_space_allocated
    from
        ash_samp_3
),
ash_bucket_grp as (
    select
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket,
        obs_end_bucket - obs_start_bucket + 1                   as obs_spanned_buckets,
        --
        sum(delta_read_io_requests * start_bucket_weight)       as delta_read_io_req_start,
        sum(delta_read_io_requests * inner_bucket_weight)       as delta_read_io_req_inner,
        sum(delta_read_io_requests * end_bucket_weight)         as delta_read_io_req_end,
        --
        sum(delta_write_io_requests * start_bucket_weight)      as delta_write_io_req_start, 
        sum(delta_write_io_requests * inner_bucket_weight)      as delta_write_io_req_inner, 
        sum(delta_write_io_requests * end_bucket_weight)        as delta_write_io_req_end, 
        --
        sum(delta_read_io_bytes * start_bucket_weight)          as delta_read_io_bytes_start, 
        sum(delta_read_io_bytes * inner_bucket_weight)          as delta_read_io_bytes_inner, 
        sum(delta_read_io_bytes * end_bucket_weight)            as delta_read_io_bytes_end, 
        --
        sum(delta_write_io_bytes * start_bucket_weight)         as delta_write_io_bytes_start,
        sum(delta_write_io_bytes * inner_bucket_weight)         as delta_write_io_bytes_inner,
        sum(delta_write_io_bytes * end_bucket_weight)           as delta_write_io_bytes_end,
        --
        sum(delta_interconnect_io_bytes * start_bucket_weight)  as delta_interco_io_bytes_start, 
        sum(delta_interconnect_io_bytes * inner_bucket_weight)  as delta_interco_io_bytes_inner, 
        sum(delta_interconnect_io_bytes * end_bucket_weight)    as delta_interco_io_bytes_end, 
        --
        sum(pga_allocated * delta_s * start_bucket_weight)      as pga_allocated_start, 
        sum(pga_allocated * delta_s * inner_bucket_weight)      as pga_allocated_inner, 
        sum(pga_allocated * delta_s * end_bucket_weight)        as pga_allocated_end, 
        --
        sum(temp_space_allocated * delta_s * start_bucket_weight)   as temp_space_allocated_start,
        sum(temp_space_allocated * delta_s * inner_bucket_weight)   as temp_space_allocated_inner,
        sum(temp_space_allocated * delta_s * end_bucket_weight)     as temp_space_allocated_end
    from
        ash_samp_4
    group by
        bucket_width_s,
        obs_start_bucket, 
        obs_end_bucket
),
ash_all_bucket_grp as (
    select
        a.bucket_width_s,
        b.column_value as bucket_num,
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_read_io_req_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_read_io_req_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_read_io_req_inner
            end)                                                    as delta_read_io_req,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_write_io_req_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_write_io_req_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_write_io_req_inner
            end)                                                    as delta_write_io_req,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_read_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_read_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_read_io_bytes_inner
            end)                                                    as delta_read_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_write_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_write_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_write_io_bytes_inner
            end)                                                    as delta_write_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.delta_interco_io_bytes_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.delta_interco_io_bytes_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.delta_interco_io_bytes_inner
            end)                                                    as delta_interco_io_bytes,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.pga_allocated_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.pga_allocated_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.pga_allocated_inner
            end)                                                    as pga_allocated,
        --
        sum(case
                when b.column_value = a.obs_start_bucket    then a.temp_space_allocated_start
                when obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket   then a.temp_space_allocated_end
                when obs_spanned_buckets >= 3 
                    and b.column_value > a.obs_start_bucket
                    and b.column_value < a.obs_end_bucket   then a.temp_space_allocated_inner
            end)                                                    as temp_space_allocated
    from
        ash_bucket_grp a,
        table(cast(multiset(
                select a.obs_start_bucket + (level - 1)  as bucket_num
                from dual
                connect by level <= 1 + (a.obs_end_bucket - a.obs_start_bucket)
            ) as sys.odcinumberlist)) b
    group by
        a.bucket_width_s,
        b.column_value
    having
        b.column_value >= 0
)
select 
    cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
            + numtodsinterval(bucket_num * bucket_width_s, 'SECOND')        as bucket_ts,
    round( delta_read_io_req  / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_read_io_req  / bucket_width_s ), 0), 1)))) )  as read_iops,
    round( delta_write_io_req / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_write_io_req / bucket_width_s ), 0), 1)))) )  as write_iops,
    round( delta_read_io_bytes    / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_read_io_bytes    / bucket_width_s / power(2,20) ), 0), 1)))) )  as read_mbps,
    round( delta_write_io_bytes   / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_write_io_bytes   / bucket_width_s / power(2,20) ), 0), 1)))) )  as write_mbps,
    round( delta_interco_io_bytes / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( delta_interco_io_bytes / bucket_width_s / power(2,20) ), 0), 1)))) )  as interco_mbps,
    round( pga_allocated          / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( pga_allocated          / bucket_width_s / power(2,20) ), 0), 1)))) )  as pga_alloc,
    round( temp_space_allocated   / bucket_width_s / power(2,20) , greatest(0, 2 - floor(log(10, nvl(nullif(abs( temp_space_allocated   / bucket_width_s / power(2,20) ), 0), 1)))) )  as temp_alloc
from 
    ash_all_bucket_grp 
order by 
    bucket_num]]></sql>
            <binds>
                <bind id="SQL_EXEC_START">
                    <prompt><![CDATA[SQL_EXEC_START]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="INST_ID">
                    <prompt><![CDATA[INST_ID]]></prompt>
                    <tooltip><![CDATA[INST_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SID">
                    <prompt><![CDATA[SID]]></prompt>
                    <tooltip><![CDATA[SID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SESSION_SERIAL#">
                    <prompt><![CDATA[SESSION_SERIAL#]]></prompt>
                    <tooltip><![CDATA[SESSION_SERIAL#]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_ID">
                    <prompt><![CDATA[SQL_ID]]></prompt>
                    <tooltip><![CDATA[SQL_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_EXEC_ID">
                    <prompt><![CDATA[SQL_EXEC_ID]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
    </display>
    <display id="null" type="" style="Chart" enable="true">
        <name><![CDATA[Metrics: CPU/DB time]]></name>
        <description><![CDATA[]]></description>
        <tooltip><![CDATA[]]></tooltip>
        <drillclass><![CDATA[]]></drillclass>
        <CustomValues>
            <PLOT_HGRID_WIDTH><![CDATA[THINNER]]></PLOT_HGRID_WIDTH>
            <Y1AXIS_SCALE_INCREMENT><![CDATA[10.0]]></Y1AXIS_SCALE_INCREMENT>
            <Y2AXIS_SCALE_MAXIMUM><![CDATA[80.0]]></Y2AXIS_SCALE_MAXIMUM>
            <Y2AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL><![CDATA[EUR_SYMBOL]]></Y2AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL>
            <Y1AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y1AXIS_LINE_WIDTH>
            <PLOT_SERIES_OPTIONS_FITLINE_TYPE><![CDATA[\,NONE,NONE,NONE,NONE,NONE]]></PLOT_SERIES_OPTIONS_FITLINE_TYPE>
            <Y1AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y1AXIS_TITLE_ALIGNMENT>
            <LEGEND_LOCATION><![CDATA[AUTOMATIC]]></LEGEND_LOCATION>
            <PLOT_SERIES_OPTIONS_COLOR><![CDATA[\,-16737997,-10066330,-3394816,-16751002,-26368]]></PLOT_SERIES_OPTIONS_COLOR>
            <LEGEND_ALIGNMENT><![CDATA[LEFT]]></LEGEND_ALIGNMENT>
            <XAXIS_LINE_WIDTH><![CDATA[THINNEST]]></XAXIS_LINE_WIDTH>
            <DATA_MAP_COLUMNS><![CDATA[\,"BUCKET_TS","BUCKET_TS",]]></DATA_MAP_COLUMNS>
            <Y1AXIS_NUMBER_FORMATS.TYPE><![CDATA[NUMBER]]></Y1AXIS_NUMBER_FORMATS.TYPE>
            <Y1AXIS_SCALE_MAXIMUM><![CDATA[60.0]]></Y1AXIS_SCALE_MAXIMUM>
            <Y2AXIS_NUMBER_FORMATS.DECIMAL_PLACES><![CDATA[1]]></Y2AXIS_NUMBER_FORMATS.DECIMAL_PLACES>
            <XAXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></XAXIS_TITLE_ALIGNMENT>
            <XAXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></XAXIS_TICK_LABEL_ROTATE>
            <Y1AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y1AXIS_LOGARITHMIC_BASE>
            <TYPE><![CDATA[LINE_VERT_ABS]]></TYPE>
            <GRID_WIDTH><![CDATA[THINNER]]></GRID_WIDTH>
            <PLOT_DATALABELS_BAR_POSITION><![CDATA[ABOVE]]></PLOT_DATALABELS_BAR_POSITION>
            <FOOTNOTE_ALIGNMENT><![CDATA[LEFT]]></FOOTNOTE_ALIGNMENT>
            <PLOT_SERIES_OPTIONS_LINE_TYPE><![CDATA[\,LINE,LINE,LINE,LINE,LINE]]></PLOT_SERIES_OPTIONS_LINE_TYPE>
            <XAXIS_TICK_LABEL_SKIP_MODE><![CDATA[AUTOMATIC]]></XAXIS_TICK_LABEL_SKIP_MODE>
            <Y1AXIS_NUMBER_FORMATS.SCALE_FACTOR><![CDATA[NONE]]></Y1AXIS_NUMBER_FORMATS.SCALE_FACTOR>
            <Y2AXIS_NUMBER_FORMATS.TYPE><![CDATA[NUMBER]]></Y2AXIS_NUMBER_FORMATS.TYPE>
            <Y1AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL><![CDATA[EUR_SYMBOL]]></Y1AXIS_NUMBER_FORMATS.CURRENCY_SYMBOL>
            <DATA_MAP_COLNAMES><![CDATA[\,"BUCKET_TS","CPU_PS","DBTIME_PS"]]></DATA_MAP_COLNAMES>
            <DATA_MAP_SERIES><![CDATA[\,CPU time (s),DB time (s),]]></DATA_MAP_SERIES>
            <Y2AXIS_LOGARITHMIC_BASE><![CDATA[BASE_10]]></Y2AXIS_LOGARITHMIC_BASE>
            <DATA_MAP_COUNT><![CDATA[3]]></DATA_MAP_COUNT>
            <STYLE><![CDATA[Default]]></STYLE>
            <TITLE_ALIGNMENT><![CDATA[LEFT]]></TITLE_ALIGNMENT>
            <Y2AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y2AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_SCALE_MINIMUM><![CDATA[10.0]]></Y2AXIS_SCALE_MINIMUM>
            <Y2AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT><![CDATA[BRACKETED]]></Y2AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT>
            <Y1AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT><![CDATA[BRACKETED]]></Y1AXIS_NUMBER_FORMATS.NEGATIVE_NUMBER_FORMAT>
            <PLOT_SERIES_OPTIONS_LINE_WIDTH><![CDATA[\,THIN,THINNER,THIN,THICKER,THICKER]]></PLOT_SERIES_OPTIONS_LINE_WIDTH>
            <NUMBER_FORMATS.DECIMAL_PLACES><![CDATA[2]]></NUMBER_FORMATS.DECIMAL_PLACES>
            <Y1AXIS_NUMBER_FORMATS.DECIMAL_PLACES><![CDATA[1]]></Y1AXIS_NUMBER_FORMATS.DECIMAL_PLACES>
            <Y2AXIS_LINE_WIDTH><![CDATA[THINNEST]]></Y2AXIS_LINE_WIDTH>
            <DATA_MAP_VALUES><![CDATA[\,"CPU_PS","DBTIME_PS",]]></DATA_MAP_VALUES>
            <Y1AXIS_TICK_LABEL_ROTATE><![CDATA[HORIZONTAL]]></Y1AXIS_TICK_LABEL_ROTATE>
            <Y2AXIS_NUMBER_FORMATS.SCALE_FACTOR><![CDATA[NONE]]></Y2AXIS_NUMBER_FORMATS.SCALE_FACTOR>
            <Y2AXIS_SCALE_INCREMENT><![CDATA[20.0]]></Y2AXIS_SCALE_INCREMENT>
            <PLOT_VGRID_WIDTH><![CDATA[THINNER]]></PLOT_VGRID_WIDTH>
            <Y2AXIS_TITLE_ALIGNMENT><![CDATA[CENTER]]></Y2AXIS_TITLE_ALIGNMENT>
            <SUBTITLE_ALIGNMENT><![CDATA[LEFT]]></SUBTITLE_ALIGNMENT>
        </CustomValues>
        <query>
            <sql><![CDATA[with
ash_samp as (
    select
        extract(second from (sample_time 
                            - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 60 * extract(minute from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 3600 * extract(hour from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
                + 86400 * extract(day from (sample_time 
                                    - cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)))
            as obs_end_s,
        tm_delta_time / 1000000     as tm_delta_s,
        tm_delta_cpu_time,
        tm_delta_db_time
    from
        gv$active_session_history
    where
        ( ( inst_id             = :INST_ID
            and session_id      = :SID
            and session_serial# = :SESSION_SERIAL# )
          or
          ( qc_instance_id         = :INST_ID
            and qc_session_id      = :SID
            and qc_session_serial# = :SESSION_SERIAL# ) 
        )
        and sample_time between 
                cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
                and (select
                        cast(max(gm.last_refresh_time) as timestamp)
                    from
                        gv$sql_monitor gm
                    where
                        (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                        and gm.sql_id = :SQL_ID
                        and gm.sql_exec_id = :SQL_EXEC_ID
                        and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS'))
        and tm_delta_time > 0
),
ash_samp_2 as (
    select
        (select
            greatest(1, ceil( greatest(1, floor(avail_ash_sec))
                               / least(150, greatest(1, floor(avail_ash_sec))) * 20 ) / 20)
        from
            (select
                max( extract( day from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 86400
                   + extract( hour from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 3600
                   + extract( minute from
                         cast(gm.last_refresh_time as timestamp)
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     ) * 60
                   + extract( second from
                         cast(gm.last_refresh_time as timestamp) 
                         - greatest( cast(gm.sql_exec_start as timestamp)
                                   , ai.oldest_sample_time )
                     )
                   )  as avail_ash_sec
            from
                gv$ash_info ai,
                gv$sql_monitor gm
            where
                ai.inst_id = gm.inst_id
                and (gm.inst_id = :INST_ID or gm.px_qcinst_id = :INST_ID)
                and gm.sql_id = :SQL_ID
                and gm.sql_exec_id = :SQL_EXEC_ID
                and gm.sql_exec_start = to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS')
            )
        )                           as bucket_width_s,
        obs_end_s - tm_delta_s      as tm_obs_start_s,
        obs_end_s,
        tm_delta_s,
        tm_delta_cpu_time,
        tm_delta_db_time
    from
        ash_samp
),
ash_samp_3 as (
    select
        bucket_width_s,
        floor(tm_obs_start_s / bucket_width_s)                                      as tm_obs_start_bucket, 
        tm_obs_start_s - floor(tm_obs_start_s / bucket_width_s) * bucket_width_s    as tm_obs_start_offset, 
        floor(obs_end_s / bucket_width_s)                                           as obs_end_bucket,
        obs_end_s - floor(obs_end_s / bucket_width_s) * bucket_width_s              as obs_end_offset,
        tm_delta_s,
        tm_delta_cpu_time,
        tm_delta_db_time
    from
        ash_samp_2
),
ash_samp_4 as (
    select
        bucket_width_s,
        tm_obs_start_bucket, 
        obs_end_bucket,
        case
            when tm_obs_start_bucket < obs_end_bucket
            then (bucket_width_s - tm_obs_start_offset) / tm_delta_s   
            else 1
        end                                                 as tm_start_bucket_weight,
        case
            when tm_obs_start_bucket + 1 < obs_end_bucket
            then bucket_width_s / tm_delta_s
            else 0
        end                                                 as tm_inner_bucket_weight,
        case
            when tm_obs_start_bucket < obs_end_bucket
            then obs_end_offset / tm_delta_s   
            else 0
        end                                                 as tm_end_bucket_weight,
        tm_delta_cpu_time,
        tm_delta_db_time
    from
        ash_samp_3
),
ash_bucket_grp as (
    select
        bucket_width_s,
        tm_obs_start_bucket, 
        obs_end_bucket,
        obs_end_bucket - tm_obs_start_bucket + 1                as tm_obs_spanned_buckets,
        --
        sum(tm_delta_cpu_time * tm_start_bucket_weight)         as tm_delta_cpu_time_start,
        sum(tm_delta_cpu_time * tm_inner_bucket_weight)         as tm_delta_cpu_time_inner,
        sum(tm_delta_cpu_time * tm_end_bucket_weight)           as tm_delta_cpu_time_end,
        --
        sum(tm_delta_db_time * tm_start_bucket_weight)          as tm_delta_db_time_start,
        sum(tm_delta_db_time * tm_inner_bucket_weight)          as tm_delta_db_time_inner,
        sum(tm_delta_db_time * tm_end_bucket_weight)            as tm_delta_db_time_end
    from
        ash_samp_4
    group by
        bucket_width_s,
        tm_obs_start_bucket, 
        obs_end_bucket
),
ash_all_bucket_grp as (
    select
        a.bucket_width_s,
        b.column_value as bucket_num,
        sum(case
                when b.column_value = a.tm_obs_start_bucket     then a.tm_delta_cpu_time_start
                when tm_obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket       then a.tm_delta_cpu_time_end
                when tm_obs_spanned_buckets >= 3 
                    and b.column_value > a.tm_obs_start_bucket
                    and b.column_value < a.obs_end_bucket       then a.tm_delta_cpu_time_inner
            end)                                                    as tm_delta_cpu_time,
        --
        sum(case
                when b.column_value = a.tm_obs_start_bucket     then a.tm_delta_db_time_start
                when tm_obs_spanned_buckets >= 2
                    and b.column_value = a.obs_end_bucket       then a.tm_delta_db_time_end
                when tm_obs_spanned_buckets >= 3 
                    and b.column_value > a.tm_obs_start_bucket
                    and b.column_value < a.obs_end_bucket       then a.tm_delta_db_time_inner
            end)                                                    as tm_delta_db_time
    from
        ash_bucket_grp a,
        table(cast(multiset(
                select a.tm_obs_start_bucket + (level - 1)  as bucket_num
                from dual
                connect by level <= 1 + (a.obs_end_bucket - a.tm_obs_start_bucket)
            ) as sys.odcinumberlist)) b
    group by
        a.bucket_width_s,
        b.column_value
    having
        b.column_value >= 0
)
select 
    cast(to_date(:SQL_EXEC_START, 'YYYY-MM-DD HH24:MI:SS') as timestamp)
            + numtodsinterval(bucket_num * bucket_width_s, 'SECOND')        as bucket_ts,
    round( tm_delta_cpu_time / power(10, 6) / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( tm_delta_cpu_time / power(10, 6) / bucket_width_s ), 0), 1)))) )  as cpu_ps,
    round( tm_delta_db_time  / power(10, 6) / bucket_width_s , greatest(0, 2 - floor(log(10, nvl(nullif(abs( tm_delta_db_time  / power(10, 6) / bucket_width_s ), 0), 1)))) )  as dbtime_ps
from 
    ash_all_bucket_grp 
order by 
    bucket_num]]></sql>
            <binds>
                <bind id="SQL_EXEC_START">
                    <prompt><![CDATA[SQL_EXEC_START]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_START]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="INST_ID">
                    <prompt><![CDATA[INST_ID]]></prompt>
                    <tooltip><![CDATA[INST_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SID">
                    <prompt><![CDATA[SID]]></prompt>
                    <tooltip><![CDATA[SID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SESSION_SERIAL#">
                    <prompt><![CDATA[SESSION_SERIAL#]]></prompt>
                    <tooltip><![CDATA[SESSION_SERIAL#]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_ID">
                    <prompt><![CDATA[SQL_ID]]></prompt>
                    <tooltip><![CDATA[SQL_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
                <bind id="SQL_EXEC_ID">
                    <prompt><![CDATA[SQL_EXEC_ID]]></prompt>
                    <tooltip><![CDATA[SQL_EXEC_ID]]></tooltip>
                    <value><![CDATA[NULL_VALUE]]></value>
                    <bracket><![CDATA[null]]></bracket>
                </bind>
            </binds>
        </query>
    </display>
</display>
</folder>
</displays>
