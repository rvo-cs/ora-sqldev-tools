<?xml version="1.0" encoding="UTF-8" ?>
<displays>
<display id="760631de-0167-1000-8001-c0a83801ccfc" type="" style="Table" enable="true">
	<name><![CDATA[Data Dict - Enhanced table viewer (v2)]]></name>
	<description><![CDATA[Warning: this is a 3-level report; don't edit in SQL Developer!]]></description>
	<tooltip><![CDATA[]]></tooltip>
	<drillclass><![CDATA[]]></drillclass>
	<CustomValues>
		<TYPE><![CDATA[horizontal]]></TYPE>
	</CustomValues>
	<query>
		<sql><![CDATA[with 
table_like_in as (
    select
        :TABLE_LIKE_LIST  as str,
        '\s* ( ( [^"[:space:]] "? )+ | " ( [^"] )* " ) \s*'  as rex
    from
        dual
),
table_pattrn_raw as (
    select
        regexp_substr(a.str, a.rex, 1, level, 'x')  as tok
    from
        table_like_in a
    connect by
        regexp_instr (a.str, a.rex, 1, level, 0, 'x') > 0
),
table_pattrn_trimmed as (
    select
        regexp_replace(regexp_replace(b.tok, '^\s*'), '\s*$')  as tok
    from
        table_pattrn_raw b
),
table_pattrn_dequoted as (
    select 
        regexp_replace(c.tok, '^" (.*) "$', '\1', 1, 1, 'nx')  as tok
    from
        table_pattrn_trimmed c
),
table_like_list as (
    select /*+ materialize */
        d.tok  as table_like
    from
        table_pattrn_dequoted d
    where
        d.tok is not null
),
matching_tables as (
    select
        listagg(b.table_like, ' | ') within group (order by b.table_like)
            as matching_patterns,
        a.owner, a.table_name
    from
        dba_tables a,
        table_like_list b
    where
        (:OWNER_LIKE is null or upper(a.owner) like upper(:OWNER_LIKE) escape '\') 
        and (:OWNER_RE is null or regexp_like(a.owner, :OWNER_RE, 'i'))
        and upper(a.table_name) like upper(b.table_like) escape '\'
    group by
        a.owner, a.table_name
)
select /*+ noparallel */
    b.owner,
    b.table_name,
    b.num_rows,
    b.blocks,
    b.avg_row_len,
    b.iot_type,
    b.iot_name,
    b.status,
    b.partitioned,
    b.nested,
    b.temporary,
    b.duration,
    b.sample_size,
    b.last_analyzed,
    c.comments,
    a.matching_patterns
from
    matching_tables a,
    dba_tables b,
    dba_tab_comments c
where
    a.owner = b.owner
    and a.table_name = b.table_name
    and a.owner = c.owner (+)
    and a.table_name = c.table_name (+)
order by
    b.owner,
    b.table_name]]></sql>
		<binds>
			<bind id="TABLE_LIKE_LIST">
				<prompt><![CDATA[Table like?]]></prompt>
				<tooltip><![CDATA[LIKE pattern (escape '\') for matching tables -- optionally: list of pattens separated by blanks]]></tooltip>
				<value><![CDATA[foo%]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="OWNER_LIKE">
				<prompt><![CDATA[Owner like?]]></prompt>
				<tooltip><![CDATA[LIKE pattern for matching the name of the table owner]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
			<bind id="OWNER_RE">
				<prompt><![CDATA[Owner regexp?]]></prompt>
				<tooltip><![CDATA[OWNER_RE]]></tooltip>
				<value><![CDATA[NULL_VALUE]]></value>
				<bracket><![CDATA[null]]></bracket>
			</bind>
		</binds>
	</query>
		<pdf version="VERSION_1_7" compression="CONTENT">
			<docproperty title="" author="" subject="" keywords="" />
			<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
			<column>
				<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
				<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
				<blob blob="NONE" zip="false" />
			</column>
			<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
			<header enable="false" generatedate="false">
				<data>
				
					
					
					null																			</data>
			</header>
			<footer enable="false" generatedate="false">
				<data value="null" />
			</footer>
			<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
		</pdf>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Table details]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[vertical]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    --a.num_rows,
    --a.blocks,
    --a.avg_row_len,
    a.partitioned,
    a.row_movement,
    a.tablespace_name,
    a.iot_name,
    a.iot_type,
    a.nested,
    a.temporary,
    a.duration,
    a.cluster_name,
    a.cluster_owner,
    a.status,
    a.dropped,
    a.read_only,
    a.backed_up,
    a.degree,
    a.buffer_pool,
    a.cache,
    a.flash_cache,
    a.result_cache,
    a.cell_flash_cache,
    a.pct_free,
    a.pct_increase,
    a.pct_used,
    a.ini_trans,
    a.initial_extent,
    a.next_extent,
    a.min_extents,
    a.max_extents,
    a.freelists,
    a.freelist_groups,
    a.instances,
    a.logging,
    a.monitoring,
    a.compression,
    a.compress_for,
    a.dependencies,
    a.segment_created,
    --a.num_freelist_blocks,
    --a.empty_blocks,
    --a.avg_space,
    --a.avg_space_freelist_blocks,
    --a.chain_cnt,
    --a.sample_size,
    --a.last_analyzed,
    a.skip_corrupt,
    a.table_lock,
    --a.global_stats,
    --a.user_stats,
    c.created,
    c.last_ddl_time,
    b.comments
from
    dba_tables a,
    dba_tab_comments b,
    dba_objects c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner (+)
    and a.table_name = b.table_name (+)
    and a.owner = c.owner (+)
    and a.table_name = c.object_name (+)
    and c.object_type (+) = 'TABLE']]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						
						
						null																							</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Table stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[vertical]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    b.stattype_locked,
    b.num_rows,
    b.blocks,
    b.avg_row_len,
    a.partitioned,
    b.avg_space,
    b.avg_space_freelist_blocks,
    b.num_freelist_blocks,
    b.empty_blocks,
    b.avg_cached_blocks,
    b.avg_cache_hit_ratio,
    b.chain_cnt,
    b.sample_size,
    b.last_analyzed,
    b.global_stats,
    b.user_stats,
    b.stale_stats,
    c.inserts,
    c.updates,
    c.deletes,
    c.truncated,
    c.drop_segments,
    c.timestamp
from
    dba_tables a,
    dba_tab_statistics b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and b.partition_name is null
    and b.subpartition_name is null
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and c.partition_name (+) is null
    and c.subpartition_name (+) is null]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						
						
						null																							</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Stats prefs]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[with
all_stat_pref ( name
              , min_version
              , is_table_pref
              , is_global_pref
              ) 
as (
    select /*+ no_merge */ 'APPROXIMATE_NDV_ALGORITHM'      , '12.02'  , 'Y'    , 'Y'   from dual
    union all       select 'AUTO_STAT_EXTENSIONS'           , '12.02'  , 'Y'    , 'Y'   from dual
    --union all       select 'AUTO_TASK_STATUS'               , '19.00'  , null   , 'Y'   from dual   /* high-freq. auto stats collection (EE-ES only!) */
    --union all       select 'AUTO_TASK_MAX_RUN_TIME'         , '19.00'  , null   , 'Y'   from dual   /* high-freq. auto stats collection (EE-ES only!) */
    --union all       select 'AUTO_TASK_INTERVAL'             , '19.00'  , null   , 'Y'   from dual   /* high-freq. auto stats collection (EE-ES only!) */
    union all       select 'AUTOSTATS_TARGET'               , '11.02'  , null   , 'Y'   from dual
    union all       select 'CASCADE'                        , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'CONCURRENT'                     , '11.02'  , null   , 'Y'   from dual
    --union all       select 'COORDINATOR_TRIGGER_SHARD'      , '19.00'  , 'Y'    , 'Y'   from dual   /* If using sharding only */
    union all       select 'DEGREE'                         , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'ESTIMATE_PERCENT'               , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'GLOBAL_TEMP_TABLE_STATS'        , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'GRANULARITY'                    , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'INCREMENTAL'                    , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'INCREMENTAL_LEVEL'              , '12.01'  , 'Y'    , null  from dual
    union all       select 'INCREMENTAL_STALENESS'          , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'METHOD_OPT'                     , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'OPTIONS'                        , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'NO_INVALIDATE'                  , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'PREFERENCE_OVERRIDES_PARAMETER' , '12.02'  , 'Y'    , 'Y'   from dual
    union all       select 'PUBLISH'                        , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'ROOT_TRIGGER_PDB'               , '19.00'  , 'Y'    , 'Y'   from dual   /* if using App. PDB only */
    union all       select 'STALE_PERCENT'                  , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'STAT_CATEGORY'                  , '12.01'  , 'Y'    , 'Y'   from dual
    union all       select 'TABLE_CACHED_BLOCKS'            , '11.02'  , 'Y'    , 'Y'   from dual
    union all       select 'WAIT_TIME_TO_UPDATE_STATS'      , '12.02'  , 'Y'    , 'Y'   from dual
),
v_instance_version (mm_nn_version) as (
    select /*+ no_merge */
        lpad(regexp_substr(version, '([^\.]+)', 1, 1), 2, '0') 
            || '.' || lpad(regexp_substr(version, '([^\.]+)', 1, 2), 2, '0')
    from
        v$instance
),
global_stat_pref (pref_name) as (
    select
        a.name
    from
        all_stat_pref a,
        v_instance_version b
    where
        a.is_global_pref = 'Y'
        and a.min_version <= b.mm_nn_version
),
table_stat_pref (pref_name) as (
    select
        a.name
    from
        all_stat_pref a,
        v_instance_version b
    where
        a.is_table_pref = 'Y'
        and a.min_version <= b.mm_nn_version
)
select /*+ noparallel */
    null as owner,
    null as table_name,
    a.pref_name as preference_name,
    dbms_stats.get_prefs(a.pref_name) as preference_value
from
    global_stat_pref a
union all
select /*+ noparallel */
    :OWNER as owner,
    :TABLE_NAME as table_name,
    a.pref_name as preference_name,
    c.preference_value
from
    table_stat_pref a,
    dba_tab_stat_prefs c
where
    :OWNER = c.owner (+)
    and :TABLE_NAME = c.table_name (+)
    and a.pref_name = c.preference_name (+)
order by
    owner nulls first, 
    table_name nulls first, 
    preference_name]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						
						
						null																							</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Partitioning]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[vertical]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.partitioning_type,
    a.interval,
    a.subpartitioning_type,
    a.partition_count,
    (
        select count(*) from dba_tab_subpartitions b
        where b.table_owner = a.owner and b.table_name = a.table_name
    ) 
    as subpartition_count,
    a.partitioning_key_count,
    (
        select
            listagg(b.column_name || case when c.virtual_column = 'YES' then ' (*)' end, ', ')
                    within group (order by b.column_position) as list_cols
        from
            dba_part_key_columns b,
            dba_tab_cols c
        where
            b.owner = c.owner
            and b.name = c.table_name
            and b.column_name = c.column_name
            and b.object_type = 'TABLE'
            and b.owner = a.owner
            and b.name = a.table_name
    ) 
    as partition_keys,
    a.subpartitioning_key_count,
    (
        select
            listagg(b.column_name || case when c.virtual_column = 'YES' then ' (*)' end, ', ')
                    within group (order by b.column_position) as list_cols
        from
            dba_subpart_key_columns b,
            dba_tab_cols c
        where
            b.owner = c.owner
            and b.name = c.table_name
            and b.column_name = c.column_name
            and b.object_type = 'TABLE'
            and b.owner = a.owner
            and b.name = a.table_name
    ) 
    as subpartition_keys,
    a.status,
    a.is_nested,
    a.def_subpartition_count,
    a.def_tablespace_name,
    a.def_logging,
    a.def_compression,
    a.def_compress_for,
    a.def_segment_creation,
    a.def_pct_free,
    a.def_pct_used,
    a.def_ini_trans,
    a.def_max_trans,
    a.def_initial_extent,
    a.def_next_extent,
    a.def_min_extents,
    a.def_max_extents,
    a.def_max_size,
    a.def_pct_increase,
    a.def_freelists,
    a.def_freelist_groups,
    a.def_buffer_pool,
    a.def_flash_cache,
    a.def_cell_flash_cache,
    a.ref_ptn_constraint_name
from
    dba_part_tables a
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						
						null																	</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Segments]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    nvl(b.tablespace_name, '-- Grand total --') as tablespace_name,
    nvl(b.segment_type, nvl2(b.tablespace_name, '-- Total for TBS --', null)) as segment_type, 
    b.segment_subtype,
    b.owner, b.segment_name,
    count(*) as cnt_seg,
    round(sum(b.bytes) / power(2, 20), 1) as total_size_mb,
    sum(b.blocks) as total_blocks,
    b.lob_column_name
from
    (select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tables b
    where
        b.owner = :OWNER
        and b.table_name = :TABLE_NAME
        and a.owner = b.owner
        and a.segment_name = b.table_name
        and a.segment_type in ('TABLE', 'TABLE PARTITION', 'TABLE SUBPARTITION')
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tables b
    where
        b.owner = :OWNER
        and b.table_name = :TABLE_NAME
        and a.owner = b.owner
        and a.segment_name = b.cluster_name
        and a.segment_type = 'CLUSTER'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_indexes b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.index_type <> 'LOB'
        and a.owner = b.owner
        and a.segment_name = b.index_name
        and a.segment_type in ('INDEX', 'INDEX PARTITION', 'INDEX SUBPARTITION')
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b
    where
        b.owner = :OWNER
        and b.table_name = :TABLE_NAME
        and a.owner = b.owner
        and a.segment_name = b.segment_name
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b
    where
        b.owner = :OWNER
        and b.table_name = :TABLE_NAME
        and a.owner = b.owner
        and a.segment_name = b.index_name
    ) b
group by 
    grouping sets (
        (tablespace_name,
        segment_type, segment_subtype,
        owner, segment_name, lob_column_name),
        (tablespace_name), 
        ()
)
order by
    nvl2(b.tablespace_name, 0, 1), nvl2(b.segment_type, 0, 1),
    b.tablespace_name,
    case when b.segment_type like 'CLUS%' then 0 
        when b.segment_type like 'TABLE%' then 1
        when b.segment_type like 'INDEX%' and b.segment_name not like 'SYS_IL%' then 2
        when b.segment_type like 'INDEX%' and b.segment_name like 'SYS_IL%' then 4
        when b.segment_type like 'LOB%' then 3 end,
    b.segment_type, b.segment_subtype, 
    b.owner, b.segment_name, b.lob_column_name]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Columns]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    a.data_default,
    a.data_type_mod,
    a.data_type_owner,
    decode(a.hidden_column, 'NO', 'N', 'YES', 'Y') as hidden_column,
    decode(a.virtual_column, 'NO', 'N', 'YES', 'Y') as virtual_column,
    a.segment_column_id,
    a.internal_column_id,
    a.qualified_col_name,
    b.comments,
    h.cnt_indexes,
    h.index_list
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
order by
    a.internal_column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
        <query>
			<sql><![CDATA[select
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    a.data_default,
    a.data_type_mod,
    a.data_type_owner,
    decode(a.hidden_column, 'NO', 'N', 'YES', 'Y') as hidden_column,
    decode(a.virtual_column, 'NO', 'N', 'YES', 'Y') as virtual_column,
    a.segment_column_id,
    a.internal_column_id,
    a.qualified_col_name,
    b.comments,
    h.cnt_indexes,
    h.index_list
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
order by
    a.column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		</queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Constraints]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.constraint_name,
    a.constraint_type,
    a.search_condition,
    a.r_owner,
    a.r_constraint_name,
    a.delete_rule,
    a.status,
    a.deferrable,
    a.deferred,
    a.validated,
    a.generated,
    a.bad,
    a.rely,
    a.last_change,
    a.index_owner,
    a.index_name,
    (select listagg(b.column_name, ', ') within group (order by b.position)
    from dba_cons_columns b 
    where 
        b.owner = a.owner 
        and b.constraint_name = a.constraint_name 
        and b.table_name = a.table_name
    ) as column_list
from 
    dba_constraints a
where 
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
order by
    decode(a.constraint_type, 'P', 1, 'U', 2, 'R', 3, 'C', 4, 99),
    a.constraint_name]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Indexes]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner, 
    a.index_name, 
    a.index_type, 
    a.visibility,
    a.degree,
    a.uniqueness, 
    a.compression, 
    a.prefix_length, 
    a.partitioned,
    d.locality,
    a.tablespace_name, 
    a.logging, 
    a.status, 
    a.num_rows, 
    a.blevel, 
    a.leaf_blocks, 
    a.distinct_keys, 
    a.avg_leaf_blocks_per_key, 
    a.avg_data_blocks_per_key, 
    a.clustering_factor,
    case when b.blocks > 0 then round(a.clustering_factor / b.blocks, 2) end as scaled_clustr_factor,
    a.sample_size,
    a.last_analyzed, 
    a.temporary, 
    a.generated, 
    a.global_stats, 
    a.funcidx_status, 
    a.join_index, 
    a.pct_threshold, 
    a.include_column, 
    a.pct_direct_access, 
    a.iot_redundant_pkey_elim, 
    a.dropped, 
    a.orphaned_entries, 
    a.indexing,
    (select
        listagg(e.column_name 
                    || case when e.descend = 'DESC' then ' desc' end, ', ')
            within group (order by e.column_position)
    from
        dba_ind_columns e
    where
        e.index_owner = a.owner
        and e.index_name = a.index_name
    ) as ind_columns,
    c.column_name as lob_col_name
from 
    dba_indexes a,
    dba_tables b,
    dba_lobs c,
    dba_part_indexes d
where
    a.table_owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.table_owner = b.owner
    and a.table_name = b.table_name
    and a.table_owner = c.owner (+)
    and a.table_name = c.table_name (+)
    and a.index_name = c.index_name (+)
    and a.owner = d.owner (+)
    and a.index_name = d.index_name (+)
order by
    decode(index_type, 'CLUSTER', 1, 'IOT - TOP', 2, 'DOMAIN', 3, 'LOB', 100, 10),
    index_name
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query>
			<sql><![CDATA[select
    a.owner, 
    a.index_name, 
    a.index_type, 
    a.visibility,
    a.degree,
    a.uniqueness, 
    a.compression, 
    a.prefix_length, 
    a.partitioned,
    d.locality,
    a.tablespace_name, 
    a.logging, 
    a.status, 
    a.num_rows, 
    a.blevel, 
    a.leaf_blocks, 
    a.distinct_keys, 
    a.avg_leaf_blocks_per_key, 
    a.avg_data_blocks_per_key, 
    a.clustering_factor,
    case when b.blocks > 0 then round(a.clustering_factor / b.blocks, 2) end as scaled_clustr_factor,
    a.sample_size,
    a.last_analyzed, 
    a.temporary, 
    a.generated, 
    a.global_stats, 
    a.funcidx_status, 
    a.join_index, 
    a.pct_threshold, 
    a.include_column, 
    a.pct_direct_access, 
    a.iot_redundant_pkey_elim, 
    a.dropped, 
    (select
        listagg(e.column_name 
                    || case when e.descend = 'DESC' then ' desc' end, ', ')
            within group (order by e.column_position)
    from
        dba_ind_columns e
    where
        e.index_owner = a.owner
        and e.index_name = a.index_name
    ) as ind_columns,
    c.column_name as lob_col_name
from 
    dba_indexes a,
    dba_tables b,
    dba_lobs c,
    dba_part_indexes d
where
    a.table_owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.table_owner = b.owner
    and a.table_name = b.table_name
    and a.table_owner = c.owner (+)
    and a.table_name = c.table_name (+)
    and a.index_name = c.index_name (+)
    and a.owner = d.owner (+)
    and a.index_name = d.index_name (+)
order by
    decode(index_type, 'CLUSTER', 1, 'IOT - TOP', 2, 'DOMAIN', 3, 'LOB', 100, 10),
    index_name
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Col usage]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    l.equality_preds, 
    l.equijoin_preds, 
    l.nonequijoin_preds, 
    l.range_preds, 
    l.like_preds, 
    l.null_preds, 
    l.timestamp,
    b.comments,
    h.cnt_indexes,
    h.index_list    
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h,
    (select 
        i.owner,
        j.table_name,
        j.column_name,
        k.equality_preds, 
        k.equijoin_preds, 
        k.nonequijoin_preds, 
        k.range_preds, 
        k.like_preds, 
        k.null_preds, 
        k.timestamp
    from
        sys.col_usage$ k,
        dba_objects i,
        dba_tab_cols j
    where
        k.obj# = i.object_id
        and i.object_type = 'TABLE'
        and i.owner = :OWNER
        and i.object_name = :TABLE_NAME
        and j.owner = i.owner
        and j.table_name = i.object_name
        and j.internal_column_id = k.intcol#
    ) l
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
    and  a.owner = l.owner (+)
    and  a.table_name = l.table_name (+)
    and  a.column_name = l.column_name (+)
order by
    a.internal_column_id]]></sql>
		</query>
		<query>
			<sql><![CDATA[select
    a.owner,
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    case when e.column_name is not null then 'Y' end as is_pk,
    case when h.column_name is not null then 'Y' end as is_idx,
    l.equality_preds, 
    l.equijoin_preds, 
    l.nonequijoin_preds, 
    l.range_preds, 
    l.like_preds, 
    l.null_preds, 
    l.timestamp,
    b.comments,
    h.cnt_indexes,
    h.index_list    
from
    dba_tab_cols a,
    dba_col_comments b,
    (select
        c.owner,
        c.table_name,
        d.column_name
    from 
        dba_constraints c,
        dba_cons_columns d
    where 
        c.owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.constraint_type = 'P'
        and c.owner = d.owner
        and c.table_name = d.table_name
        and c.constraint_name = d.constraint_name
    ) e,
    (select
        f.table_owner,
        f.table_name,
        g.column_name,
        count(*) as cnt_indexes,
        listagg(dbms_assert.enquote_name(g.index_owner) 
                || '.' || dbms_assert.enquote_name(g.index_name)
                || ' (' || g.column_position || ')', ', ') 
                within group (order by g.index_owner, g.index_name) as index_list
    from
        dba_indexes f,
        dba_ind_columns g
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and g.index_owner = f.owner
        and g.index_name = f.index_name
    group by
        f.table_owner,
        f.table_name,
        g.column_name
    ) h,
    (select 
        i.owner,
        j.table_name,
        j.column_name,
        k.equality_preds, 
        k.equijoin_preds, 
        k.nonequijoin_preds, 
        k.range_preds, 
        k.like_preds, 
        k.null_preds, 
        k.timestamp
    from
        sys.col_usage$ k,
        dba_objects i,
        dba_tab_cols j
    where
        k.obj# = i.object_id
        and i.object_type = 'TABLE'
        and i.owner = :OWNER
        and i.object_name = :TABLE_NAME
        and j.owner = i.owner
        and j.table_name = i.object_name
        and j.internal_column_id = k.intcol#
    ) l
where
    a.owner = :OWNER
    and  a.table_name = :TABLE_NAME
    and  a.owner = b.owner (+)
    and  a.table_name = b.table_name (+)
    and  a.column_name = b.column_name (+)
    and  a.owner = e.owner (+)
    and  a.table_name = e.table_name (+)
    and  a.column_name = e.column_name (+)
    and  a.owner = h.table_owner (+)
    and  a.table_name = h.table_name (+)
    and  a.column_name = h.column_name (+)
    and  a.owner = l.owner (+)
    and  a.table_name = l.table_name (+)
    and  a.column_name = l.column_name (+)
order by
    a.column_id]]></sql>
		</query>
        </queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Tab modifs]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
        a.table_owner, a.table_name, a.partition_name, a.subpartition_name,
        a.inserts,
        a.updates,
        a.deletes,
        a.timestamp,
        a.truncated,
        a.drop_segments
    from 
        dba_tab_modifications a
    where
        a.table_owner = :OWNER
        and a.table_name = :TABLE_NAME
    order by
        a.table_owner, a.table_name, a.partition_name, a.subpartition_name]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Col stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    dba_tab_col_statistics b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and a.column_name = b.column_name
order by
    a.column_id]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Part stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select  /*+ noparallel */
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name) as part_hv,
    b.interval,
    b.compression,
    b.compress_for,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    --a.scan_rate, /* 12.2, external tables only */
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    a.scope,
    c.inserts, c.deletes, c.updates, 
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_partitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'PARTITION'
    and a.partition_name is not null
    and a.subpartition_name is null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_position = b.partition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and c.subpartition_name (+) is null
order by
    a.object_type, a.partition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query>
			<sql><![CDATA[select 
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name) as part_hv,
    b.interval,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    c.inserts, c.deletes, c.updates, 
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_partitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'PARTITION'
    and a.partition_name is not null
    and a.subpartition_name is null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_position = b.partition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and c.subpartition_name (+) is null
order by
    a.object_type, a.partition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Part col stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    b.partition_name as part_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    dba_part_col_statistics b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and a.column_name = b.column_name
    and b.partition_name = :PARTITION_NAME
order by
    a.column_id]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Part segments]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    nvl(b.tablespace_name, '-- Grand total --') as tablespace_name,
    nvl(b.segment_type, nvl2(b.tablespace_name, '-- Total for TBS --', null)) as segment_type, 
    b.segment_subtype,
    b.owner, b.segment_name,
    count(*) as cnt_seg,
    round(sum(b.bytes) / power(2, 20), 1) as total_size_mb,
    sum(b.blocks) as total_blocks,
    b.lob_column_name
from
    (select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tab_partitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.subpartition_count = 0
        and b.table_owner = a.owner
        and b.table_name = a.segment_name
        and b.partition_name = a.partition_name
        and a.segment_type = 'TABLE PARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tab_subpartitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.table_owner = a.owner
        and b.table_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'TABLE SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_ind_partitions b,
        dba_indexes c,
        dba_part_indexes d,
        dba_tab_partitions e
    where
        e.table_owner = :OWNER
        and e.table_name = :TABLE_NAME
        and e.partition_name = :PARTITION_NAME
        and e.table_owner = c.table_owner
        and e.table_name = c.table_name
        and c.index_type <> 'LOB'
        and c.owner = d.owner
        and c.index_name = d.index_name
        and d.locality = 'LOCAL'
        and d.subpartitioning_key_count = 0
        and c.owner = b.index_owner
        and c.index_name = b.index_name
        and e.partition_position = b.partition_position
        and b.index_owner = a.owner
        and b.index_name = a.segment_name
        and b.partition_name = a.partition_name
        and a.segment_type = 'INDEX PARTITION'
    union all
    select /*+ no_query_transformation leading(f d e c b a) */
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_ind_subpartitions b,
        dba_ind_partitions c,
        dba_indexes d,
        dba_part_indexes e,
        dba_tab_partitions f
    where
        f.table_owner = :OWNER
        and f.table_name = :TABLE_NAME
        and f.partition_name = :PARTITION_NAME
        and f.table_owner = d.table_owner
        and f.table_name = d.table_name
        and d.index_type <> 'LOB'
        and d.owner = e.owner
        and d.index_name = e.index_name
        and e.locality = 'LOCAL'
        and e.subpartitioning_key_count > 0
        and d.owner = c.index_owner
        and d.index_name = c.index_name
        and f.partition_position = c.partition_position
        and c.index_owner = b.index_owner
        and c.index_name = b.index_name
        and c.partition_name = b.partition_name
        and b.index_owner = a.owner
        and b.index_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lob_partitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.composite = 'NO'
        and b.table_owner = a.owner
        and b.lob_name = a.segment_name
        and b.lob_partition_name = a.partition_name
        and a.segment_type = 'LOB PARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        c.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lob_subpartitions b,
        dba_lob_partitions c
    where
        c.table_owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.partition_name = :PARTITION_NAME
        and c.composite = 'YES'
        and c.table_owner = b.table_owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and c.lob_partition_name = b.lob_partition_name
        and b.table_owner = a.owner
        and b.lob_name = a.segment_name
        and b.lob_subpartition_name = a.partition_name
        and a.segment_type = 'LOB SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b,
        dba_lob_partitions c
    where
        c.table_owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.partition_name = :PARTITION_NAME
        and c.composite = 'NO'
        and c.table_owner = b.owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and b.owner = a.owner
        and b.index_name = a.segment_name
        and c.lob_indpart_name = a.partition_name
        and a.segment_type = 'INDEX PARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, a.partition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b,
        dba_lob_subpartitions c,
        dba_lob_partitions d
    where
        d.table_owner = :OWNER
        and d.table_name = :TABLE_NAME
        and d.partition_name = :PARTITION_NAME
        and d.composite = 'YES'
        and d.table_owner = c.table_owner
        and d.table_name = c.table_name
        and d.column_name = c.column_name
        and d.lob_partition_name = c.lob_partition_name
        and c.table_owner = b.owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and b.owner = a.owner
        and b.index_name = a.segment_name
        and c.lob_indsubpart_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    ) b
group by 
    grouping sets (
        (tablespace_name,
        segment_type, segment_subtype,
        owner, segment_name, lob_column_name),
        (tablespace_name), 
        ()
)
order by
    nvl2(b.tablespace_name, 0, 1), nvl2(b.segment_type, 0, 1),
    b.tablespace_name,
    case when b.segment_type like 'TABLE%' then 1
        when b.segment_type like 'INDEX%' and b.segment_name not like 'SYS_IL%' then 2
        when b.segment_type like 'INDEX%' and b.segment_name like 'SYS_IL%' then 4
        when b.segment_type like 'LOB%' then 3 end,
    b.segment_type, b.segment_subtype, 
    b.owner, b.segment_name, b.lob_column_name]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Subpart stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select /*+ noparallel */
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    a.subpartition_position as subpart_pos, 
    a.subpartition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name, p_subpart_name => b.subpartition_name) as subpart_hv,
    b.compression,
    b.compress_for,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    --a.scan_rate,  /* 12.2, external tables only */
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    a.scope,
    c.inserts, c.deletes, c.updates,
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_subpartitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'SUBPARTITION'
    and a.partition_name = :PARTITION_NAME
    and a.subpartition_name is not null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_name = b.partition_name
    and a.subpartition_position = b.subpartition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and a.subpartition_name = c.subpartition_name (+)
order by
    a.object_type, a.partition_position, a.subpartition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PARTITION_NAME">
					<prompt><![CDATA[PARTITION_NAME]]></prompt>
					<tooltip><![CDATA[PARTITION_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query>
			<sql><![CDATA[select 
    a.owner, a.table_name, 
    a.partition_position as part_pos, 
    a.partition_name, 
    a.subpartition_position as subpart_pos, 
    a.subpartition_name, 
    c##pkg_pub_partition_helper.high_value_as_vc2(
            p_owner => b.table_owner, p_table_name => b.table_name,
            p_part_name => b.partition_name, p_subpart_name => b.subpartition_name) as subpart_hv,
    a.num_rows, 
    a.blocks, 
    a.empty_blocks, 
    a.avg_space, 
    a.chain_cnt, 
    a.avg_row_len, 
    a.avg_space_freelist_blocks, 
    a.num_freelist_blocks, 
    a.avg_cached_blocks, 
    a.avg_cache_hit_ratio, 
    a.sample_size, 
    a.last_analyzed, 
    a.global_stats, 
    a.user_stats, 
    a.stattype_locked, 
    a.stale_stats, 
    c.inserts, c.deletes, c.updates,
    c.drop_segments, c.truncated, c.timestamp
from
    dba_tab_statistics a,
    dba_tab_subpartitions b,
    dba_tab_modifications c
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.object_type = 'SUBPARTITION'
    and a.partition_name = :PARTITION_NAME
    and a.subpartition_name is not null
    and a.owner = b.table_owner
    and a.table_name = b.table_name
    and a.partition_name = b.partition_name
    and a.subpartition_position = b.subpartition_position
    and a.owner = c.table_owner (+)
    and a.table_name = c.table_name (+)
    and a.partition_name = c.partition_name (+)
    and a.subpartition_name = c.subpartition_name (+)
order by
    a.object_type, a.partition_position, a.subpartition_position]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="PARTITION_NAME">
					<prompt><![CDATA[PARTITION_NAME]]></prompt>
					<tooltip><![CDATA[PARTITION_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Subpart col stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    b.subpartition_name as subpart_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    dba_subpart_col_statistics b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.owner = b.owner
    and a.table_name = b.table_name
    and a.column_name = b.column_name
    and b.subpartition_name = :SUBPARTITION_NAME
order by
    column_id]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Subpart segments]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    nvl(b.tablespace_name, '-- Grand total --') as tablespace_name,
    nvl(b.segment_type, nvl2(b.tablespace_name, '-- Total for TBS --', null)) as segment_type, 
    b.segment_subtype,
    b.owner, b.segment_name,
    count(*) as cnt_seg,
    round(sum(b.bytes) / power(2, 20), 1) as total_size_mb,
    sum(b.blocks) as total_blocks,
    b.lob_column_name
from
    (select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, 
        b.subpartition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_tab_subpartitions b
    where
        b.table_owner = :OWNER
        and b.table_name = :TABLE_NAME
        and b.partition_name = :PARTITION_NAME
        and b.subpartition_name = :SUBPARTITION_NAME
        and b.table_owner = a.owner
        and b.table_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'TABLE SUBPARTITION'
    union all
    select /*+ no_query_transformation leading(g f d e c b a) */
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, 
        g.subpartition_name,
        null as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_ind_subpartitions b,
        dba_ind_partitions c,
        dba_indexes d,
        dba_part_indexes e,
        dba_tab_partitions f,
        dba_tab_subpartitions g
    where
        g.table_owner = :OWNER
        and g.table_name = :TABLE_NAME
        and g.partition_name = :PARTITION_NAME
        and g.subpartition_name = :SUBPARTITION_NAME
        and g.table_owner = f.table_owner
        and g.table_name = f.table_name
        and g.partition_name = f.partition_name
        and f.table_owner = d.table_owner
        and f.table_name = d.table_name
        and d.index_type <> 'LOB'
        and d.owner = e.owner
        and d.index_name = e.index_name
        and e.locality = 'LOCAL'
        and e.subpartitioning_key_count > 0
        and d.owner = c.index_owner
        and d.index_name = c.index_name
        and f.partition_position = c.partition_position
        and c.index_owner = b.index_owner
        and c.index_name = b.index_name
        and c.partition_name = b.partition_name
        and g.subpartition_position = b.subpartition_position
        and b.index_owner = a.owner
        and b.index_name = a.segment_name
        and b.subpartition_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name,
        b.subpartition_name,
        c.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lob_subpartitions b,
        dba_lob_partitions c
    where
        c.table_owner = :OWNER
        and c.table_name = :TABLE_NAME
        and c.partition_name = :PARTITION_NAME
        and c.composite = 'YES'
        and c.table_owner = b.table_owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and c.lob_partition_name = b.lob_partition_name
        and b.subpartition_name = :SUBPARTITION_NAME
        and b.table_owner = a.owner
        and b.lob_name = a.segment_name
        and b.lob_subpartition_name = a.partition_name
        and a.segment_type = 'LOB SUBPARTITION'
    union all
    select 
        a.tablespace_name,
        a.segment_type, a.segment_subtype,
        a.owner, a.segment_name, 
        c.subpartition_name,
        b.column_name as lob_column_name,
        a.bytes, a.blocks
    from
        dba_segments a,
        dba_lobs b,
        dba_lob_subpartitions c,
        dba_lob_partitions d
    where
        d.table_owner = :OWNER
        and d.table_name = :TABLE_NAME
        and d.partition_name = :PARTITION_NAME
        and d.composite = 'YES'
        and d.table_owner = c.table_owner
        and d.table_name = c.table_name
        and d.column_name = c.column_name
        and d.lob_partition_name = c.lob_partition_name
        and c.subpartition_name = :SUBPARTITION_NAME
        and c.table_owner = b.owner
        and c.table_name = b.table_name
        and c.column_name = b.column_name
        and b.owner = a.owner
        and b.index_name = a.segment_name
        and c.lob_indsubpart_name = a.partition_name
        and a.segment_type = 'INDEX SUBPARTITION'
    ) b
group by 
    grouping sets (
        (tablespace_name,
        segment_type, segment_subtype,
        owner, segment_name, lob_column_name),
        (tablespace_name), 
        ()
)
order by
    nvl2(b.tablespace_name, 0, 1), nvl2(b.segment_type, 0, 1),
    b.tablespace_name,
    case when b.segment_type like 'TABLE%' then 1
        when b.segment_type like 'INDEX%' and b.segment_name not like 'SYS_IL%' then 2
        when b.segment_type like 'INDEX%' and b.segment_name like 'SYS_IL%' then 4
        when b.segment_type like 'LOB%' then 3 end,
    b.segment_type, b.segment_subtype, 
    b.owner, b.segment_name, b.lob_column_name]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	</display>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[All subpart stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[
select /*+ noparallel */ *
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        null as subpart_pos,
        null as subpartition_name,
        null as subpart_hv,
        b.compression,
        b.compress_for,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        --a.scan_rate,  /* 12.2, external tables only */
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        a.scope,
        c.inserts, c.deletes, c.updates, 
        c.drop_segments, c.truncated, c.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_modifications c
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'PARTITION'
        and a.partition_name is not null
        and a.subpartition_name is null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner (+)
        and a.table_name = c.table_name (+)
        and a.partition_name = c.partition_name (+)
        and c.subpartition_name (+) is null
    order by
        a.partition_position
    )
union all
select * 
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        a.subpartition_position as subpart_pos, 
        a.subpartition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => c.table_owner, p_table_name => c.table_name,
                p_part_name => c.partition_name, p_subpart_name => c.subpartition_name) as subpart_hv,
        c.compression,
        c.compress_for,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        --a.scan_rate,  /* 12.2, external tables only */
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        a.scope,
        d.inserts, d.deletes, d.updates, 
        d.drop_segments, d.truncated, d.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_subpartitions c,
        dba_tab_modifications d
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'SUBPARTITION'
        and a.partition_name is not null
        and a.subpartition_name is not null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner
        and a.table_name = c.table_name
        and a.partition_name = c.partition_name
        and a.subpartition_position = c.subpartition_position
        and a.owner = d.table_owner (+)
        and a.table_name = d.table_name (+)
        and a.partition_name = d.partition_name (+)
        and a.subpartition_name = d.subpartition_name (+)
    order by
        a.partition_position, a.subpartition_position
    )
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
        </query>
		<query>
			<sql><![CDATA[
select *
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        null as subpart_pos,
        null as subpartition_name,
        null as subpart_hv,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        c.inserts, c.deletes, c.updates, 
        c.drop_segments, c.truncated, c.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_modifications c
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'PARTITION'
        and a.partition_name is not null
        and a.subpartition_name is null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner (+)
        and a.table_name = c.table_name (+)
        and a.partition_name = c.partition_name (+)
        and c.subpartition_name (+) is null
    order by
        a.partition_position
    )
union all
select * 
from
    (select /*+ no_eliminate_oby */
        a.owner, a.table_name, 
        a.object_type, 
        a.partition_position as part_pos, 
        a.partition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => b.table_owner, p_table_name => b.table_name,
                p_part_name => b.partition_name) as part_hv,
        a.subpartition_position as subpart_pos, 
        a.subpartition_name, 
        c##pkg_pub_partition_helper.high_value_as_vc2(
                p_owner => c.table_owner, p_table_name => c.table_name,
                p_part_name => c.partition_name, p_subpart_name => c.subpartition_name) as subpart_hv,
        a.num_rows, 
        a.blocks, 
        a.empty_blocks, 
        a.avg_space, 
        a.chain_cnt, 
        a.avg_row_len, 
        a.avg_space_freelist_blocks, 
        a.num_freelist_blocks, 
        a.avg_cached_blocks, 
        a.avg_cache_hit_ratio, 
        a.sample_size, 
        a.last_analyzed, 
        a.global_stats, 
        a.user_stats, 
        a.stattype_locked, 
        a.stale_stats, 
        d.inserts, d.deletes, d.updates, 
        d.drop_segments, d.truncated, d.timestamp
    from
        dba_tab_statistics a,
        dba_tab_partitions b,
        dba_tab_subpartitions c,
        dba_tab_modifications d
    where
        a.owner = :OWNER
        and a.table_name = :TABLE_NAME
        and a.object_type = 'SUBPARTITION'
        and a.partition_name is not null
        and a.subpartition_name is not null
        and a.owner = b.table_owner
        and a.table_name = b.table_name
        and a.partition_position = b.partition_position
        and a.owner = c.table_owner
        and a.table_name = c.table_name
        and a.partition_name = c.partition_name
        and a.subpartition_position = c.subpartition_position
        and a.owner = d.table_owner (+)
        and a.table_name = d.table_name (+)
        and a.partition_name = d.partition_name (+)
        and a.subpartition_name = d.subpartition_name (+)
    order by
        a.partition_position, a.subpartition_position
    )
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Column stats]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select /*+ noparallel */
    a.table_name,
    :OBJECT_TYPE as object_type,
    b.part_name,
    a.column_id,
    a.column_name,
    case
        when a.data_type in ('CHAR', 'VARCHAR', 'VARCHAR2', 'NCHAR', 'NVARCHAR', 'NVARCHAR2')
            then lower(a.data_type) 
                    || '(' || a.char_length 
                    || decode(a.char_used, 'B', ' byte', 'C', ' char', null) || ')'
        when a.data_type = 'NUMBER' 
            then lower(a.data_type)
                    || case
                        when a.data_precision is null and a.data_scale is null then null
                        when a.data_precision is null and a.data_scale is not null 
                            then '(* ,' || a.data_scale || ')'
                        else '(' || a.data_precision || ',' || a.data_scale || ')' end
        when data_type = 'FLOAT' 
            then lower(a.data_type)
                    || case when a.data_precision is not null then '(' || a.data_precision || ')' end
        else lower(a.data_type) end
        as data_type,
    a.nullable,
    b.num_distinct,
    b.num_nulls,
    b.density,
    case
        when b.low_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.low_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.low_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.low_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.low_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.low_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.low_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.low_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.low_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.low_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.low_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.low_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.low_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.low_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.low_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.low_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.low_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as low_value_vc2,
    case
        when b.high_value is null 
        then cast(null as varchar2(50))
        --
        when a.data_type = 'NUMBER'
        then to_char(utl_raw.cast_to_number(b.high_value))
        --
        when a.data_type in ('VARCHAR2', 'CHAR')
        then to_char(utl_raw.cast_to_varchar2(b.high_value))
        --
        when a.data_type in ('NVARCHAR2', 'NCHAR')
        then to_char(utl_raw.cast_to_nvarchar2(b.high_value))
        --
        when a.data_type = 'BINARY_DOUBLE'
        then to_char(utl_raw.cast_to_binary_double(b.high_value))
        --
        when a.data_type = 'BINARY_FLOAT'
        then to_char(utl_raw.cast_to_binary_float(b.high_value))
        --
        when a.data_type = 'DATE'
        then 
            to_char(
                100 * (to_number(substr(b.high_value, 1, 2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    ||'.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    ||'.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    ||' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    ||':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
        --
        when regexp_like(a.data_type, '^ TIMESTAMP ( \(\d+\) )? (\s WITH (\s LOCAL)? \s TIME \s ZONE)? $', 'ix')
        then
            to_char(
                100 * (to_number(substr(b.high_value, 1 ,2), 'XX') - 100)   /* century (excess-100) */ 
                    + (to_number(substr(b.high_value, 3, 2), 'XX') - 100),  /* year in century (excess-100) */
                'FM0000')
                    || '.'|| to_char(to_number(substr(b.high_value, 5, 2), 'XX'), 'FM00')        /* month */
                    || '.'|| to_char(to_number(substr(b.high_value, 7, 2), 'XX'), 'FM00')        /* day */
                    || ' '|| to_char(to_number(substr(b.high_value, 9, 2), 'XX') - 1, 'FM00')    /* hours (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 11, 2), 'XX') - 1, 'FM00')   /* minutes (excess-1) */
                    || ':'|| to_char(to_number(substr(b.high_value, 13, 2), 'XX') - 1, 'FM00')   /* seconds (excess-1) */
                    || '.'|| to_char(nvl(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX'), 0), 'FM000000000')
                    || case when regexp_like(a.data_type, '\s WITH \s TIME \s ZONE $', 'ix') then ' UTC' end
        --
        when regexp_like(a.data_type, '^ INTERVAL \s YEAR ( \(\d+\) )? \s TO \s MONTH $', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || '-' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
        --
        when regexp_like(a.data_type, '^ INTERVAL \s DAY ( \(\d+\) )? \s TO \s SECOND', 'ix')
        then
            regexp_replace(
                to_char(to_number(substr(b.high_value, 1, 8), 'XXXXXXXX') - power(2,31), 'S000000000'),
                '^([-+])([0]+)(\d\d)', '\1\3'
            )
            || ' ' || to_char(abs(to_number(substr(b.high_value, 9, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 11, 2), 'XX') - 60), 'FM00')
            || ':' || to_char(abs(to_number(substr(b.high_value, 13, 2), 'XX') - 60), 'FM00')
            || '.' || to_char(abs(to_number(substr(b.high_value, 15, 8), 'XXXXXXXX') - power(2,31)), 'FM000000000')
    end as high_value_vc2,
    b.histogram,
    case when b.histogram <> 'NONE' then b.num_buckets end as num_buckets,
    b.avg_col_len,
    b.sample_size,
    b.user_stats,
    b.global_stats,
    b.last_analyzed,
    b.low_value as low_value_raw,
    b.high_value as high_value_raw
from
    dba_tab_cols a,
    (select
        partition_name as part_name,
        column_name,
        num_distinct,
        num_nulls,
        density,
        low_value,
        high_value,
        histogram,
        num_buckets,
        avg_col_len,
        sample_size,
        user_stats,
        global_stats,
        last_analyzed
    from
        dba_part_col_statistics
    where
        owner = :OWNER
        and table_name = :TABLE_NAME
        and partition_name = :PARTITION_NAME
        and :OBJECT_TYPE = 'PARTITION'
    union all
    select
        subpartition_name as part_name,
        column_name,
        num_distinct,
        num_nulls,
        density,
        low_value,
        high_value,
        histogram,
        num_buckets,
        avg_col_len,
        sample_size,
        user_stats,
        global_stats,
        last_analyzed
    from
        dba_subpart_col_statistics
    where
        owner = :OWNER
        and table_name = :TABLE_NAME
        and subpartition_name = :SUBPARTITION_NAME
        and :OBJECT_TYPE = 'SUBPARTITION'
    ) b
where
    a.owner = :OWNER
    and a.table_name = :TABLE_NAME
    and a.column_name = b.column_name
order by
    a.column_id]]></sql>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					
						null											</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[Grants]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
        <queries>
		<query minversion="12.1">
			<sql><![CDATA[select
    grantee
    , nvl((select 'Y' from dba_roles r where r.role = d.grantee), 'N')  as is_role
    , max(decode(rn, 1, privilege))
            || max(decode(rn, 2, ', ' || privilege))
            || max(decode(rn, 3, ', ' || privilege))
            || max(decode(rn, 4, ', ' || privilege))
            || max(decode(rn, 5, ', ' || privilege))
            || max(decode(rn, 6, ', ' || privilege))
            || max(decode(rn, 7, ', ' || privilege))
            || max(decode(rn, 8, ', ' || privilege))
            || max(decode(rn, 9, ', ' || privilege))
            || max(decode(rn, 10, ', ' || privilege))
            || max(decode(rn, 11, ', ' || privilege))
            || max(decode(rn, 12, ', ' || privilege))
            || max(decode(rn, 13, ', ' || privilege))
            || max(decode(rn, 14, ', ' || privilege))
            || max(decode(rn, 15, ', ' || privilege))
            || max(decode(rn, 16, ', ' || privilege))
            || /* 
                  This purposely raises ORA-01722 invalid number if there are 
                  more than 16 distinct privileges in the same group.
                */
               max(decode(rn, 17, to_char(to_number('too many privs!'))))
        as object_privs
    , owner
    , object_name 
            || case 
                when column_name is not null 
                then '.' || column_name
               end
        as object_name
    , object_type
    , grantable
    , hierarchy
    , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
from
    (select
        c.grantee
        , c.privilege
        , c.owner
        , c.object_type
        , c.object_name
        , c.column_name
        , c.grantable
        , c.hierarchy
        , c.common       /* DB version >= 12.1 */
        -- , c.inherited    /* DB version >= 12.2 */
        , /* Fancy ordering of privileges in the same group */ 
          row_number() over (
                partition by
                    c.grantee
                    , c.owner
                    , c.object_type
                    , c.object_name
                    , c.column_name
                    , c.grantable
                    , c.hierarchy
                    , c.common       /* DB version >= 12.1 */
                    -- , c.inherited    /* DB version >= 12.2 */
                order by
                    case c.object_type
                        when 'TABLE' 
                            then decode(c.privilege, 'ALTER', '1', 'READ', '2', 'SELECT', '3',
                                        'INSERT', '4', 'UPDATE', '5', 'DELETE', '6', c.privilege)
                        else
                            c.privilege
                    end)
            as rn
    from
        (select distinct  /* Note: each priv may have been granted
                             more than once by distinct grantors */
            a.grantee
            , a.privilege
            , b.owner
            , b.object_type
            , b.object_name
            , null as column_name
            , a.grantable
            , a.hierarchy
            , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_tab_privs a,
            dba_objects b
        where
            a.owner = b.owner
            and a.table_name = b.object_name
            and a.type = b.object_type   /* DB version >= 12.1 */
            and b.owner = :OWNER
            and b.object_type = 'TABLE'
            and b.object_name = :TABLE_NAME
        union all
        select distinct
            a.grantee
            , a.privilege
            , a.owner
            , 'TABLE COLUMN'    as object_type
            , a.table_name      as object_name
            , a.column_name
            , a.grantable
            , null              as hierarchy
            , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_col_privs a
        where
            a.owner = :OWNER
            and a.table_name = :TABLE_NAME
        ) c
    ) d
group by
    grantee
    , owner
    , object_type
    , object_name
    , column_name
    , grantable
    , hierarchy
    , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
order by
    owner
    , d.object_name
    , grantee
    , d.column_name  nulls first
    , object_privs
    , grantable
    , hierarchy
    , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
		<query>
			<sql><![CDATA[select
    grantee
    , nvl((select 'Y' from dba_roles r where r.role = d.grantee), 'N')  as is_role
    , max(decode(rn, 1, privilege))
            || max(decode(rn, 2, ', ' || privilege))
            || max(decode(rn, 3, ', ' || privilege))
            || max(decode(rn, 4, ', ' || privilege))
            || max(decode(rn, 5, ', ' || privilege))
            || max(decode(rn, 6, ', ' || privilege))
            || max(decode(rn, 7, ', ' || privilege))
            || max(decode(rn, 8, ', ' || privilege))
            || max(decode(rn, 9, ', ' || privilege))
            || max(decode(rn, 10, ', ' || privilege))
            || max(decode(rn, 11, ', ' || privilege))
            || max(decode(rn, 12, ', ' || privilege))
            || max(decode(rn, 13, ', ' || privilege))
            || max(decode(rn, 14, ', ' || privilege))
            || max(decode(rn, 15, ', ' || privilege))
            || max(decode(rn, 16, ', ' || privilege))
            || /* 
                  This purposely raises ORA-01722 invalid number if there are 
                  more than 16 distinct privileges in the same group.
                */
               max(decode(rn, 17, to_char(to_number('too many privs!'))))
        as object_privs
    , owner
    , object_name 
            || case 
                when column_name is not null 
                then '.' || column_name
               end
        as object_name
    , object_type
    , grantable
    , hierarchy
    -- , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
from
    (select
        c.grantee
        , c.privilege
        , c.owner
        , c.object_type
        , c.object_name
        , c.column_name
        , c.grantable
        , c.hierarchy
        -- , c.common       /* DB version >= 12.1 */
        -- , c.inherited    /* DB version >= 12.2 */
        , /* Fancy ordering of privileges in the same group */ 
          row_number() over (
                partition by
                    c.grantee
                    , c.owner
                    , c.object_type
                    , c.object_name
                    , c.column_name
                    , c.grantable
                    , c.hierarchy
                    -- , c.common       /* DB version >= 12.1 */
                    -- , c.inherited    /* DB version >= 12.2 */
                order by
                    case c.object_type
                        when 'TABLE' 
                            then decode(c.privilege, 'ALTER', '1', 'READ', '2', 'SELECT', '3',
                                        'INSERT', '4', 'UPDATE', '5', 'DELETE', '6', c.privilege)
                        else
                            c.privilege
                    end)
            as rn
    from
        (select distinct  /* Note: each priv may have been granted
                             more than once by distinct grantors */
            a.grantee
            , a.privilege
            , b.owner
            , b.object_type
            , b.object_name
            , null as column_name
            , a.grantable
            , a.hierarchy
            -- , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_tab_privs a,
            dba_objects b
        where
            a.owner = b.owner
            and a.table_name = b.object_name
            -- and a.type = b.object_type   /* DB version >= 12.1 */
            and b.owner = :OWNER
            and b.object_type = 'TABLE'
            and b.object_name = :TABLE_NAME
        union all
        select distinct
            a.grantee
            , a.privilege
            , a.owner
            , 'TABLE COLUMN'    as object_type
            , a.table_name      as object_name
            , a.column_name
            , a.grantable
            , null              as hierarchy
            -- , a.common       /* DB version >= 12.1 */
            -- , a.inherited    /* DB version >= 12.2 */
        from
            dba_col_privs a
        where
            a.owner = :OWNER
            and a.table_name = :TABLE_NAME
        ) c
    ) d
group by
    grantee
    , owner
    , object_type
    , object_name
    , column_name
    , grantable
    , hierarchy
    -- , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
order by
    owner
    , d.object_name
    , grantee
    , d.column_name  nulls first
    , object_privs
    , grantable
    , hierarchy
    -- , common         /* DB version >= 12.1 */
    -- , inherited      /* DB version >= 12.2 */
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
        </queries>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
	<display id="null" type="" style="Table" enable="true">
		<name><![CDATA[References]]></name>
		<description><![CDATA[]]></description>
		<tooltip><![CDATA[]]></tooltip>
		<drillclass><![CDATA[]]></drillclass>
		<CustomValues>
			<TYPE><![CDATA[horizontal]]></TYPE>
		</CustomValues>
		<query>
			<sql><![CDATA[select 
    owner,
    name,
    type,
    referenced_owner,
    referenced_name,
    referenced_type,
    dependency_type
from 
    dba_dependencies
where
    referenced_owner = :OWNER
    and referenced_name = :TABLE_NAME
order by
    owner, name, type
]]></sql>
			<binds>
				<bind id="OWNER">
					<prompt><![CDATA[OWNER]]></prompt>
					<tooltip><![CDATA[OWNER]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
				<bind id="TABLE_NAME">
					<prompt><![CDATA[TABLE_NAME]]></prompt>
					<tooltip><![CDATA[TABLE_NAME]]></tooltip>
					<value><![CDATA[NULL_VALUE]]></value>
					<bracket><![CDATA[null]]></bracket>
				</bind>
			</binds>
		</query>
			<pdf version="VERSION_1_7" compression="CONTENT">
				<docproperty title="" author="" subject="" keywords="" />
				<cell toppadding="2" bottompadding="2" leftpadding="2" rightpadding="2" horizontalalign="LEFT" verticalalign="TOP" wrap="true" />
				<column>
					<heading font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="FIRST_PAGE" />
					<footing font="null" size="10" style="NORMAL" color="-16777216" rowshading="-1" labeling="NONE" />
					<blob blob="NONE" zip="false" />
				</column>
				<table font="Times New Roman" size="10" style="NORMAL" color="-16777216" userowshading="false" oddrowshading="-1" evenrowshading="-1" showborders="true" spacingbefore="12" spacingafter="12" horizontalalign="LEFT" />
				<header enable="false" generatedate="false">
					<data>
					null					</data>
				</header>
				<footer enable="false" generatedate="false">
					<data value="null" />
				</footer>
				<pagesetup papersize="LETTER" orientation="1" measurement="in" margintop="1.0" marginbottom="1.0" marginleft="1.0" marginright="1.0" />
			</pdf>
	</display>
</display>
</displays>
